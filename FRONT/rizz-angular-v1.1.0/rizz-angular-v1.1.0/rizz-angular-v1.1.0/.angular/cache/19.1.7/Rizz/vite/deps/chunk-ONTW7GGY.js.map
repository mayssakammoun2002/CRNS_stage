{
  "version": 3,
  "sources": ["../../../../../../node_modules/@uppy/utils/lib/toArray.js", "../../../../../../node_modules/@uppy/utils/lib/getDroppedFiles/utils/webkitGetAsEntryApi/getFilesAndDirectoriesFromDirectory.js", "../../../../../../node_modules/@uppy/utils/lib/getDroppedFiles/utils/webkitGetAsEntryApi/index.js", "../../../../../../node_modules/@uppy/utils/lib/getDroppedFiles/utils/fallbackApi.js", "../../../../../../node_modules/@uppy/utils/lib/getDroppedFiles/index.js", "../../../../../../node_modules/@uppy/utils/lib/isDragDropSupported.js"],
  "sourcesContent": ["/**\n * Converts list into array\n */\nexport default Array.from;", "/**\n * Recursive function, calls the original callback() when the directory is entirely parsed.\n */\nexport default function getFilesAndDirectoriesFromDirectory(directoryReader, oldEntries, logDropError, _ref) {\n  let {\n    onSuccess\n  } = _ref;\n  directoryReader.readEntries(entries => {\n    const newEntries = [...oldEntries, ...entries];\n    // According to the FileSystem API spec, getFilesAndDirectoriesFromDirectory()\n    // must be called until it calls the onSuccess with an empty array.\n    if (entries.length) {\n      queueMicrotask(() => {\n        getFilesAndDirectoriesFromDirectory(directoryReader, newEntries, logDropError, {\n          onSuccess\n        });\n      });\n      // Done iterating this particular directory\n    } else {\n      onSuccess(newEntries);\n    }\n  },\n  // Make sure we resolve on error anyway, it's fine if only one directory couldn't be parsed!\n  error => {\n    logDropError(error);\n    onSuccess(oldEntries);\n  });\n}", "import getFilesAndDirectoriesFromDirectory from \"./getFilesAndDirectoriesFromDirectory.js\";\n/**\n * Polyfill for the new (experimental) getAsFileSystemHandle API (using the popular webkitGetAsEntry behind the scenes)\n * so that we can switch to the getAsFileSystemHandle API once it (hopefully) becomes standard\n */\nfunction getAsFileSystemHandleFromEntry(entry, logDropError) {\n  if (entry == null) return entry;\n  return {\n    kind:\n    // eslint-disable-next-line no-nested-ternary\n    entry.isFile ? 'file' : entry.isDirectory ? 'directory' : undefined,\n    name: entry.name,\n    getFile() {\n      return new Promise((resolve, reject) => entry.file(resolve, reject));\n    },\n    async *values() {\n      // If the file is a directory.\n      const directoryReader = entry.createReader();\n      const entries = await new Promise(resolve => {\n        getFilesAndDirectoriesFromDirectory(directoryReader, [], logDropError, {\n          onSuccess: dirEntries => resolve(dirEntries.map(file => getAsFileSystemHandleFromEntry(file, logDropError)))\n        });\n      });\n      yield* entries;\n    },\n    isSameEntry: undefined\n  };\n}\nfunction createPromiseToAddFileOrParseDirectory(entry, relativePath, lastResortFile) {\n  try {\n    if (lastResortFile === void 0) {\n      lastResortFile = undefined;\n    }\n    return async function* () {\n      const getNextRelativePath = () => `${relativePath}/${entry.name}`;\n\n      // For each dropped item, - make sure it's a file/directory, and start deepening in!\n      if (entry.kind === 'file') {\n        const file = await entry.getFile();\n        if (file != null) {\n          ;\n          file.relativePath = relativePath ? getNextRelativePath() : null;\n          yield file;\n        } else if (lastResortFile != null) yield lastResortFile;\n      } else if (entry.kind === 'directory') {\n        for await (const handle of entry.values()) {\n          // Recurse on the directory, appending the dir name to the relative path\n          yield* createPromiseToAddFileOrParseDirectory(handle, relativePath ? getNextRelativePath() : entry.name);\n        }\n      } else if (lastResortFile != null) yield lastResortFile;\n    }();\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Load all files from data transfer, and recursively read any directories.\n * Note that IE is not supported for drag-drop, because IE doesn't support Data Transfers\n *\n * @param {DataTransfer} dataTransfer\n * @param {*} logDropError on error\n */\nexport default async function* getFilesFromDataTransfer(dataTransfer, logDropError) {\n  // Retrieving the dropped items must happen synchronously\n  // otherwise only the first item gets treated and the other ones are garbage collected.\n  // https://github.com/transloadit/uppy/pull/3998\n  const fileSystemHandles = await Promise.all(Array.from(dataTransfer.items, async item => {\n    var _fileSystemHandle;\n    let fileSystemHandle;\n\n    // TODO enable getAsFileSystemHandle API once we can get it working with subdirectories\n    // IMPORTANT: Need to check isSecureContext *before* calling getAsFileSystemHandle\n    // or else Chrome will crash when running in HTTP: https://github.com/transloadit/uppy/issues/4133\n    // if (window.isSecureContext && item.getAsFileSystemHandle != null)\n    // fileSystemHandle = await item.getAsFileSystemHandle()\n\n    // `webkitGetAsEntry` exists in all popular browsers (including non-WebKit browsers),\n    // however it may be renamed to getAsEntry() in the future, so you should code defensively, looking for both.\n    // from https://developer.mozilla.org/en-US/docs/Web/API/DataTransferItem/webkitGetAsEntry\n    const getAsEntry = () => typeof item.getAsEntry === 'function' ? item.getAsEntry() : item.webkitGetAsEntry();\n    // eslint-disable-next-line prefer-const\n    (_fileSystemHandle = fileSystemHandle) != null ? _fileSystemHandle : fileSystemHandle = getAsFileSystemHandleFromEntry(getAsEntry(), logDropError);\n    return {\n      fileSystemHandle,\n      lastResortFile: item.getAsFile() // can be used as a fallback in case other methods fail\n    };\n  }));\n  for (const {\n    lastResortFile,\n    fileSystemHandle\n  } of fileSystemHandles) {\n    // fileSystemHandle and lastResortFile can be null when we drop an url.\n    if (fileSystemHandle != null) {\n      try {\n        yield* createPromiseToAddFileOrParseDirectory(fileSystemHandle, '', lastResortFile);\n      } catch (err) {\n        // Example: If dropping a symbolic link, Chromium will throw:\n        // \"DOMException: A requested file or directory could not be found at the time an operation was processed.\",\n        // So we will use lastResortFile instead. See https://github.com/transloadit/uppy/issues/3505.\n        if (lastResortFile != null) {\n          yield lastResortFile;\n        } else {\n          logDropError(err);\n        }\n      }\n    } else if (lastResortFile != null) yield lastResortFile;\n  }\n}", "import toArray from \"../../toArray.js\";\n\n// .files fallback, should be implemented in any browser\nexport default function fallbackApi(dataTransfer) {\n  const files = toArray(dataTransfer.files);\n  return Promise.resolve(files);\n}", "import webkitGetAsEntryApi from \"./utils/webkitGetAsEntryApi/index.js\";\nimport fallbackApi from \"./utils/fallbackApi.js\";\n\n/**\n * Returns a promise that resolves to the array of dropped files (if a folder is\n * dropped, and browser supports folder parsing - promise resolves to the flat\n * array of all files in all directories).\n * Each file has .relativePath prop appended to it (e.g. \"/docs/Prague/ticket_from_prague_to_ufa.pdf\")\n * if browser supports it. Otherwise it's undefined.\n *\n * @param dataTransfer\n * @param options\n * @param options.logDropError - a function that's called every time some\n * folder or some file error out (e.g. because of the folder name being too long\n * on Windows). Notice that resulting promise will always be resolved anyway.\n *\n * @returns {Promise} - Array<File>\n */\nexport default async function getDroppedFiles(dataTransfer, options) {\n  var _options$logDropError;\n  // Get all files from all subdirs. Works (at least) in Chrome, Mozilla, and Safari\n  const logDropError = (_options$logDropError = options == null ? void 0 : options.logDropError) != null ? _options$logDropError : Function.prototype;\n  try {\n    const accumulator = [];\n    for await (const file of webkitGetAsEntryApi(dataTransfer, logDropError)) {\n      accumulator.push(file);\n    }\n    return accumulator;\n    // Otherwise just return all first-order files\n  } catch {\n    return fallbackApi(dataTransfer);\n  }\n}", "/**\n * Checks if the browser supports Drag & Drop (not supported on mobile devices, for example).\n */\nexport default function isDragDropSupported() {\n  const div = document.body;\n  if (!('draggable' in div) || !('ondragstart' in div && 'ondrop' in div)) {\n    return false;\n  }\n  if (!('FormData' in window)) {\n    return false;\n  }\n  if (!('FileReader' in window)) {\n    return false;\n  }\n  return true;\n}"],
  "mappings": "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",
  "names": []
}
