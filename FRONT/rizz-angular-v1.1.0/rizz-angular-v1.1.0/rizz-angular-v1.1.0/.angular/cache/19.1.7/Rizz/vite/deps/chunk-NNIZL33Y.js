import {
  __commonJS
} from "./chunk-APYJOV5E.js";

// node_modules/tui-chart/node_modules/raphael/raphael.min.js
var require_raphael_min = __commonJS({
  "node_modules/tui-chart/node_modules/raphael/raphael.min.js"(exports, module) {
    !function t(e, r) {
      "object" == typeof exports && "object" == typeof module ? module.exports = r() : "function" == typeof define && define.amd ? define("Raphael", [], r) : "object" == typeof exports ? exports.Raphael = r() : e.Raphael = r();
    }(exports, function() {
      return function(t) {
        function e(i) {
          if (r[i]) return r[i].exports;
          var n = r[i] = {
            exports: {},
            id: i,
            loaded: false
          };
          return t[i].call(n.exports, n, n.exports, e), n.loaded = true, n.exports;
        }
        var r = {};
        return e.m = t, e.c = r, e.p = "", e(0);
      }([function(t, e, r) {
        var i, n;
        i = [r(1), r(3), r(4)], n = function(t2) {
          return t2;
        }.apply(e, i), !(void 0 !== n && (t.exports = n));
      }, function(t, e, r) {
        var i, n;
        i = [r(2)], n = function(t2) {
          function e2(r3) {
            if (e2.is(r3, "function")) return w ? r3() : t2.on("raphael.DOMload", r3);
            if (e2.is(r3, Q)) return e2._engine.create[z](e2, r3.splice(0, 3 + e2.is(r3[0], $))).add(r3);
            var i3 = Array.prototype.slice.call(arguments, 0);
            if (e2.is(i3[i3.length - 1], "function")) {
              var n3 = i3.pop();
              return w ? n3.call(e2._engine.create[z](e2, i3)) : t2.on("raphael.DOMload", function() {
                n3.call(e2._engine.create[z](e2, i3));
              });
            }
            return e2._engine.create[z](e2, arguments);
          }
          function r2(t3) {
            if ("function" == typeof t3 || Object(t3) !== t3) return t3;
            var e3 = new t3.constructor();
            for (var i3 in t3) t3[T](i3) && (e3[i3] = r2(t3[i3]));
            return e3;
          }
          function i2(t3, e3) {
            for (var r3 = 0, i3 = t3.length; r3 < i3; r3++) if (t3[r3] === e3) return t3.push(t3.splice(r3, 1)[0]);
          }
          function n2(t3, e3, r3) {
            function n3() {
              var a2 = Array.prototype.slice.call(arguments, 0), s2 = a2.join("␀"), o2 = n3.cache = n3.cache || {}, l2 = n3.count = n3.count || [];
              return o2[T](s2) ? (i2(l2, s2), r3 ? r3(o2[s2]) : o2[s2]) : (l2.length >= 1e3 && delete o2[l2.shift()], l2.push(s2), o2[s2] = t3[z](e3, a2), r3 ? r3(o2[s2]) : o2[s2]);
            }
            return n3;
          }
          function a() {
            return this.hex;
          }
          function s(t3, e3) {
            for (var r3 = [], i3 = 0, n3 = t3.length; n3 - 2 * !e3 > i3; i3 += 2) {
              var a2 = [{
                x: +t3[i3 - 2],
                y: +t3[i3 - 1]
              }, {
                x: +t3[i3],
                y: +t3[i3 + 1]
              }, {
                x: +t3[i3 + 2],
                y: +t3[i3 + 3]
              }, {
                x: +t3[i3 + 4],
                y: +t3[i3 + 5]
              }];
              e3 ? i3 ? n3 - 4 == i3 ? a2[3] = {
                x: +t3[0],
                y: +t3[1]
              } : n3 - 2 == i3 && (a2[2] = {
                x: +t3[0],
                y: +t3[1]
              }, a2[3] = {
                x: +t3[2],
                y: +t3[3]
              }) : a2[0] = {
                x: +t3[n3 - 2],
                y: +t3[n3 - 1]
              } : n3 - 4 == i3 ? a2[3] = a2[2] : i3 || (a2[0] = {
                x: +t3[i3],
                y: +t3[i3 + 1]
              }), r3.push(["C", (-a2[0].x + 6 * a2[1].x + a2[2].x) / 6, (-a2[0].y + 6 * a2[1].y + a2[2].y) / 6, (a2[1].x + 6 * a2[2].x - a2[3].x) / 6, (a2[1].y + 6 * a2[2].y - a2[3].y) / 6, a2[2].x, a2[2].y]);
            }
            return r3;
          }
          function o(t3, e3, r3, i3, n3) {
            var a2 = -3 * e3 + 9 * r3 - 9 * i3 + 3 * n3, s2 = t3 * a2 + 6 * e3 - 12 * r3 + 6 * i3;
            return t3 * s2 - 3 * e3 + 3 * r3;
          }
          function l(t3, e3, r3, i3, n3, a2, s2, l2, h2) {
            null == h2 && (h2 = 1), h2 = h2 > 1 ? 1 : h2 < 0 ? 0 : h2;
            for (var u2 = h2 / 2, c2 = 12, f2 = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816], p2 = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472], d2 = 0, g2 = 0; g2 < c2; g2++) {
              var x2 = u2 * f2[g2] + u2, v2 = o(x2, t3, r3, n3, s2), y2 = o(x2, e3, i3, a2, l2), m2 = v2 * v2 + y2 * y2;
              d2 += p2[g2] * Y.sqrt(m2);
            }
            return u2 * d2;
          }
          function h(t3, e3, r3, i3, n3, a2, s2, o2, h2) {
            if (!(h2 < 0 || l(t3, e3, r3, i3, n3, a2, s2, o2) < h2)) {
              var u2 = 1, c2 = u2 / 2, f2 = u2 - c2, p2, d2 = 0.01;
              for (p2 = l(t3, e3, r3, i3, n3, a2, s2, o2, f2); H(p2 - h2) > d2; ) c2 /= 2, f2 += (p2 < h2 ? 1 : -1) * c2, p2 = l(t3, e3, r3, i3, n3, a2, s2, o2, f2);
              return f2;
            }
          }
          function u(t3, e3, r3, i3, n3, a2, s2, o2) {
            if (!(W(t3, r3) < G(n3, s2) || G(t3, r3) > W(n3, s2) || W(e3, i3) < G(a2, o2) || G(e3, i3) > W(a2, o2))) {
              var l2 = (t3 * i3 - e3 * r3) * (n3 - s2) - (t3 - r3) * (n3 * o2 - a2 * s2), h2 = (t3 * i3 - e3 * r3) * (a2 - o2) - (e3 - i3) * (n3 * o2 - a2 * s2), u2 = (t3 - r3) * (a2 - o2) - (e3 - i3) * (n3 - s2);
              if (u2) {
                var c2 = l2 / u2, f2 = h2 / u2, p2 = +c2.toFixed(2), d2 = +f2.toFixed(2);
                if (!(p2 < +G(t3, r3).toFixed(2) || p2 > +W(t3, r3).toFixed(2) || p2 < +G(n3, s2).toFixed(2) || p2 > +W(n3, s2).toFixed(2) || d2 < +G(e3, i3).toFixed(2) || d2 > +W(e3, i3).toFixed(2) || d2 < +G(a2, o2).toFixed(2) || d2 > +W(a2, o2).toFixed(2))) return {
                  x: c2,
                  y: f2
                };
              }
            }
          }
          function c(t3, e3) {
            return p(t3, e3);
          }
          function f(t3, e3) {
            return p(t3, e3, 1);
          }
          function p(t3, r3, i3) {
            var n3 = e2.bezierBBox(t3), a2 = e2.bezierBBox(r3);
            if (!e2.isBBoxIntersect(n3, a2)) return i3 ? 0 : [];
            for (var s2 = l.apply(0, t3), o2 = l.apply(0, r3), h2 = W(~~(s2 / 5), 1), c2 = W(~~(o2 / 5), 1), f2 = [], p2 = [], d2 = {}, g2 = i3 ? 0 : [], x2 = 0; x2 < h2 + 1; x2++) {
              var v2 = e2.findDotsAtSegment.apply(e2, t3.concat(x2 / h2));
              f2.push({
                x: v2.x,
                y: v2.y,
                t: x2 / h2
              });
            }
            for (x2 = 0; x2 < c2 + 1; x2++) v2 = e2.findDotsAtSegment.apply(e2, r3.concat(x2 / c2)), p2.push({
              x: v2.x,
              y: v2.y,
              t: x2 / c2
            });
            for (x2 = 0; x2 < h2; x2++) for (var y2 = 0; y2 < c2; y2++) {
              var m2 = f2[x2], b2 = f2[x2 + 1], _2 = p2[y2], w2 = p2[y2 + 1], k2 = H(b2.x - m2.x) < 1e-3 ? "y" : "x", B2 = H(w2.x - _2.x) < 1e-3 ? "y" : "x", C2 = u(m2.x, m2.y, b2.x, b2.y, _2.x, _2.y, w2.x, w2.y);
              if (C2) {
                if (d2[C2.x.toFixed(4)] == C2.y.toFixed(4)) continue;
                d2[C2.x.toFixed(4)] = C2.y.toFixed(4);
                var S2 = m2.t + H((C2[k2] - m2[k2]) / (b2[k2] - m2[k2])) * (b2.t - m2.t), T2 = _2.t + H((C2[B2] - _2[B2]) / (w2[B2] - _2[B2])) * (w2.t - _2.t);
                S2 >= 0 && S2 <= 1.001 && T2 >= 0 && T2 <= 1.001 && (i3 ? g2++ : g2.push({
                  x: C2.x,
                  y: C2.y,
                  t1: G(S2, 1),
                  t2: G(T2, 1)
                }));
              }
            }
            return g2;
          }
          function d(t3, r3, i3) {
            t3 = e2._path2curve(t3), r3 = e2._path2curve(r3);
            for (var n3, a2, s2, o2, l2, h2, u2, c2, f2, d2, g2 = i3 ? 0 : [], x2 = 0, v2 = t3.length; x2 < v2; x2++) {
              var y2 = t3[x2];
              if ("M" == y2[0]) n3 = l2 = y2[1], a2 = h2 = y2[2];
              else {
                "C" == y2[0] ? (f2 = [n3, a2].concat(y2.slice(1)), n3 = f2[6], a2 = f2[7]) : (f2 = [n3, a2, n3, a2, l2, h2, l2, h2], n3 = l2, a2 = h2);
                for (var m2 = 0, b2 = r3.length; m2 < b2; m2++) {
                  var _2 = r3[m2];
                  if ("M" == _2[0]) s2 = u2 = _2[1], o2 = c2 = _2[2];
                  else {
                    "C" == _2[0] ? (d2 = [s2, o2].concat(_2.slice(1)), s2 = d2[6], o2 = d2[7]) : (d2 = [s2, o2, s2, o2, u2, c2, u2, c2], s2 = u2, o2 = c2);
                    var w2 = p(f2, d2, i3);
                    if (i3) g2 += w2;
                    else {
                      for (var k2 = 0, B2 = w2.length; k2 < B2; k2++) w2[k2].segment1 = x2, w2[k2].segment2 = m2, w2[k2].bez1 = f2, w2[k2].bez2 = d2;
                      g2 = g2.concat(w2);
                    }
                  }
                }
              }
            }
            return g2;
          }
          function g(t3, e3, r3, i3, n3, a2) {
            null != t3 ? (this.a = +t3, this.b = +e3, this.c = +r3, this.d = +i3, this.e = +n3, this.f = +a2) : (this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0);
          }
          function x() {
            return this.x + I + this.y;
          }
          function v() {
            return this.x + I + this.y + I + this.width + " × " + this.height;
          }
          function y(t3, e3, r3, i3, n3, a2) {
            function s2(t4) {
              return ((c2 * t4 + u2) * t4 + h2) * t4;
            }
            function o2(t4, e4) {
              var r4 = l2(t4, e4);
              return ((d2 * r4 + p2) * r4 + f2) * r4;
            }
            function l2(t4, e4) {
              var r4, i4, n4, a3, o3, l3;
              for (n4 = t4, l3 = 0; l3 < 8; l3++) {
                if (a3 = s2(n4) - t4, H(a3) < e4) return n4;
                if (o3 = (3 * c2 * n4 + 2 * u2) * n4 + h2, H(o3) < 1e-6) break;
                n4 -= a3 / o3;
              }
              if (r4 = 0, i4 = 1, n4 = t4, n4 < r4) return r4;
              if (n4 > i4) return i4;
              for (; r4 < i4; ) {
                if (a3 = s2(n4), H(a3 - t4) < e4) return n4;
                t4 > a3 ? r4 = n4 : i4 = n4, n4 = (i4 - r4) / 2 + r4;
              }
              return n4;
            }
            var h2 = 3 * e3, u2 = 3 * (i3 - e3) - h2, c2 = 1 - h2 - u2, f2 = 3 * r3, p2 = 3 * (n3 - r3) - f2, d2 = 1 - f2 - p2;
            return o2(t3, 1 / (200 * a2));
          }
          function m(t3, e3) {
            var r3 = [], i3 = {};
            if (this.ms = e3, this.times = 1, t3) {
              for (var n3 in t3) t3[T](n3) && (i3[ht(n3)] = t3[n3], r3.push(ht(n3)));
              r3.sort(Bt);
            }
            this.anim = i3, this.top = r3[r3.length - 1], this.percents = r3;
          }
          function b(r3, i3, n3, a2, s2, o2) {
            n3 = ht(n3);
            var l2, h2, u2, c2 = [], f2, p2, d2, x2 = r3.ms, v2 = {}, m2 = {}, b2 = {};
            if (a2) for (w2 = 0, B2 = Ee.length; w2 < B2; w2++) {
              var _2 = Ee[w2];
              if (_2.el.id == i3.id && _2.anim == r3) {
                _2.percent != n3 ? (Ee.splice(w2, 1), u2 = 1) : h2 = _2, i3.attr(_2.totalOrigin);
                break;
              }
            }
            else a2 = +m2;
            for (var w2 = 0, B2 = r3.percents.length; w2 < B2; w2++) {
              if (r3.percents[w2] == n3 || r3.percents[w2] > a2 * r3.top) {
                n3 = r3.percents[w2], p2 = r3.percents[w2 - 1] || 0, x2 = x2 / r3.top * (n3 - p2), f2 = r3.percents[w2 + 1], l2 = r3.anim[n3];
                break;
              }
              a2 && i3.attr(r3.anim[r3.percents[w2]]);
            }
            if (l2) {
              if (h2) h2.initstatus = a2, h2.start = /* @__PURE__ */ new Date() - h2.ms * a2;
              else {
                for (var C2 in l2) if (l2[T](C2) && (pt[T](C2) || i3.paper.customAttributes[T](C2))) switch (v2[C2] = i3.attr(C2), null == v2[C2] && (v2[C2] = ft[C2]), m2[C2] = l2[C2], pt[C2]) {
                  case $:
                    b2[C2] = (m2[C2] - v2[C2]) / x2;
                    break;
                  case "colour":
                    v2[C2] = e2.getRGB(v2[C2]);
                    var S2 = e2.getRGB(m2[C2]);
                    b2[C2] = {
                      r: (S2.r - v2[C2].r) / x2,
                      g: (S2.g - v2[C2].g) / x2,
                      b: (S2.b - v2[C2].b) / x2
                    };
                    break;
                  case "path":
                    var A2 = Qt(v2[C2], m2[C2]), E2 = A2[1];
                    for (v2[C2] = A2[0], b2[C2] = [], w2 = 0, B2 = v2[C2].length; w2 < B2; w2++) {
                      b2[C2][w2] = [0];
                      for (var N2 = 1, M2 = v2[C2][w2].length; N2 < M2; N2++) b2[C2][w2][N2] = (E2[w2][N2] - v2[C2][w2][N2]) / x2;
                    }
                    break;
                  case "transform":
                    var L2 = i3._, z2 = le(L2[C2], m2[C2]);
                    if (z2) for (v2[C2] = z2.from, m2[C2] = z2.to, b2[C2] = [], b2[C2].real = true, w2 = 0, B2 = v2[C2].length; w2 < B2; w2++) for (b2[C2][w2] = [v2[C2][w2][0]], N2 = 1, M2 = v2[C2][w2].length; N2 < M2; N2++) b2[C2][w2][N2] = (m2[C2][w2][N2] - v2[C2][w2][N2]) / x2;
                    else {
                      var F2 = i3.matrix || new g(), R2 = {
                        _: {
                          transform: L2.transform
                        },
                        getBBox: function() {
                          return i3.getBBox(1);
                        }
                      };
                      v2[C2] = [F2.a, F2.b, F2.c, F2.d, F2.e, F2.f], se(R2, m2[C2]), m2[C2] = R2._.transform, b2[C2] = [(R2.matrix.a - F2.a) / x2, (R2.matrix.b - F2.b) / x2, (R2.matrix.c - F2.c) / x2, (R2.matrix.d - F2.d) / x2, (R2.matrix.e - F2.e) / x2, (R2.matrix.f - F2.f) / x2];
                    }
                    break;
                  case "csv":
                    var I2 = j(l2[C2])[q](k), D2 = j(v2[C2])[q](k);
                    if ("clip-rect" == C2) for (v2[C2] = D2, b2[C2] = [], w2 = D2.length; w2--; ) b2[C2][w2] = (I2[w2] - v2[C2][w2]) / x2;
                    m2[C2] = I2;
                    break;
                  default:
                    for (I2 = [][P](l2[C2]), D2 = [][P](v2[C2]), b2[C2] = [], w2 = i3.paper.customAttributes[C2].length; w2--; ) b2[C2][w2] = ((I2[w2] || 0) - (D2[w2] || 0)) / x2;
                }
                var V2 = l2.easing, O2 = e2.easing_formulas[V2];
                if (!O2) if (O2 = j(V2).match(st), O2 && 5 == O2.length) {
                  var Y2 = O2;
                  O2 = function(t3) {
                    return y(t3, +Y2[1], +Y2[2], +Y2[3], +Y2[4], x2);
                  };
                } else O2 = St;
                if (d2 = l2.start || r3.start || +/* @__PURE__ */ new Date(), _2 = {
                  anim: r3,
                  percent: n3,
                  timestamp: d2,
                  start: d2 + (r3.del || 0),
                  status: 0,
                  initstatus: a2 || 0,
                  stop: false,
                  ms: x2,
                  easing: O2,
                  from: v2,
                  diff: b2,
                  to: m2,
                  el: i3,
                  callback: l2.callback,
                  prev: p2,
                  next: f2,
                  repeat: o2 || r3.times,
                  origin: i3.attr(),
                  totalOrigin: s2
                }, Ee.push(_2), a2 && !h2 && !u2 && (_2.stop = true, _2.start = /* @__PURE__ */ new Date() - x2 * a2, 1 == Ee.length)) return Me();
                u2 && (_2.start = /* @__PURE__ */ new Date() - _2.ms * a2), 1 == Ee.length && Ne(Me);
              }
              t2("raphael.anim.start." + i3.id, i3, r3);
            }
          }
          function _(t3) {
            for (var e3 = 0; e3 < Ee.length; e3++) Ee[e3].el.paper == t3 && Ee.splice(e3--, 1);
          }
          e2.version = "@@VERSION", e2.eve = t2;
          var w, k = /[, ]+/, B = {
            circle: 1,
            rect: 1,
            path: 1,
            ellipse: 1,
            text: 1,
            image: 1
          }, C = /\{(\d+)\}/g, S = "prototype", T = "hasOwnProperty", A = {
            doc: document,
            win: window
          }, E = {
            was: Object.prototype[T].call(A.win, "Raphael"),
            is: A.win.Raphael
          }, N = function() {
            this.ca = this.customAttributes = {};
          }, M, L = "appendChild", z = "apply", P = "concat", F = "ontouchstart" in A.win || A.win.DocumentTouch && A.doc instanceof DocumentTouch, R = "", I = " ", j = String, q = "split", D = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[q](I), V = {
            mousedown: "touchstart",
            mousemove: "touchmove",
            mouseup: "touchend"
          }, O = j.prototype.toLowerCase, Y = Math, W = Y.max, G = Y.min, H = Y.abs, X = Y.pow, U = Y.PI, $ = "number", Z = "string", Q = "array", J = "toString", K = "fill", tt = Object.prototype.toString, et = {}, rt = "push", it = e2._ISURL = /^url\(['"]?(.+?)['"]?\)$/i, nt = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i, at = {
            NaN: 1,
            Infinity: 1,
            "-Infinity": 1
          }, st = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/, ot = Y.round, lt = "setAttribute", ht = parseFloat, ut = parseInt, ct = j.prototype.toUpperCase, ft = e2._availableAttrs = {
            "arrow-end": "none",
            "arrow-start": "none",
            blur: 0,
            "clip-rect": "0 0 1e9 1e9",
            cursor: "default",
            cx: 0,
            cy: 0,
            fill: "#fff",
            "fill-opacity": 1,
            font: '10px "Arial"',
            "font-family": '"Arial"',
            "font-size": "10",
            "font-style": "normal",
            "font-weight": 400,
            gradient: 0,
            height: 0,
            href: "http://raphaeljs.com/",
            "letter-spacing": 0,
            opacity: 1,
            path: "M0,0",
            r: 0,
            rx: 0,
            ry: 0,
            src: "",
            stroke: "#000",
            "stroke-dasharray": "",
            "stroke-linecap": "butt",
            "stroke-linejoin": "butt",
            "stroke-miterlimit": 0,
            "stroke-opacity": 1,
            "stroke-width": 1,
            target: "_blank",
            "text-anchor": "middle",
            title: "Raphael",
            transform: "",
            width: 0,
            x: 0,
            y: 0
          }, pt = e2._availableAnimAttrs = {
            blur: $,
            "clip-rect": "csv",
            cx: $,
            cy: $,
            fill: "colour",
            "fill-opacity": $,
            "font-size": $,
            height: $,
            opacity: $,
            path: "path",
            r: $,
            rx: $,
            ry: $,
            stroke: "colour",
            "stroke-opacity": $,
            "stroke-width": $,
            transform: "transform",
            width: $,
            x: $,
            y: $
          }, dt = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g, gt = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/, xt = {
            hs: 1,
            rg: 1
          }, vt = /,?([achlmqrstvxz]),?/gi, yt = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/gi, mt = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/gi, bt = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/gi, _t = e2._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/, wt = {}, kt = function(t3, e3) {
            return t3.key - e3.key;
          }, Bt = function(t3, e3) {
            return ht(t3) - ht(e3);
          }, Ct = function() {
          }, St = function(t3) {
            return t3;
          }, Tt = e2._rectPath = function(t3, e3, r3, i3, n3) {
            return n3 ? [["M", t3 + n3, e3], ["l", r3 - 2 * n3, 0], ["a", n3, n3, 0, 0, 1, n3, n3], ["l", 0, i3 - 2 * n3], ["a", n3, n3, 0, 0, 1, -n3, n3], ["l", 2 * n3 - r3, 0], ["a", n3, n3, 0, 0, 1, -n3, -n3], ["l", 0, 2 * n3 - i3], ["a", n3, n3, 0, 0, 1, n3, -n3], ["z"]] : [["M", t3, e3], ["l", r3, 0], ["l", 0, i3], ["l", -r3, 0], ["z"]];
          }, At = function(t3, e3, r3, i3) {
            return null == i3 && (i3 = r3), [["M", t3, e3], ["m", 0, -i3], ["a", r3, i3, 0, 1, 1, 0, 2 * i3], ["a", r3, i3, 0, 1, 1, 0, -2 * i3], ["z"]];
          }, Et = e2._getPath = {
            path: function(t3) {
              return t3.attr("path");
            },
            circle: function(t3) {
              var e3 = t3.attrs;
              return At(e3.cx, e3.cy, e3.r);
            },
            ellipse: function(t3) {
              var e3 = t3.attrs;
              return At(e3.cx, e3.cy, e3.rx, e3.ry);
            },
            rect: function(t3) {
              var e3 = t3.attrs;
              return Tt(e3.x, e3.y, e3.width, e3.height, e3.r);
            },
            image: function(t3) {
              var e3 = t3.attrs;
              return Tt(e3.x, e3.y, e3.width, e3.height);
            },
            text: function(t3) {
              var e3 = t3._getBBox();
              return Tt(e3.x, e3.y, e3.width, e3.height);
            },
            set: function(t3) {
              var e3 = t3._getBBox();
              return Tt(e3.x, e3.y, e3.width, e3.height);
            }
          }, Nt = e2.mapPath = function(t3, e3) {
            if (!e3) return t3;
            var r3, i3, n3, a2, s2, o2, l2;
            for (t3 = Qt(t3), n3 = 0, s2 = t3.length; n3 < s2; n3++) for (l2 = t3[n3], a2 = 1, o2 = l2.length; a2 < o2; a2 += 2) r3 = e3.x(l2[a2], l2[a2 + 1]), i3 = e3.y(l2[a2], l2[a2 + 1]), l2[a2] = r3, l2[a2 + 1] = i3;
            return t3;
          };
          if (e2._g = A, e2.type = A.win.SVGAngle || A.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML", "VML" == e2.type) {
            var Mt = A.doc.createElement("div"), Lt;
            if (Mt.innerHTML = '<v:shape adj="1"/>', Lt = Mt.firstChild, Lt.style.behavior = "url(#default#VML)", !Lt || "object" != typeof Lt.adj) return e2.type = R;
            Mt = null;
          }
          e2.svg = !(e2.vml = "VML" == e2.type), e2._Paper = N, e2.fn = M = N.prototype = e2.prototype, e2._id = 0, e2._oid = 0, e2.is = function(t3, e3) {
            return e3 = O.call(e3), "finite" == e3 ? !at[T](+t3) : "array" == e3 ? t3 instanceof Array : "null" == e3 && null === t3 || e3 == typeof t3 && null !== t3 || "object" == e3 && t3 === Object(t3) || "array" == e3 && Array.isArray && Array.isArray(t3) || tt.call(t3).slice(8, -1).toLowerCase() == e3;
          }, e2.angle = function(t3, r3, i3, n3, a2, s2) {
            if (null == a2) {
              var o2 = t3 - i3, l2 = r3 - n3;
              return o2 || l2 ? (180 + 180 * Y.atan2(-l2, -o2) / U + 360) % 360 : 0;
            }
            return e2.angle(t3, r3, a2, s2) - e2.angle(i3, n3, a2, s2);
          }, e2.rad = function(t3) {
            return t3 % 360 * U / 180;
          }, e2.deg = function(t3) {
            return Math.round(180 * t3 / U % 360 * 1e3) / 1e3;
          }, e2.snapTo = function(t3, r3, i3) {
            if (i3 = e2.is(i3, "finite") ? i3 : 10, e2.is(t3, Q)) {
              for (var n3 = t3.length; n3--; ) if (H(t3[n3] - r3) <= i3) return t3[n3];
            } else {
              t3 = +t3;
              var a2 = r3 % t3;
              if (a2 < i3) return r3 - a2;
              if (a2 > t3 - i3) return r3 - a2 + t3;
            }
            return r3;
          };
          var zt = e2.createUUID = /* @__PURE__ */ function(t3, e3) {
            return function() {
              return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(t3, e3).toUpperCase();
            };
          }(/[xy]/g, function(t3) {
            var e3 = 16 * Y.random() | 0, r3 = "x" == t3 ? e3 : 3 & e3 | 8;
            return r3.toString(16);
          });
          e2.setWindow = function(r3) {
            t2("raphael.setWindow", e2, A.win, r3), A.win = r3, A.doc = A.win.document, e2._engine.initWin && e2._engine.initWin(A.win);
          };
          var Pt = function(t3) {
            if (e2.vml) {
              var r3 = /^\s+|\s+$/g, i3;
              try {
                var a2 = new ActiveXObject("htmlfile");
                a2.write("<body>"), a2.close(), i3 = a2.body;
              } catch (s2) {
                i3 = createPopup().document.body;
              }
              var o2 = i3.createTextRange();
              Pt = n2(function(t4) {
                try {
                  i3.style.color = j(t4).replace(r3, R);
                  var e3 = o2.queryCommandValue("ForeColor");
                  return e3 = (255 & e3) << 16 | 65280 & e3 | (16711680 & e3) >>> 16, "#" + ("000000" + e3.toString(16)).slice(-6);
                } catch (n3) {
                  return "none";
                }
              });
            } else {
              var l2 = A.doc.createElement("i");
              l2.title = "Raphaël Colour Picker", l2.style.display = "none", A.doc.body.appendChild(l2), Pt = n2(function(t4) {
                return l2.style.color = t4, A.doc.defaultView.getComputedStyle(l2, R).getPropertyValue("color");
              });
            }
            return Pt(t3);
          }, Ft = function() {
            return "hsb(" + [this.h, this.s, this.b] + ")";
          }, Rt = function() {
            return "hsl(" + [this.h, this.s, this.l] + ")";
          }, It = function() {
            return this.hex;
          }, jt = function(t3, r3, i3) {
            if (null == r3 && e2.is(t3, "object") && "r" in t3 && "g" in t3 && "b" in t3 && (i3 = t3.b, r3 = t3.g, t3 = t3.r), null == r3 && e2.is(t3, Z)) {
              var n3 = e2.getRGB(t3);
              t3 = n3.r, r3 = n3.g, i3 = n3.b;
            }
            return (t3 > 1 || r3 > 1 || i3 > 1) && (t3 /= 255, r3 /= 255, i3 /= 255), [t3, r3, i3];
          }, qt = function(t3, r3, i3, n3) {
            t3 *= 255, r3 *= 255, i3 *= 255;
            var a2 = {
              r: t3,
              g: r3,
              b: i3,
              hex: e2.rgb(t3, r3, i3),
              toString: It
            };
            return e2.is(n3, "finite") && (a2.opacity = n3), a2;
          };
          e2.color = function(t3) {
            var r3;
            return e2.is(t3, "object") && "h" in t3 && "s" in t3 && "b" in t3 ? (r3 = e2.hsb2rgb(t3), t3.r = r3.r, t3.g = r3.g, t3.b = r3.b, t3.hex = r3.hex) : e2.is(t3, "object") && "h" in t3 && "s" in t3 && "l" in t3 ? (r3 = e2.hsl2rgb(t3), t3.r = r3.r, t3.g = r3.g, t3.b = r3.b, t3.hex = r3.hex) : (e2.is(t3, "string") && (t3 = e2.getRGB(t3)), e2.is(t3, "object") && "r" in t3 && "g" in t3 && "b" in t3 ? (r3 = e2.rgb2hsl(t3), t3.h = r3.h, t3.s = r3.s, t3.l = r3.l, r3 = e2.rgb2hsb(t3), t3.v = r3.b) : (t3 = {
              hex: "none"
            }, t3.r = t3.g = t3.b = t3.h = t3.s = t3.v = t3.l = -1)), t3.toString = It, t3;
          }, e2.hsb2rgb = function(t3, e3, r3, i3) {
            this.is(t3, "object") && "h" in t3 && "s" in t3 && "b" in t3 && (r3 = t3.b, e3 = t3.s, i3 = t3.o, t3 = t3.h), t3 *= 360;
            var n3, a2, s2, o2, l2;
            return t3 = t3 % 360 / 60, l2 = r3 * e3, o2 = l2 * (1 - H(t3 % 2 - 1)), n3 = a2 = s2 = r3 - l2, t3 = ~~t3, n3 += [l2, o2, 0, 0, o2, l2][t3], a2 += [o2, l2, l2, o2, 0, 0][t3], s2 += [0, 0, o2, l2, l2, o2][t3], qt(n3, a2, s2, i3);
          }, e2.hsl2rgb = function(t3, e3, r3, i3) {
            this.is(t3, "object") && "h" in t3 && "s" in t3 && "l" in t3 && (r3 = t3.l, e3 = t3.s, t3 = t3.h), (t3 > 1 || e3 > 1 || r3 > 1) && (t3 /= 360, e3 /= 100, r3 /= 100), t3 *= 360;
            var n3, a2, s2, o2, l2;
            return t3 = t3 % 360 / 60, l2 = 2 * e3 * (r3 < 0.5 ? r3 : 1 - r3), o2 = l2 * (1 - H(t3 % 2 - 1)), n3 = a2 = s2 = r3 - l2 / 2, t3 = ~~t3, n3 += [l2, o2, 0, 0, o2, l2][t3], a2 += [o2, l2, l2, o2, 0, 0][t3], s2 += [0, 0, o2, l2, l2, o2][t3], qt(n3, a2, s2, i3);
          }, e2.rgb2hsb = function(t3, e3, r3) {
            r3 = jt(t3, e3, r3), t3 = r3[0], e3 = r3[1], r3 = r3[2];
            var i3, n3, a2, s2;
            return a2 = W(t3, e3, r3), s2 = a2 - G(t3, e3, r3), i3 = 0 == s2 ? null : a2 == t3 ? (e3 - r3) / s2 : a2 == e3 ? (r3 - t3) / s2 + 2 : (t3 - e3) / s2 + 4, i3 = (i3 + 360) % 6 * 60 / 360, n3 = 0 == s2 ? 0 : s2 / a2, {
              h: i3,
              s: n3,
              b: a2,
              toString: Ft
            };
          }, e2.rgb2hsl = function(t3, e3, r3) {
            r3 = jt(t3, e3, r3), t3 = r3[0], e3 = r3[1], r3 = r3[2];
            var i3, n3, a2, s2, o2, l2;
            return s2 = W(t3, e3, r3), o2 = G(t3, e3, r3), l2 = s2 - o2, i3 = 0 == l2 ? null : s2 == t3 ? (e3 - r3) / l2 : s2 == e3 ? (r3 - t3) / l2 + 2 : (t3 - e3) / l2 + 4, i3 = (i3 + 360) % 6 * 60 / 360, a2 = (s2 + o2) / 2, n3 = 0 == l2 ? 0 : a2 < 0.5 ? l2 / (2 * a2) : l2 / (2 - 2 * a2), {
              h: i3,
              s: n3,
              l: a2,
              toString: Rt
            };
          }, e2._path2string = function() {
            return this.join(",").replace(vt, "$1");
          };
          var Dt = e2._preload = function(t3, e3) {
            var r3 = A.doc.createElement("img");
            r3.style.cssText = "position:absolute;left:-9999em;top:-9999em", r3.onload = function() {
              e3.call(this), this.onload = null, A.doc.body.removeChild(this);
            }, r3.onerror = function() {
              A.doc.body.removeChild(this);
            }, A.doc.body.appendChild(r3), r3.src = t3;
          };
          e2.getRGB = n2(function(t3) {
            if (!t3 || (t3 = j(t3)).indexOf("-") + 1) return {
              r: -1,
              g: -1,
              b: -1,
              hex: "none",
              error: 1,
              toString: a
            };
            if ("none" == t3) return {
              r: -1,
              g: -1,
              b: -1,
              hex: "none",
              toString: a
            };
            !(xt[T](t3.toLowerCase().substring(0, 2)) || "#" == t3.charAt()) && (t3 = Pt(t3));
            var r3, i3, n3, s2, o2, l2, h2, u2 = t3.match(nt);
            return u2 ? (u2[2] && (s2 = ut(u2[2].substring(5), 16), n3 = ut(u2[2].substring(3, 5), 16), i3 = ut(u2[2].substring(1, 3), 16)), u2[3] && (s2 = ut((l2 = u2[3].charAt(3)) + l2, 16), n3 = ut((l2 = u2[3].charAt(2)) + l2, 16), i3 = ut((l2 = u2[3].charAt(1)) + l2, 16)), u2[4] && (h2 = u2[4][q](gt), i3 = ht(h2[0]), "%" == h2[0].slice(-1) && (i3 *= 2.55), n3 = ht(h2[1]), "%" == h2[1].slice(-1) && (n3 *= 2.55), s2 = ht(h2[2]), "%" == h2[2].slice(-1) && (s2 *= 2.55), "rgba" == u2[1].toLowerCase().slice(0, 4) && (o2 = ht(h2[3])), h2[3] && "%" == h2[3].slice(-1) && (o2 /= 100)), u2[5] ? (h2 = u2[5][q](gt), i3 = ht(h2[0]), "%" == h2[0].slice(-1) && (i3 *= 2.55), n3 = ht(h2[1]), "%" == h2[1].slice(-1) && (n3 *= 2.55), s2 = ht(h2[2]), "%" == h2[2].slice(-1) && (s2 *= 2.55), ("deg" == h2[0].slice(-3) || "°" == h2[0].slice(-1)) && (i3 /= 360), "hsba" == u2[1].toLowerCase().slice(0, 4) && (o2 = ht(h2[3])), h2[3] && "%" == h2[3].slice(-1) && (o2 /= 100), e2.hsb2rgb(i3, n3, s2, o2)) : u2[6] ? (h2 = u2[6][q](gt), i3 = ht(h2[0]), "%" == h2[0].slice(-1) && (i3 *= 2.55), n3 = ht(h2[1]), "%" == h2[1].slice(-1) && (n3 *= 2.55), s2 = ht(h2[2]), "%" == h2[2].slice(-1) && (s2 *= 2.55), ("deg" == h2[0].slice(-3) || "°" == h2[0].slice(-1)) && (i3 /= 360), "hsla" == u2[1].toLowerCase().slice(0, 4) && (o2 = ht(h2[3])), h2[3] && "%" == h2[3].slice(-1) && (o2 /= 100), e2.hsl2rgb(i3, n3, s2, o2)) : (u2 = {
              r: i3,
              g: n3,
              b: s2,
              toString: a
            }, u2.hex = "#" + (16777216 | s2 | n3 << 8 | i3 << 16).toString(16).slice(1), e2.is(o2, "finite") && (u2.opacity = o2), u2)) : {
              r: -1,
              g: -1,
              b: -1,
              hex: "none",
              error: 1,
              toString: a
            };
          }, e2), e2.hsb = n2(function(t3, r3, i3) {
            return e2.hsb2rgb(t3, r3, i3).hex;
          }), e2.hsl = n2(function(t3, r3, i3) {
            return e2.hsl2rgb(t3, r3, i3).hex;
          }), e2.rgb = n2(function(t3, e3, r3) {
            function i3(t4) {
              return t4 + 0.5 | 0;
            }
            return "#" + (16777216 | i3(r3) | i3(e3) << 8 | i3(t3) << 16).toString(16).slice(1);
          }), e2.getColor = function(t3) {
            var e3 = this.getColor.start = this.getColor.start || {
              h: 0,
              s: 1,
              b: t3 || 0.75
            }, r3 = this.hsb2rgb(e3.h, e3.s, e3.b);
            return e3.h += 0.075, e3.h > 1 && (e3.h = 0, e3.s -= 0.2, e3.s <= 0 && (this.getColor.start = {
              h: 0,
              s: 1,
              b: e3.b
            })), r3.hex;
          }, e2.getColor.reset = function() {
            delete this.start;
          }, e2.parsePathString = function(t3) {
            if (!t3) return null;
            var r3 = Vt(t3);
            if (r3.arr) return Yt(r3.arr);
            var i3 = {
              a: 7,
              c: 6,
              h: 1,
              l: 2,
              m: 2,
              r: 4,
              q: 4,
              s: 4,
              t: 2,
              v: 1,
              z: 0
            }, n3 = [];
            return e2.is(t3, Q) && e2.is(t3[0], Q) && (n3 = Yt(t3)), n3.length || j(t3).replace(yt, function(t4, e3, r4) {
              var a2 = [], s2 = e3.toLowerCase();
              if (r4.replace(bt, function(t5, e4) {
                e4 && a2.push(+e4);
              }), "m" == s2 && a2.length > 2 && (n3.push([e3][P](a2.splice(0, 2))), s2 = "l", e3 = "m" == e3 ? "l" : "L"), "r" == s2) n3.push([e3][P](a2));
              else for (; a2.length >= i3[s2] && (n3.push([e3][P](a2.splice(0, i3[s2]))), i3[s2]); ) ;
            }), n3.toString = e2._path2string, r3.arr = Yt(n3), n3;
          }, e2.parseTransformString = n2(function(t3) {
            if (!t3) return null;
            var r3 = {
              r: 3,
              s: 4,
              t: 2,
              m: 6
            }, i3 = [];
            return e2.is(t3, Q) && e2.is(t3[0], Q) && (i3 = Yt(t3)), i3.length || j(t3).replace(mt, function(t4, e3, r4) {
              var n3 = [], a2 = O.call(e3);
              r4.replace(bt, function(t5, e4) {
                e4 && n3.push(+e4);
              }), i3.push([e3][P](n3));
            }), i3.toString = e2._path2string, i3;
          });
          var Vt = function(t3) {
            var e3 = Vt.ps = Vt.ps || {};
            return e3[t3] ? e3[t3].sleep = 100 : e3[t3] = {
              sleep: 100
            }, setTimeout(function() {
              for (var r3 in e3) e3[T](r3) && r3 != t3 && (e3[r3].sleep--, !e3[r3].sleep && delete e3[r3]);
            }), e3[t3];
          };
          e2.findDotsAtSegment = function(t3, e3, r3, i3, n3, a2, s2, o2, l2) {
            var h2 = 1 - l2, u2 = X(h2, 3), c2 = X(h2, 2), f2 = l2 * l2, p2 = f2 * l2, d2 = u2 * t3 + 3 * c2 * l2 * r3 + 3 * h2 * l2 * l2 * n3 + p2 * s2, g2 = u2 * e3 + 3 * c2 * l2 * i3 + 3 * h2 * l2 * l2 * a2 + p2 * o2, x2 = t3 + 2 * l2 * (r3 - t3) + f2 * (n3 - 2 * r3 + t3), v2 = e3 + 2 * l2 * (i3 - e3) + f2 * (a2 - 2 * i3 + e3), y2 = r3 + 2 * l2 * (n3 - r3) + f2 * (s2 - 2 * n3 + r3), m2 = i3 + 2 * l2 * (a2 - i3) + f2 * (o2 - 2 * a2 + i3), b2 = h2 * t3 + l2 * r3, _2 = h2 * e3 + l2 * i3, w2 = h2 * n3 + l2 * s2, k2 = h2 * a2 + l2 * o2, B2 = 90 - 180 * Y.atan2(x2 - y2, v2 - m2) / U;
            return (x2 > y2 || v2 < m2) && (B2 += 180), {
              x: d2,
              y: g2,
              m: {
                x: x2,
                y: v2
              },
              n: {
                x: y2,
                y: m2
              },
              start: {
                x: b2,
                y: _2
              },
              end: {
                x: w2,
                y: k2
              },
              alpha: B2
            };
          }, e2.bezierBBox = function(t3, r3, i3, n3, a2, s2, o2, l2) {
            e2.is(t3, "array") || (t3 = [t3, r3, i3, n3, a2, s2, o2, l2]);
            var h2 = Zt.apply(null, t3);
            return {
              x: h2.min.x,
              y: h2.min.y,
              x2: h2.max.x,
              y2: h2.max.y,
              width: h2.max.x - h2.min.x,
              height: h2.max.y - h2.min.y
            };
          }, e2.isPointInsideBBox = function(t3, e3, r3) {
            return e3 >= t3.x && e3 <= t3.x2 && r3 >= t3.y && r3 <= t3.y2;
          }, e2.isBBoxIntersect = function(t3, r3) {
            var i3 = e2.isPointInsideBBox;
            return i3(r3, t3.x, t3.y) || i3(r3, t3.x2, t3.y) || i3(r3, t3.x, t3.y2) || i3(r3, t3.x2, t3.y2) || i3(t3, r3.x, r3.y) || i3(t3, r3.x2, r3.y) || i3(t3, r3.x, r3.y2) || i3(t3, r3.x2, r3.y2) || (t3.x < r3.x2 && t3.x > r3.x || r3.x < t3.x2 && r3.x > t3.x) && (t3.y < r3.y2 && t3.y > r3.y || r3.y < t3.y2 && r3.y > t3.y);
          }, e2.pathIntersection = function(t3, e3) {
            return d(t3, e3);
          }, e2.pathIntersectionNumber = function(t3, e3) {
            return d(t3, e3, 1);
          }, e2.isPointInsidePath = function(t3, r3, i3) {
            var n3 = e2.pathBBox(t3);
            return e2.isPointInsideBBox(n3, r3, i3) && d(t3, [["M", r3, i3], ["H", n3.x2 + 10]], 1) % 2 == 1;
          }, e2._removedFactory = function(e3) {
            return function() {
              t2("raphael.log", null, "Raphaël: you are calling to method “" + e3 + "” of removed object", e3);
            };
          };
          var Ot = e2.pathBBox = function(t3) {
            var e3 = Vt(t3);
            if (e3.bbox) return r2(e3.bbox);
            if (!t3) return {
              x: 0,
              y: 0,
              width: 0,
              height: 0,
              x2: 0,
              y2: 0
            };
            t3 = Qt(t3);
            for (var i3 = 0, n3 = 0, a2 = [], s2 = [], o2, l2 = 0, h2 = t3.length; l2 < h2; l2++) if (o2 = t3[l2], "M" == o2[0]) i3 = o2[1], n3 = o2[2], a2.push(i3), s2.push(n3);
            else {
              var u2 = Zt(i3, n3, o2[1], o2[2], o2[3], o2[4], o2[5], o2[6]);
              a2 = a2[P](u2.min.x, u2.max.x), s2 = s2[P](u2.min.y, u2.max.y), i3 = o2[5], n3 = o2[6];
            }
            var c2 = G[z](0, a2), f2 = G[z](0, s2), p2 = W[z](0, a2), d2 = W[z](0, s2), g2 = p2 - c2, x2 = d2 - f2, v2 = {
              x: c2,
              y: f2,
              x2: p2,
              y2: d2,
              width: g2,
              height: x2,
              cx: c2 + g2 / 2,
              cy: f2 + x2 / 2
            };
            return e3.bbox = r2(v2), v2;
          }, Yt = function(t3) {
            var i3 = r2(t3);
            return i3.toString = e2._path2string, i3;
          }, Wt = e2._pathToRelative = function(t3) {
            var r3 = Vt(t3);
            if (r3.rel) return Yt(r3.rel);
            e2.is(t3, Q) && e2.is(t3 && t3[0], Q) || (t3 = e2.parsePathString(t3));
            var i3 = [], n3 = 0, a2 = 0, s2 = 0, o2 = 0, l2 = 0;
            "M" == t3[0][0] && (n3 = t3[0][1], a2 = t3[0][2], s2 = n3, o2 = a2, l2++, i3.push(["M", n3, a2]));
            for (var h2 = l2, u2 = t3.length; h2 < u2; h2++) {
              var c2 = i3[h2] = [], f2 = t3[h2];
              if (f2[0] != O.call(f2[0])) switch (c2[0] = O.call(f2[0]), c2[0]) {
                case "a":
                  c2[1] = f2[1], c2[2] = f2[2], c2[3] = f2[3], c2[4] = f2[4], c2[5] = f2[5], c2[6] = +(f2[6] - n3).toFixed(3), c2[7] = +(f2[7] - a2).toFixed(3);
                  break;
                case "v":
                  c2[1] = +(f2[1] - a2).toFixed(3);
                  break;
                case "m":
                  s2 = f2[1], o2 = f2[2];
                default:
                  for (var p2 = 1, d2 = f2.length; p2 < d2; p2++) c2[p2] = +(f2[p2] - (p2 % 2 ? n3 : a2)).toFixed(3);
              }
              else {
                c2 = i3[h2] = [], "m" == f2[0] && (s2 = f2[1] + n3, o2 = f2[2] + a2);
                for (var g2 = 0, x2 = f2.length; g2 < x2; g2++) i3[h2][g2] = f2[g2];
              }
              var v2 = i3[h2].length;
              switch (i3[h2][0]) {
                case "z":
                  n3 = s2, a2 = o2;
                  break;
                case "h":
                  n3 += +i3[h2][v2 - 1];
                  break;
                case "v":
                  a2 += +i3[h2][v2 - 1];
                  break;
                default:
                  n3 += +i3[h2][v2 - 2], a2 += +i3[h2][v2 - 1];
              }
            }
            return i3.toString = e2._path2string, r3.rel = Yt(i3), i3;
          }, Gt = e2._pathToAbsolute = function(t3) {
            var r3 = Vt(t3);
            if (r3.abs) return Yt(r3.abs);
            if (e2.is(t3, Q) && e2.is(t3 && t3[0], Q) || (t3 = e2.parsePathString(t3)), !t3 || !t3.length) return [["M", 0, 0]];
            var i3 = [], n3 = 0, a2 = 0, o2 = 0, l2 = 0, h2 = 0;
            "M" == t3[0][0] && (n3 = +t3[0][1], a2 = +t3[0][2], o2 = n3, l2 = a2, h2++, i3[0] = ["M", n3, a2]);
            for (var u2 = 3 == t3.length && "M" == t3[0][0] && "R" == t3[1][0].toUpperCase() && "Z" == t3[2][0].toUpperCase(), c2, f2, p2 = h2, d2 = t3.length; p2 < d2; p2++) {
              if (i3.push(c2 = []), f2 = t3[p2], f2[0] != ct.call(f2[0])) switch (c2[0] = ct.call(f2[0]), c2[0]) {
                case "A":
                  c2[1] = f2[1], c2[2] = f2[2], c2[3] = f2[3], c2[4] = f2[4], c2[5] = f2[5], c2[6] = +(f2[6] + n3), c2[7] = +(f2[7] + a2);
                  break;
                case "V":
                  c2[1] = +f2[1] + a2;
                  break;
                case "H":
                  c2[1] = +f2[1] + n3;
                  break;
                case "R":
                  for (var g2 = [n3, a2][P](f2.slice(1)), x2 = 2, v2 = g2.length; x2 < v2; x2++) g2[x2] = +g2[x2] + n3, g2[++x2] = +g2[x2] + a2;
                  i3.pop(), i3 = i3[P](s(g2, u2));
                  break;
                case "M":
                  o2 = +f2[1] + n3, l2 = +f2[2] + a2;
                default:
                  for (x2 = 1, v2 = f2.length; x2 < v2; x2++) c2[x2] = +f2[x2] + (x2 % 2 ? n3 : a2);
              }
              else if ("R" == f2[0]) g2 = [n3, a2][P](f2.slice(1)), i3.pop(), i3 = i3[P](s(g2, u2)), c2 = ["R"][P](f2.slice(-2));
              else for (var y2 = 0, m2 = f2.length; y2 < m2; y2++) c2[y2] = f2[y2];
              switch (c2[0]) {
                case "Z":
                  n3 = o2, a2 = l2;
                  break;
                case "H":
                  n3 = c2[1];
                  break;
                case "V":
                  a2 = c2[1];
                  break;
                case "M":
                  o2 = c2[c2.length - 2], l2 = c2[c2.length - 1];
                default:
                  n3 = c2[c2.length - 2], a2 = c2[c2.length - 1];
              }
            }
            return i3.toString = e2._path2string, r3.abs = Yt(i3), i3;
          }, Ht = function(t3, e3, r3, i3) {
            return [t3, e3, r3, i3, r3, i3];
          }, Xt = function(t3, e3, r3, i3, n3, a2) {
            var s2 = 1 / 3, o2 = 2 / 3;
            return [s2 * t3 + o2 * r3, s2 * e3 + o2 * i3, s2 * n3 + o2 * r3, s2 * a2 + o2 * i3, n3, a2];
          }, Ut = function(t3, e3, r3, i3, a2, s2, o2, l2, h2, u2) {
            var c2 = 120 * U / 180, f2 = U / 180 * (+a2 || 0), p2 = [], d2, g2 = n2(function(t4, e4, r4) {
              var i4 = t4 * Y.cos(r4) - e4 * Y.sin(r4), n3 = t4 * Y.sin(r4) + e4 * Y.cos(r4);
              return {
                x: i4,
                y: n3
              };
            });
            if (u2) S2 = u2[0], T2 = u2[1], B2 = u2[2], C2 = u2[3];
            else {
              d2 = g2(t3, e3, -f2), t3 = d2.x, e3 = d2.y, d2 = g2(l2, h2, -f2), l2 = d2.x, h2 = d2.y;
              var x2 = Y.cos(U / 180 * a2), v2 = Y.sin(U / 180 * a2), y2 = (t3 - l2) / 2, m2 = (e3 - h2) / 2, b2 = y2 * y2 / (r3 * r3) + m2 * m2 / (i3 * i3);
              b2 > 1 && (b2 = Y.sqrt(b2), r3 = b2 * r3, i3 = b2 * i3);
              var _2 = r3 * r3, w2 = i3 * i3, k2 = (s2 == o2 ? -1 : 1) * Y.sqrt(H((_2 * w2 - _2 * m2 * m2 - w2 * y2 * y2) / (_2 * m2 * m2 + w2 * y2 * y2))), B2 = k2 * r3 * m2 / i3 + (t3 + l2) / 2, C2 = k2 * -i3 * y2 / r3 + (e3 + h2) / 2, S2 = Y.asin(((e3 - C2) / i3).toFixed(9)), T2 = Y.asin(((h2 - C2) / i3).toFixed(9));
              S2 = t3 < B2 ? U - S2 : S2, T2 = l2 < B2 ? U - T2 : T2, S2 < 0 && (S2 = 2 * U + S2), T2 < 0 && (T2 = 2 * U + T2), o2 && S2 > T2 && (S2 -= 2 * U), !o2 && T2 > S2 && (T2 -= 2 * U);
            }
            var A2 = T2 - S2;
            if (H(A2) > c2) {
              var E2 = T2, N2 = l2, M2 = h2;
              T2 = S2 + c2 * (o2 && T2 > S2 ? 1 : -1), l2 = B2 + r3 * Y.cos(T2), h2 = C2 + i3 * Y.sin(T2), p2 = Ut(l2, h2, r3, i3, a2, 0, o2, N2, M2, [T2, E2, B2, C2]);
            }
            A2 = T2 - S2;
            var L2 = Y.cos(S2), z2 = Y.sin(S2), F2 = Y.cos(T2), R2 = Y.sin(T2), I2 = Y.tan(A2 / 4), j2 = 4 / 3 * r3 * I2, D2 = 4 / 3 * i3 * I2, V2 = [t3, e3], O2 = [t3 + j2 * z2, e3 - D2 * L2], W2 = [l2 + j2 * R2, h2 - D2 * F2], G2 = [l2, h2];
            if (O2[0] = 2 * V2[0] - O2[0], O2[1] = 2 * V2[1] - O2[1], u2) return [O2, W2, G2][P](p2);
            p2 = [O2, W2, G2][P](p2).join()[q](",");
            for (var X2 = [], $2 = 0, Z2 = p2.length; $2 < Z2; $2++) X2[$2] = $2 % 2 ? g2(p2[$2 - 1], p2[$2], f2).y : g2(p2[$2], p2[$2 + 1], f2).x;
            return X2;
          }, $t = function(t3, e3, r3, i3, n3, a2, s2, o2, l2) {
            var h2 = 1 - l2;
            return {
              x: X(h2, 3) * t3 + 3 * X(h2, 2) * l2 * r3 + 3 * h2 * l2 * l2 * n3 + X(l2, 3) * s2,
              y: X(h2, 3) * e3 + 3 * X(h2, 2) * l2 * i3 + 3 * h2 * l2 * l2 * a2 + X(l2, 3) * o2
            };
          }, Zt = n2(function(t3, e3, r3, i3, n3, a2, s2, o2) {
            var l2 = n3 - 2 * r3 + t3 - (s2 - 2 * n3 + r3), h2 = 2 * (r3 - t3) - 2 * (n3 - r3), u2 = t3 - r3, c2 = (-h2 + Y.sqrt(h2 * h2 - 4 * l2 * u2)) / 2 / l2, f2 = (-h2 - Y.sqrt(h2 * h2 - 4 * l2 * u2)) / 2 / l2, p2 = [e3, o2], d2 = [t3, s2], g2;
            return H(c2) > "1e12" && (c2 = 0.5), H(f2) > "1e12" && (f2 = 0.5), c2 > 0 && c2 < 1 && (g2 = $t(t3, e3, r3, i3, n3, a2, s2, o2, c2), d2.push(g2.x), p2.push(g2.y)), f2 > 0 && f2 < 1 && (g2 = $t(t3, e3, r3, i3, n3, a2, s2, o2, f2), d2.push(g2.x), p2.push(g2.y)), l2 = a2 - 2 * i3 + e3 - (o2 - 2 * a2 + i3), h2 = 2 * (i3 - e3) - 2 * (a2 - i3), u2 = e3 - i3, c2 = (-h2 + Y.sqrt(h2 * h2 - 4 * l2 * u2)) / 2 / l2, f2 = (-h2 - Y.sqrt(h2 * h2 - 4 * l2 * u2)) / 2 / l2, H(c2) > "1e12" && (c2 = 0.5), H(f2) > "1e12" && (f2 = 0.5), c2 > 0 && c2 < 1 && (g2 = $t(t3, e3, r3, i3, n3, a2, s2, o2, c2), d2.push(g2.x), p2.push(g2.y)), f2 > 0 && f2 < 1 && (g2 = $t(t3, e3, r3, i3, n3, a2, s2, o2, f2), d2.push(g2.x), p2.push(g2.y)), {
              min: {
                x: G[z](0, d2),
                y: G[z](0, p2)
              },
              max: {
                x: W[z](0, d2),
                y: W[z](0, p2)
              }
            };
          }), Qt = e2._path2curve = n2(function(t3, e3) {
            var r3 = !e3 && Vt(t3);
            if (!e3 && r3.curve) return Yt(r3.curve);
            for (var i3 = Gt(t3), n3 = e3 && Gt(e3), a2 = {
              x: 0,
              y: 0,
              bx: 0,
              by: 0,
              X: 0,
              Y: 0,
              qx: null,
              qy: null
            }, s2 = {
              x: 0,
              y: 0,
              bx: 0,
              by: 0,
              X: 0,
              Y: 0,
              qx: null,
              qy: null
            }, o2 = function(t4, e4, r4) {
              var i4, n4, a3 = {
                T: 1,
                Q: 1
              };
              if (!t4) return ["C", e4.x, e4.y, e4.x, e4.y, e4.x, e4.y];
              switch (!(t4[0] in a3) && (e4.qx = e4.qy = null), t4[0]) {
                case "M":
                  e4.X = t4[1], e4.Y = t4[2];
                  break;
                case "A":
                  t4 = ["C"][P](Ut[z](0, [e4.x, e4.y][P](t4.slice(1))));
                  break;
                case "S":
                  "C" == r4 || "S" == r4 ? (i4 = 2 * e4.x - e4.bx, n4 = 2 * e4.y - e4.by) : (i4 = e4.x, n4 = e4.y), t4 = ["C", i4, n4][P](t4.slice(1));
                  break;
                case "T":
                  "Q" == r4 || "T" == r4 ? (e4.qx = 2 * e4.x - e4.qx, e4.qy = 2 * e4.y - e4.qy) : (e4.qx = e4.x, e4.qy = e4.y), t4 = ["C"][P](Xt(e4.x, e4.y, e4.qx, e4.qy, t4[1], t4[2]));
                  break;
                case "Q":
                  e4.qx = t4[1], e4.qy = t4[2], t4 = ["C"][P](Xt(e4.x, e4.y, t4[1], t4[2], t4[3], t4[4]));
                  break;
                case "L":
                  t4 = ["C"][P](Ht(e4.x, e4.y, t4[1], t4[2]));
                  break;
                case "H":
                  t4 = ["C"][P](Ht(e4.x, e4.y, t4[1], e4.y));
                  break;
                case "V":
                  t4 = ["C"][P](Ht(e4.x, e4.y, e4.x, t4[1]));
                  break;
                case "Z":
                  t4 = ["C"][P](Ht(e4.x, e4.y, e4.X, e4.Y));
              }
              return t4;
            }, l2 = function(t4, e4) {
              if (t4[e4].length > 7) {
                t4[e4].shift();
                for (var r4 = t4[e4]; r4.length; ) u2[e4] = "A", n3 && (c2[e4] = "A"), t4.splice(e4++, 0, ["C"][P](r4.splice(0, 6)));
                t4.splice(e4, 1), g2 = W(i3.length, n3 && n3.length || 0);
              }
            }, h2 = function(t4, e4, r4, a3, s3) {
              t4 && e4 && "M" == t4[s3][0] && "M" != e4[s3][0] && (e4.splice(s3, 0, ["M", a3.x, a3.y]), r4.bx = 0, r4.by = 0, r4.x = t4[s3][1], r4.y = t4[s3][2], g2 = W(i3.length, n3 && n3.length || 0));
            }, u2 = [], c2 = [], f2 = "", p2 = "", d2 = 0, g2 = W(i3.length, n3 && n3.length || 0); d2 < g2; d2++) {
              i3[d2] && (f2 = i3[d2][0]), "C" != f2 && (u2[d2] = f2, d2 && (p2 = u2[d2 - 1])), i3[d2] = o2(i3[d2], a2, p2), "A" != u2[d2] && "C" == f2 && (u2[d2] = "C"), l2(i3, d2), n3 && (n3[d2] && (f2 = n3[d2][0]), "C" != f2 && (c2[d2] = f2, d2 && (p2 = c2[d2 - 1])), n3[d2] = o2(n3[d2], s2, p2), "A" != c2[d2] && "C" == f2 && (c2[d2] = "C"), l2(n3, d2)), h2(i3, n3, a2, s2, d2), h2(n3, i3, s2, a2, d2);
              var x2 = i3[d2], v2 = n3 && n3[d2], y2 = x2.length, m2 = n3 && v2.length;
              a2.x = x2[y2 - 2], a2.y = x2[y2 - 1], a2.bx = ht(x2[y2 - 4]) || a2.x, a2.by = ht(x2[y2 - 3]) || a2.y, s2.bx = n3 && (ht(v2[m2 - 4]) || s2.x), s2.by = n3 && (ht(v2[m2 - 3]) || s2.y), s2.x = n3 && v2[m2 - 2], s2.y = n3 && v2[m2 - 1];
            }
            return n3 || (r3.curve = Yt(i3)), n3 ? [i3, n3] : i3;
          }, null, Yt), Jt = e2._parseDots = n2(function(t3) {
            for (var r3 = [], i3 = 0, n3 = t3.length; i3 < n3; i3++) {
              var a2 = {}, s2 = t3[i3].match(/^([^:]*):?([\d\.]*)/);
              if (a2.color = e2.getRGB(s2[1]), a2.color.error) return null;
              a2.opacity = a2.color.opacity, a2.color = a2.color.hex, s2[2] && (a2.offset = s2[2] + "%"), r3.push(a2);
            }
            for (i3 = 1, n3 = r3.length - 1; i3 < n3; i3++) if (!r3[i3].offset) {
              for (var o2 = ht(r3[i3 - 1].offset || 0), l2 = 0, h2 = i3 + 1; h2 < n3; h2++) if (r3[h2].offset) {
                l2 = r3[h2].offset;
                break;
              }
              l2 || (l2 = 100, h2 = n3), l2 = ht(l2);
              for (var u2 = (l2 - o2) / (h2 - i3 + 1); i3 < h2; i3++) o2 += u2, r3[i3].offset = o2 + "%";
            }
            return r3;
          }), Kt = e2._tear = function(t3, e3) {
            t3 == e3.top && (e3.top = t3.prev), t3 == e3.bottom && (e3.bottom = t3.next), t3.next && (t3.next.prev = t3.prev), t3.prev && (t3.prev.next = t3.next);
          }, te = e2._tofront = function(t3, e3) {
            e3.top !== t3 && (Kt(t3, e3), t3.next = null, t3.prev = e3.top, e3.top.next = t3, e3.top = t3);
          }, ee = e2._toback = function(t3, e3) {
            e3.bottom !== t3 && (Kt(t3, e3), t3.next = e3.bottom, t3.prev = null, e3.bottom.prev = t3, e3.bottom = t3);
          }, re = e2._insertafter = function(t3, e3, r3) {
            Kt(t3, r3), e3 == r3.top && (r3.top = t3), e3.next && (e3.next.prev = t3), t3.next = e3.next, t3.prev = e3, e3.next = t3;
          }, ie = e2._insertbefore = function(t3, e3, r3) {
            Kt(t3, r3), e3 == r3.bottom && (r3.bottom = t3), e3.prev && (e3.prev.next = t3), t3.prev = e3.prev, e3.prev = t3, t3.next = e3;
          }, ne = e2.toMatrix = function(t3, e3) {
            var r3 = Ot(t3), i3 = {
              _: {
                transform: R
              },
              getBBox: function() {
                return r3;
              }
            };
            return se(i3, e3), i3.matrix;
          }, ae = e2.transformPath = function(t3, e3) {
            return Nt(t3, ne(t3, e3));
          }, se = e2._extractTransform = function(t3, r3) {
            if (null == r3) return t3._.transform;
            r3 = j(r3).replace(/\.{3}|\u2026/g, t3._.transform || R);
            var i3 = e2.parseTransformString(r3), n3 = 0, a2 = 0, s2 = 0, o2 = 1, l2 = 1, h2 = t3._, u2 = new g();
            if (h2.transform = i3 || [], i3) for (var c2 = 0, f2 = i3.length; c2 < f2; c2++) {
              var p2 = i3[c2], d2 = p2.length, x2 = j(p2[0]).toLowerCase(), v2 = p2[0] != x2, y2 = v2 ? u2.invert() : 0, m2, b2, _2, w2, k2;
              "t" == x2 && 3 == d2 ? v2 ? (m2 = y2.x(0, 0), b2 = y2.y(0, 0), _2 = y2.x(p2[1], p2[2]), w2 = y2.y(p2[1], p2[2]), u2.translate(_2 - m2, w2 - b2)) : u2.translate(p2[1], p2[2]) : "r" == x2 ? 2 == d2 ? (k2 = k2 || t3.getBBox(1), u2.rotate(p2[1], k2.x + k2.width / 2, k2.y + k2.height / 2), n3 += p2[1]) : 4 == d2 && (v2 ? (_2 = y2.x(p2[2], p2[3]), w2 = y2.y(p2[2], p2[3]), u2.rotate(p2[1], _2, w2)) : u2.rotate(p2[1], p2[2], p2[3]), n3 += p2[1]) : "s" == x2 ? 2 == d2 || 3 == d2 ? (k2 = k2 || t3.getBBox(1), u2.scale(p2[1], p2[d2 - 1], k2.x + k2.width / 2, k2.y + k2.height / 2), o2 *= p2[1], l2 *= p2[d2 - 1]) : 5 == d2 && (v2 ? (_2 = y2.x(p2[3], p2[4]), w2 = y2.y(p2[3], p2[4]), u2.scale(p2[1], p2[2], _2, w2)) : u2.scale(p2[1], p2[2], p2[3], p2[4]), o2 *= p2[1], l2 *= p2[2]) : "m" == x2 && 7 == d2 && u2.add(p2[1], p2[2], p2[3], p2[4], p2[5], p2[6]), h2.dirtyT = 1, t3.matrix = u2;
            }
            t3.matrix = u2, h2.sx = o2, h2.sy = l2, h2.deg = n3, h2.dx = a2 = u2.e, h2.dy = s2 = u2.f, 1 == o2 && 1 == l2 && !n3 && h2.bbox ? (h2.bbox.x += +a2, h2.bbox.y += +s2) : h2.dirtyT = 1;
          }, oe = function(t3) {
            var e3 = t3[0];
            switch (e3.toLowerCase()) {
              case "t":
                return [e3, 0, 0];
              case "m":
                return [e3, 1, 0, 0, 1, 0, 0];
              case "r":
                return 4 == t3.length ? [e3, 0, t3[2], t3[3]] : [e3, 0];
              case "s":
                return 5 == t3.length ? [e3, 1, 1, t3[3], t3[4]] : 3 == t3.length ? [e3, 1, 1] : [e3, 1];
            }
          }, le = e2._equaliseTransform = function(t3, r3) {
            r3 = j(r3).replace(/\.{3}|\u2026/g, t3), t3 = e2.parseTransformString(t3) || [], r3 = e2.parseTransformString(r3) || [];
            for (var i3 = W(t3.length, r3.length), n3 = [], a2 = [], s2 = 0, o2, l2, h2, u2; s2 < i3; s2++) {
              if (h2 = t3[s2] || oe(r3[s2]), u2 = r3[s2] || oe(h2), h2[0] != u2[0] || "r" == h2[0].toLowerCase() && (h2[2] != u2[2] || h2[3] != u2[3]) || "s" == h2[0].toLowerCase() && (h2[3] != u2[3] || h2[4] != u2[4])) return;
              for (n3[s2] = [], a2[s2] = [], o2 = 0, l2 = W(h2.length, u2.length); o2 < l2; o2++) o2 in h2 && (n3[s2][o2] = h2[o2]), o2 in u2 && (a2[s2][o2] = u2[o2]);
            }
            return {
              from: n3,
              to: a2
            };
          };
          e2._getContainer = function(t3, r3, i3, n3) {
            var a2;
            if (a2 = null != n3 || e2.is(t3, "object") ? t3 : A.doc.getElementById(t3), null != a2) return a2.tagName ? null == r3 ? {
              container: a2,
              width: a2.style.pixelWidth || a2.offsetWidth,
              height: a2.style.pixelHeight || a2.offsetHeight
            } : {
              container: a2,
              width: r3,
              height: i3
            } : {
              container: 1,
              x: t3,
              y: r3,
              width: i3,
              height: n3
            };
          }, e2.pathToRelative = Wt, e2._engine = {}, e2.path2curve = Qt, e2.matrix = function(t3, e3, r3, i3, n3, a2) {
            return new g(t3, e3, r3, i3, n3, a2);
          }, function(t3) {
            function r3(t4) {
              return t4[0] * t4[0] + t4[1] * t4[1];
            }
            function i3(t4) {
              var e3 = Y.sqrt(r3(t4));
              t4[0] && (t4[0] /= e3), t4[1] && (t4[1] /= e3);
            }
            t3.add = function(t4, e3, r4, i4, n3, a2) {
              var s2 = [[], [], []], o2 = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]], l2 = [[t4, r4, n3], [e3, i4, a2], [0, 0, 1]], h2, u2, c2, f2;
              for (t4 && t4 instanceof g && (l2 = [[t4.a, t4.c, t4.e], [t4.b, t4.d, t4.f], [0, 0, 1]]), h2 = 0; h2 < 3; h2++) for (u2 = 0; u2 < 3; u2++) {
                for (f2 = 0, c2 = 0; c2 < 3; c2++) f2 += o2[h2][c2] * l2[c2][u2];
                s2[h2][u2] = f2;
              }
              this.a = s2[0][0], this.b = s2[1][0], this.c = s2[0][1], this.d = s2[1][1], this.e = s2[0][2], this.f = s2[1][2];
            }, t3.invert = function() {
              var t4 = this, e3 = t4.a * t4.d - t4.b * t4.c;
              return new g(t4.d / e3, -t4.b / e3, -t4.c / e3, t4.a / e3, (t4.c * t4.f - t4.d * t4.e) / e3, (t4.b * t4.e - t4.a * t4.f) / e3);
            }, t3.clone = function() {
              return new g(this.a, this.b, this.c, this.d, this.e, this.f);
            }, t3.translate = function(t4, e3) {
              this.add(1, 0, 0, 1, t4, e3);
            }, t3.scale = function(t4, e3, r4, i4) {
              null == e3 && (e3 = t4), (r4 || i4) && this.add(1, 0, 0, 1, r4, i4), this.add(t4, 0, 0, e3, 0, 0), (r4 || i4) && this.add(1, 0, 0, 1, -r4, -i4);
            }, t3.rotate = function(t4, r4, i4) {
              t4 = e2.rad(t4), r4 = r4 || 0, i4 = i4 || 0;
              var n3 = +Y.cos(t4).toFixed(9), a2 = +Y.sin(t4).toFixed(9);
              this.add(n3, a2, -a2, n3, r4, i4), this.add(1, 0, 0, 1, -r4, -i4);
            }, t3.x = function(t4, e3) {
              return t4 * this.a + e3 * this.c + this.e;
            }, t3.y = function(t4, e3) {
              return t4 * this.b + e3 * this.d + this.f;
            }, t3.get = function(t4) {
              return +this[j.fromCharCode(97 + t4)].toFixed(4);
            }, t3.toString = function() {
              return e2.svg ? "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" : [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();
            }, t3.toFilter = function() {
              return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) + ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) + ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')";
            }, t3.offset = function() {
              return [this.e.toFixed(4), this.f.toFixed(4)];
            }, t3.split = function() {
              var t4 = {};
              t4.dx = this.e, t4.dy = this.f;
              var n3 = [[this.a, this.c], [this.b, this.d]];
              t4.scalex = Y.sqrt(r3(n3[0])), i3(n3[0]), t4.shear = n3[0][0] * n3[1][0] + n3[0][1] * n3[1][1], n3[1] = [n3[1][0] - n3[0][0] * t4.shear, n3[1][1] - n3[0][1] * t4.shear], t4.scaley = Y.sqrt(r3(n3[1])), i3(n3[1]), t4.shear /= t4.scaley;
              var a2 = -n3[0][1], s2 = n3[1][1];
              return s2 < 0 ? (t4.rotate = e2.deg(Y.acos(s2)), a2 < 0 && (t4.rotate = 360 - t4.rotate)) : t4.rotate = e2.deg(Y.asin(a2)), t4.isSimple = !(+t4.shear.toFixed(9) || t4.scalex.toFixed(9) != t4.scaley.toFixed(9) && t4.rotate), t4.isSuperSimple = !+t4.shear.toFixed(9) && t4.scalex.toFixed(9) == t4.scaley.toFixed(9) && !t4.rotate, t4.noRotation = !+t4.shear.toFixed(9) && !t4.rotate, t4;
            }, t3.toTransformString = function(t4) {
              var e3 = t4 || this[q]();
              return e3.isSimple ? (e3.scalex = +e3.scalex.toFixed(4), e3.scaley = +e3.scaley.toFixed(4), e3.rotate = +e3.rotate.toFixed(4), (e3.dx || e3.dy ? "t" + [e3.dx, e3.dy] : R) + (1 != e3.scalex || 1 != e3.scaley ? "s" + [e3.scalex, e3.scaley, 0, 0] : R) + (e3.rotate ? "r" + [e3.rotate, 0, 0] : R)) : "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
            };
          }(g.prototype);
          for (var he = function() {
            this.returnValue = false;
          }, ue = function() {
            return this.originalEvent.preventDefault();
          }, ce = function() {
            this.cancelBubble = true;
          }, fe = function() {
            return this.originalEvent.stopPropagation();
          }, pe = function(t3) {
            var e3 = A.doc.documentElement.scrollTop || A.doc.body.scrollTop, r3 = A.doc.documentElement.scrollLeft || A.doc.body.scrollLeft;
            return {
              x: t3.clientX + r3,
              y: t3.clientY + e3
            };
          }, de = function() {
            return A.doc.addEventListener ? function(t3, e3, r3, i3) {
              var n3 = function(t4) {
                var e4 = pe(t4);
                return r3.call(i3, t4, e4.x, e4.y);
              };
              if (t3.addEventListener(e3, n3, false), F && V[e3]) {
                var a2 = function(e4) {
                  for (var n4 = pe(e4), a3 = e4, s2 = 0, o2 = e4.targetTouches && e4.targetTouches.length; s2 < o2; s2++) if (e4.targetTouches[s2].target == t3) {
                    e4 = e4.targetTouches[s2], e4.originalEvent = a3, e4.preventDefault = ue, e4.stopPropagation = fe;
                    break;
                  }
                  return r3.call(i3, e4, n4.x, n4.y);
                };
                t3.addEventListener(V[e3], a2, false);
              }
              return function() {
                return t3.removeEventListener(e3, n3, false), F && V[e3] && t3.removeEventListener(V[e3], a2, false), true;
              };
            } : A.doc.attachEvent ? function(t3, e3, r3, i3) {
              var n3 = function(t4) {
                t4 = t4 || A.win.event;
                var e4 = A.doc.documentElement.scrollTop || A.doc.body.scrollTop, n4 = A.doc.documentElement.scrollLeft || A.doc.body.scrollLeft, a3 = t4.clientX + n4, s2 = t4.clientY + e4;
                return t4.preventDefault = t4.preventDefault || he, t4.stopPropagation = t4.stopPropagation || ce, r3.call(i3, t4, a3, s2);
              };
              t3.attachEvent("on" + e3, n3);
              var a2 = function() {
                return t3.detachEvent("on" + e3, n3), true;
              };
              return a2;
            } : void 0;
          }(), ge = [], xe = function(e3) {
            for (var r3 = e3.clientX, i3 = e3.clientY, n3 = A.doc.documentElement.scrollTop || A.doc.body.scrollTop, a2 = A.doc.documentElement.scrollLeft || A.doc.body.scrollLeft, s2, o2 = ge.length; o2--; ) {
              if (s2 = ge[o2], F && e3.touches) {
                for (var l2 = e3.touches.length, h2; l2--; ) if (h2 = e3.touches[l2], h2.identifier == s2.el._drag.id) {
                  r3 = h2.clientX, i3 = h2.clientY, (e3.originalEvent ? e3.originalEvent : e3).preventDefault();
                  break;
                }
              } else e3.preventDefault();
              var u2 = s2.el.node, c2, f2 = u2.nextSibling, p2 = u2.parentNode, d2 = u2.style.display;
              A.win.opera && p2.removeChild(u2), u2.style.display = "none", c2 = s2.el.paper.getElementByPoint(r3, i3), u2.style.display = d2, A.win.opera && (f2 ? p2.insertBefore(u2, f2) : p2.appendChild(u2)), c2 && t2("raphael.drag.over." + s2.el.id, s2.el, c2), r3 += a2, i3 += n3, t2("raphael.drag.move." + s2.el.id, s2.move_scope || s2.el, r3 - s2.el._drag.x, i3 - s2.el._drag.y, r3, i3, e3);
            }
          }, ve = function(r3) {
            e2.unmousemove(xe).unmouseup(ve);
            for (var i3 = ge.length, n3; i3--; ) n3 = ge[i3], n3.el._drag = {}, t2("raphael.drag.end." + n3.el.id, n3.end_scope || n3.start_scope || n3.move_scope || n3.el, r3);
            ge = [];
          }, ye = e2.el = {}, me = D.length; me--; ) !function(t3) {
            e2[t3] = ye[t3] = function(r3, i3) {
              return e2.is(r3, "function") && (this.events = this.events || [], this.events.push({
                name: t3,
                f: r3,
                unbind: de(this.shape || this.node || A.doc, t3, r3, i3 || this)
              })), this;
            }, e2["un" + t3] = ye["un" + t3] = function(r3) {
              for (var i3 = this.events || [], n3 = i3.length; n3--; ) i3[n3].name != t3 || !e2.is(r3, "undefined") && i3[n3].f != r3 || (i3[n3].unbind(), i3.splice(n3, 1), !i3.length && delete this.events);
              return this;
            };
          }(D[me]);
          ye.data = function(r3, i3) {
            var n3 = wt[this.id] = wt[this.id] || {};
            if (0 == arguments.length) return n3;
            if (1 == arguments.length) {
              if (e2.is(r3, "object")) {
                for (var a2 in r3) r3[T](a2) && this.data(a2, r3[a2]);
                return this;
              }
              return t2("raphael.data.get." + this.id, this, n3[r3], r3), n3[r3];
            }
            return n3[r3] = i3, t2("raphael.data.set." + this.id, this, i3, r3), this;
          }, ye.removeData = function(t3) {
            return null == t3 ? wt[this.id] = {} : wt[this.id] && delete wt[this.id][t3], this;
          }, ye.getData = function() {
            return r2(wt[this.id] || {});
          }, ye.hover = function(t3, e3, r3, i3) {
            return this.mouseover(t3, r3).mouseout(e3, i3 || r3);
          }, ye.unhover = function(t3, e3) {
            return this.unmouseover(t3).unmouseout(e3);
          };
          var be = [];
          ye.drag = function(r3, i3, n3, a2, s2, o2) {
            function l2(l3) {
              (l3.originalEvent || l3).preventDefault();
              var h2 = l3.clientX, u2 = l3.clientY, c2 = A.doc.documentElement.scrollTop || A.doc.body.scrollTop, f2 = A.doc.documentElement.scrollLeft || A.doc.body.scrollLeft;
              if (this._drag.id = l3.identifier, F && l3.touches) {
                for (var p2 = l3.touches.length, d2; p2--; ) if (d2 = l3.touches[p2], this._drag.id = d2.identifier, d2.identifier == this._drag.id) {
                  h2 = d2.clientX, u2 = d2.clientY;
                  break;
                }
              }
              this._drag.x = h2 + f2, this._drag.y = u2 + c2, !ge.length && e2.mousemove(xe).mouseup(ve), ge.push({
                el: this,
                move_scope: a2,
                start_scope: s2,
                end_scope: o2
              }), i3 && t2.on("raphael.drag.start." + this.id, i3), r3 && t2.on("raphael.drag.move." + this.id, r3), n3 && t2.on("raphael.drag.end." + this.id, n3), t2("raphael.drag.start." + this.id, s2 || a2 || this, l3.clientX + f2, l3.clientY + c2, l3);
            }
            return this._drag = {}, be.push({
              el: this,
              start: l2
            }), this.mousedown(l2), this;
          }, ye.onDragOver = function(e3) {
            e3 ? t2.on("raphael.drag.over." + this.id, e3) : t2.unbind("raphael.drag.over." + this.id);
          }, ye.undrag = function() {
            for (var r3 = be.length; r3--; ) be[r3].el == this && (this.unmousedown(be[r3].start), be.splice(r3, 1), t2.unbind("raphael.drag.*." + this.id));
            !be.length && e2.unmousemove(xe).unmouseup(ve), ge = [];
          }, M.circle = function(t3, r3, i3) {
            var n3 = e2._engine.circle(this, t3 || 0, r3 || 0, i3 || 0);
            return this.__set__ && this.__set__.push(n3), n3;
          }, M.rect = function(t3, r3, i3, n3, a2) {
            var s2 = e2._engine.rect(this, t3 || 0, r3 || 0, i3 || 0, n3 || 0, a2 || 0);
            return this.__set__ && this.__set__.push(s2), s2;
          }, M.ellipse = function(t3, r3, i3, n3) {
            var a2 = e2._engine.ellipse(this, t3 || 0, r3 || 0, i3 || 0, n3 || 0);
            return this.__set__ && this.__set__.push(a2), a2;
          }, M.path = function(t3) {
            t3 && !e2.is(t3, Z) && !e2.is(t3[0], Q) && (t3 += R);
            var r3 = e2._engine.path(e2.format[z](e2, arguments), this);
            return this.__set__ && this.__set__.push(r3), r3;
          }, M.image = function(t3, r3, i3, n3, a2) {
            var s2 = e2._engine.image(this, t3 || "about:blank", r3 || 0, i3 || 0, n3 || 0, a2 || 0);
            return this.__set__ && this.__set__.push(s2), s2;
          }, M.text = function(t3, r3, i3) {
            var n3 = e2._engine.text(this, t3 || 0, r3 || 0, j(i3));
            return this.__set__ && this.__set__.push(n3), n3;
          }, M.set = function(t3) {
            !e2.is(t3, "array") && (t3 = Array.prototype.splice.call(arguments, 0, arguments.length));
            var r3 = new ze(t3);
            return this.__set__ && this.__set__.push(r3), r3.paper = this, r3.type = "set", r3;
          }, M.setStart = function(t3) {
            this.__set__ = t3 || this.set();
          }, M.setFinish = function(t3) {
            var e3 = this.__set__;
            return delete this.__set__, e3;
          }, M.getSize = function() {
            var t3 = this.canvas.parentNode;
            return {
              width: t3.offsetWidth,
              height: t3.offsetHeight
            };
          }, M.setSize = function(t3, r3) {
            return e2._engine.setSize.call(this, t3, r3);
          }, M.setViewBox = function(t3, r3, i3, n3, a2) {
            return e2._engine.setViewBox.call(this, t3, r3, i3, n3, a2);
          }, M.top = M.bottom = null, M.raphael = e2;
          var _e = function(t3) {
            var e3 = t3.getBoundingClientRect(), r3 = t3.ownerDocument, i3 = r3.body, n3 = r3.documentElement, a2 = n3.clientTop || i3.clientTop || 0, s2 = n3.clientLeft || i3.clientLeft || 0, o2 = e3.top + (A.win.pageYOffset || n3.scrollTop || i3.scrollTop) - a2, l2 = e3.left + (A.win.pageXOffset || n3.scrollLeft || i3.scrollLeft) - s2;
            return {
              y: o2,
              x: l2
            };
          };
          M.getElementByPoint = function(t3, e3) {
            var r3 = this, i3 = r3.canvas, n3 = A.doc.elementFromPoint(t3, e3);
            if (A.win.opera && "svg" == n3.tagName) {
              var a2 = _e(i3), s2 = i3.createSVGRect();
              s2.x = t3 - a2.x, s2.y = e3 - a2.y, s2.width = s2.height = 1;
              var o2 = i3.getIntersectionList(s2, null);
              o2.length && (n3 = o2[o2.length - 1]);
            }
            if (!n3) return null;
            for (; n3.parentNode && n3 != i3.parentNode && !n3.raphael; ) n3 = n3.parentNode;
            return n3 == r3.canvas.parentNode && (n3 = i3), n3 = n3 && n3.raphael ? r3.getById(n3.raphaelid) : null;
          }, M.getElementsByBBox = function(t3) {
            var r3 = this.set();
            return this.forEach(function(i3) {
              e2.isBBoxIntersect(i3.getBBox(), t3) && r3.push(i3);
            }), r3;
          }, M.getById = function(t3) {
            for (var e3 = this.bottom; e3; ) {
              if (e3.id == t3) return e3;
              e3 = e3.next;
            }
            return null;
          }, M.forEach = function(t3, e3) {
            for (var r3 = this.bottom; r3; ) {
              if (t3.call(e3, r3) === false) return this;
              r3 = r3.next;
            }
            return this;
          }, M.getElementsByPoint = function(t3, e3) {
            var r3 = this.set();
            return this.forEach(function(i3) {
              i3.isPointInside(t3, e3) && r3.push(i3);
            }), r3;
          }, ye.isPointInside = function(t3, r3) {
            var i3 = this.realPath = Et[this.type](this);
            return this.attr("transform") && this.attr("transform").length && (i3 = e2.transformPath(i3, this.attr("transform"))), e2.isPointInsidePath(i3, t3, r3);
          }, ye.getBBox = function(t3) {
            if (this.removed) return {};
            var e3 = this._;
            return t3 ? (!e3.dirty && e3.bboxwt || (this.realPath = Et[this.type](this), e3.bboxwt = Ot(this.realPath), e3.bboxwt.toString = v, e3.dirty = 0), e3.bboxwt) : ((e3.dirty || e3.dirtyT || !e3.bbox) && (!e3.dirty && this.realPath || (e3.bboxwt = 0, this.realPath = Et[this.type](this)), e3.bbox = Ot(Nt(this.realPath, this.matrix)), e3.bbox.toString = v, e3.dirty = e3.dirtyT = 0), e3.bbox);
          }, ye.clone = function() {
            if (this.removed) return null;
            var t3 = this.paper[this.type]().attr(this.attr());
            return this.__set__ && this.__set__.push(t3), t3;
          }, ye.glow = function(t3) {
            if ("text" == this.type) return null;
            t3 = t3 || {};
            var e3 = {
              width: (t3.width || 10) + (+this.attr("stroke-width") || 1),
              fill: t3.fill || false,
              opacity: null == t3.opacity ? 0.5 : t3.opacity,
              offsetx: t3.offsetx || 0,
              offsety: t3.offsety || 0,
              color: t3.color || "#000"
            }, r3 = e3.width / 2, i3 = this.paper, n3 = i3.set(), a2 = this.realPath || Et[this.type](this);
            a2 = this.matrix ? Nt(a2, this.matrix) : a2;
            for (var s2 = 1; s2 < r3 + 1; s2++) n3.push(i3.path(a2).attr({
              stroke: e3.color,
              fill: e3.fill ? e3.color : "none",
              "stroke-linejoin": "round",
              "stroke-linecap": "round",
              "stroke-width": +(e3.width / r3 * s2).toFixed(3),
              opacity: +(e3.opacity / r3).toFixed(3)
            }));
            return n3.insertBefore(this).translate(e3.offsetx, e3.offsety);
          };
          var we = {}, ke = function(t3, r3, i3, n3, a2, s2, o2, u2, c2) {
            return null == c2 ? l(t3, r3, i3, n3, a2, s2, o2, u2) : e2.findDotsAtSegment(t3, r3, i3, n3, a2, s2, o2, u2, h(t3, r3, i3, n3, a2, s2, o2, u2, c2));
          }, Be = function(t3, r3) {
            return function(i3, n3, a2) {
              i3 = Qt(i3);
              for (var s2, o2, l2, h2, u2 = "", c2 = {}, f2, p2 = 0, d2 = 0, g2 = i3.length; d2 < g2; d2++) {
                if (l2 = i3[d2], "M" == l2[0]) s2 = +l2[1], o2 = +l2[2];
                else {
                  if (h2 = ke(s2, o2, l2[1], l2[2], l2[3], l2[4], l2[5], l2[6]), p2 + h2 > n3) {
                    if (r3 && !c2.start) {
                      if (f2 = ke(s2, o2, l2[1], l2[2], l2[3], l2[4], l2[5], l2[6], n3 - p2), u2 += ["C" + f2.start.x, f2.start.y, f2.m.x, f2.m.y, f2.x, f2.y], a2) return u2;
                      c2.start = u2, u2 = ["M" + f2.x, f2.y + "C" + f2.n.x, f2.n.y, f2.end.x, f2.end.y, l2[5], l2[6]].join(), p2 += h2, s2 = +l2[5], o2 = +l2[6];
                      continue;
                    }
                    if (!t3 && !r3) return f2 = ke(s2, o2, l2[1], l2[2], l2[3], l2[4], l2[5], l2[6], n3 - p2), {
                      x: f2.x,
                      y: f2.y,
                      alpha: f2.alpha
                    };
                  }
                  p2 += h2, s2 = +l2[5], o2 = +l2[6];
                }
                u2 += l2.shift() + l2;
              }
              return c2.end = u2, f2 = t3 ? p2 : r3 ? c2 : e2.findDotsAtSegment(s2, o2, l2[0], l2[1], l2[2], l2[3], l2[4], l2[5], 1), f2.alpha && (f2 = {
                x: f2.x,
                y: f2.y,
                alpha: f2.alpha
              }), f2;
            };
          }, Ce = Be(1), Se = Be(), Te = Be(0, 1);
          e2.getTotalLength = Ce, e2.getPointAtLength = Se, e2.getSubpath = function(t3, e3, r3) {
            if (this.getTotalLength(t3) - r3 < 1e-6) return Te(t3, e3).end;
            var i3 = Te(t3, r3, 1);
            return e3 ? Te(i3, e3).end : i3;
          }, ye.getTotalLength = function() {
            var t3 = this.getPath();
            if (t3) return this.node.getTotalLength ? this.node.getTotalLength() : Ce(t3);
          }, ye.getPointAtLength = function(t3) {
            var e3 = this.getPath();
            if (e3) return Se(e3, t3);
          }, ye.getPath = function() {
            var t3, r3 = e2._getPath[this.type];
            if ("text" != this.type && "set" != this.type) return r3 && (t3 = r3(this)), t3;
          }, ye.getSubpath = function(t3, r3) {
            var i3 = this.getPath();
            if (i3) return e2.getSubpath(i3, t3, r3);
          };
          var Ae = e2.easing_formulas = {
            linear: function(t3) {
              return t3;
            },
            "<": function(t3) {
              return X(t3, 1.7);
            },
            ">": function(t3) {
              return X(t3, 0.48);
            },
            "<>": function(t3) {
              var e3 = 0.48 - t3 / 1.04, r3 = Y.sqrt(0.1734 + e3 * e3), i3 = r3 - e3, n3 = X(H(i3), 1 / 3) * (i3 < 0 ? -1 : 1), a2 = -r3 - e3, s2 = X(H(a2), 1 / 3) * (a2 < 0 ? -1 : 1), o2 = n3 + s2 + 0.5;
              return 3 * (1 - o2) * o2 * o2 + o2 * o2 * o2;
            },
            backIn: function(t3) {
              var e3 = 1.70158;
              return t3 * t3 * ((e3 + 1) * t3 - e3);
            },
            backOut: function(t3) {
              t3 -= 1;
              var e3 = 1.70158;
              return t3 * t3 * ((e3 + 1) * t3 + e3) + 1;
            },
            elastic: function(t3) {
              return t3 == !!t3 ? t3 : X(2, -10 * t3) * Y.sin((t3 - 0.075) * (2 * U) / 0.3) + 1;
            },
            bounce: function(t3) {
              var e3 = 7.5625, r3 = 2.75, i3;
              return t3 < 1 / r3 ? i3 = e3 * t3 * t3 : t3 < 2 / r3 ? (t3 -= 1.5 / r3, i3 = e3 * t3 * t3 + 0.75) : t3 < 2.5 / r3 ? (t3 -= 2.25 / r3, i3 = e3 * t3 * t3 + 0.9375) : (t3 -= 2.625 / r3, i3 = e3 * t3 * t3 + 0.984375), i3;
            }
          };
          Ae.easeIn = Ae["ease-in"] = Ae["<"], Ae.easeOut = Ae["ease-out"] = Ae[">"], Ae.easeInOut = Ae["ease-in-out"] = Ae["<>"], Ae["back-in"] = Ae.backIn, Ae["back-out"] = Ae.backOut;
          var Ee = [], Ne = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t3) {
            setTimeout(t3, 16);
          }, Me = function() {
            for (var r3 = +/* @__PURE__ */ new Date(), i3 = 0; i3 < Ee.length; i3++) {
              var n3 = Ee[i3];
              if (!n3.el.removed && !n3.paused) {
                var a2 = r3 - n3.start, s2 = n3.ms, o2 = n3.easing, l2 = n3.from, h2 = n3.diff, u2 = n3.to, c2 = n3.t, f2 = n3.el, p2 = {}, d2, g2 = {}, x2;
                if (n3.initstatus ? (a2 = (n3.initstatus * n3.anim.top - n3.prev) / (n3.percent - n3.prev) * s2, n3.status = n3.initstatus, delete n3.initstatus, n3.stop && Ee.splice(i3--, 1)) : n3.status = (n3.prev + (n3.percent - n3.prev) * (a2 / s2)) / n3.anim.top, !(a2 < 0)) if (a2 < s2) {
                  var v2 = o2(a2 / s2);
                  for (var y2 in l2) if (l2[T](y2)) {
                    switch (pt[y2]) {
                      case $:
                        d2 = +l2[y2] + v2 * s2 * h2[y2];
                        break;
                      case "colour":
                        d2 = "rgb(" + [Le(ot(l2[y2].r + v2 * s2 * h2[y2].r)), Le(ot(l2[y2].g + v2 * s2 * h2[y2].g)), Le(ot(l2[y2].b + v2 * s2 * h2[y2].b))].join(",") + ")";
                        break;
                      case "path":
                        d2 = [];
                        for (var m2 = 0, _2 = l2[y2].length; m2 < _2; m2++) {
                          d2[m2] = [l2[y2][m2][0]];
                          for (var w2 = 1, k2 = l2[y2][m2].length; w2 < k2; w2++) d2[m2][w2] = +l2[y2][m2][w2] + v2 * s2 * h2[y2][m2][w2];
                          d2[m2] = d2[m2].join(I);
                        }
                        d2 = d2.join(I);
                        break;
                      case "transform":
                        if (h2[y2].real) for (d2 = [], m2 = 0, _2 = l2[y2].length; m2 < _2; m2++) for (d2[m2] = [l2[y2][m2][0]], w2 = 1, k2 = l2[y2][m2].length; w2 < k2; w2++) d2[m2][w2] = l2[y2][m2][w2] + v2 * s2 * h2[y2][m2][w2];
                        else {
                          var B2 = function(t3) {
                            return +l2[y2][t3] + v2 * s2 * h2[y2][t3];
                          };
                          d2 = [["m", B2(0), B2(1), B2(2), B2(3), B2(4), B2(5)]];
                        }
                        break;
                      case "csv":
                        if ("clip-rect" == y2) for (d2 = [], m2 = 4; m2--; ) d2[m2] = +l2[y2][m2] + v2 * s2 * h2[y2][m2];
                        break;
                      default:
                        var C2 = [][P](l2[y2]);
                        for (d2 = [], m2 = f2.paper.customAttributes[y2].length; m2--; ) d2[m2] = +C2[m2] + v2 * s2 * h2[y2][m2];
                    }
                    p2[y2] = d2;
                  }
                  f2.attr(p2), function(e3, r4, i4) {
                    setTimeout(function() {
                      t2("raphael.anim.frame." + e3, r4, i4);
                    });
                  }(f2.id, f2, n3.anim);
                } else {
                  if (function(r4, i4, n4) {
                    setTimeout(function() {
                      t2("raphael.anim.frame." + i4.id, i4, n4), t2("raphael.anim.finish." + i4.id, i4, n4), e2.is(r4, "function") && r4.call(i4);
                    });
                  }(n3.callback, f2, n3.anim), f2.attr(u2), Ee.splice(i3--, 1), n3.repeat > 1 && !n3.next) {
                    for (x2 in u2) u2[T](x2) && (g2[x2] = n3.totalOrigin[x2]);
                    n3.el.attr(g2), b(n3.anim, n3.el, n3.anim.percents[0], null, n3.totalOrigin, n3.repeat - 1);
                  }
                  n3.next && !n3.stop && b(n3.anim, n3.el, n3.next, null, n3.totalOrigin, n3.repeat);
                }
              }
            }
            Ee.length && Ne(Me);
          }, Le = function(t3) {
            return t3 > 255 ? 255 : t3 < 0 ? 0 : t3;
          };
          ye.animateWith = function(t3, r3, i3, n3, a2, s2) {
            var o2 = this;
            if (o2.removed) return s2 && s2.call(o2), o2;
            var l2 = i3 instanceof m ? i3 : e2.animation(i3, n3, a2, s2), h2, u2;
            b(l2, o2, l2.percents[0], null, o2.attr());
            for (var c2 = 0, f2 = Ee.length; c2 < f2; c2++) if (Ee[c2].anim == r3 && Ee[c2].el == t3) {
              Ee[f2 - 1].start = Ee[c2].start;
              break;
            }
            return o2;
          }, ye.onAnimation = function(e3) {
            return e3 ? t2.on("raphael.anim.frame." + this.id, e3) : t2.unbind("raphael.anim.frame." + this.id), this;
          }, m.prototype.delay = function(t3) {
            var e3 = new m(this.anim, this.ms);
            return e3.times = this.times, e3.del = +t3 || 0, e3;
          }, m.prototype.repeat = function(t3) {
            var e3 = new m(this.anim, this.ms);
            return e3.del = this.del, e3.times = Y.floor(W(t3, 0)) || 1, e3;
          }, e2.animation = function(t3, r3, i3, n3) {
            if (t3 instanceof m) return t3;
            !e2.is(i3, "function") && i3 || (n3 = n3 || i3 || null, i3 = null), t3 = Object(t3), r3 = +r3 || 0;
            var a2 = {}, s2, o2;
            for (o2 in t3) t3[T](o2) && ht(o2) != o2 && ht(o2) + "%" != o2 && (s2 = true, a2[o2] = t3[o2]);
            if (s2) return i3 && (a2.easing = i3), n3 && (a2.callback = n3), new m({
              100: a2
            }, r3);
            if (n3) {
              var l2 = 0;
              for (var h2 in t3) {
                var u2 = ut(h2);
                t3[T](h2) && u2 > l2 && (l2 = u2);
              }
              l2 += "%", !t3[l2].callback && (t3[l2].callback = n3);
            }
            return new m(t3, r3);
          }, ye.animate = function(t3, r3, i3, n3) {
            var a2 = this;
            if (a2.removed) return n3 && n3.call(a2), a2;
            var s2 = t3 instanceof m ? t3 : e2.animation(t3, r3, i3, n3);
            return b(s2, a2, s2.percents[0], null, a2.attr()), a2;
          }, ye.setTime = function(t3, e3) {
            return t3 && null != e3 && this.status(t3, G(e3, t3.ms) / t3.ms), this;
          }, ye.status = function(t3, e3) {
            var r3 = [], i3 = 0, n3, a2;
            if (null != e3) return b(t3, this, -1, G(e3, 1)), this;
            for (n3 = Ee.length; i3 < n3; i3++) if (a2 = Ee[i3], a2.el.id == this.id && (!t3 || a2.anim == t3)) {
              if (t3) return a2.status;
              r3.push({
                anim: a2.anim,
                status: a2.status
              });
            }
            return t3 ? 0 : r3;
          }, ye.pause = function(e3) {
            for (var r3 = 0; r3 < Ee.length; r3++) Ee[r3].el.id != this.id || e3 && Ee[r3].anim != e3 || t2("raphael.anim.pause." + this.id, this, Ee[r3].anim) !== false && (Ee[r3].paused = true);
            return this;
          }, ye.resume = function(e3) {
            for (var r3 = 0; r3 < Ee.length; r3++) if (Ee[r3].el.id == this.id && (!e3 || Ee[r3].anim == e3)) {
              var i3 = Ee[r3];
              t2("raphael.anim.resume." + this.id, this, i3.anim) !== false && (delete i3.paused, this.status(i3.anim, i3.status));
            }
            return this;
          }, ye.stop = function(e3) {
            for (var r3 = 0; r3 < Ee.length; r3++) Ee[r3].el.id != this.id || e3 && Ee[r3].anim != e3 || t2("raphael.anim.stop." + this.id, this, Ee[r3].anim) !== false && Ee.splice(r3--, 1);
            return this;
          }, t2.on("raphael.remove", _), t2.on("raphael.clear", _), ye.toString = function() {
            return "Raphaël’s object";
          };
          var ze = function(t3) {
            if (this.items = [], this.length = 0, this.type = "set", t3) for (var e3 = 0, r3 = t3.length; e3 < r3; e3++) !t3[e3] || t3[e3].constructor != ye.constructor && t3[e3].constructor != ze || (this[this.items.length] = this.items[this.items.length] = t3[e3], this.length++);
          }, Pe = ze.prototype;
          Pe.push = function() {
            for (var t3, e3, r3 = 0, i3 = arguments.length; r3 < i3; r3++) t3 = arguments[r3], !t3 || t3.constructor != ye.constructor && t3.constructor != ze || (e3 = this.items.length, this[e3] = this.items[e3] = t3, this.length++);
            return this;
          }, Pe.pop = function() {
            return this.length && delete this[this.length--], this.items.pop();
          }, Pe.forEach = function(t3, e3) {
            for (var r3 = 0, i3 = this.items.length; r3 < i3; r3++) if (t3.call(e3, this.items[r3], r3) === false) return this;
            return this;
          };
          for (var Fe in ye) ye[T](Fe) && (Pe[Fe] = /* @__PURE__ */ function(t3) {
            return function() {
              var e3 = arguments;
              return this.forEach(function(r3) {
                r3[t3][z](r3, e3);
              });
            };
          }(Fe));
          return Pe.attr = function(t3, r3) {
            if (t3 && e2.is(t3, Q) && e2.is(t3[0], "object")) for (var i3 = 0, n3 = t3.length; i3 < n3; i3++) this.items[i3].attr(t3[i3]);
            else for (var a2 = 0, s2 = this.items.length; a2 < s2; a2++) this.items[a2].attr(t3, r3);
            return this;
          }, Pe.clear = function() {
            for (; this.length; ) this.pop();
          }, Pe.splice = function(t3, e3, r3) {
            t3 = t3 < 0 ? W(this.length + t3, 0) : t3, e3 = W(0, G(this.length - t3, e3));
            var i3 = [], n3 = [], a2 = [], s2;
            for (s2 = 2; s2 < arguments.length; s2++) a2.push(arguments[s2]);
            for (s2 = 0; s2 < e3; s2++) n3.push(this[t3 + s2]);
            for (; s2 < this.length - t3; s2++) i3.push(this[t3 + s2]);
            var o2 = a2.length;
            for (s2 = 0; s2 < o2 + i3.length; s2++) this.items[t3 + s2] = this[t3 + s2] = s2 < o2 ? a2[s2] : i3[s2 - o2];
            for (s2 = this.items.length = this.length -= e3 - o2; this[s2]; ) delete this[s2++];
            return new ze(n3);
          }, Pe.exclude = function(t3) {
            for (var e3 = 0, r3 = this.length; e3 < r3; e3++) if (this[e3] == t3) return this.splice(e3, 1), true;
          }, Pe.animate = function(t3, r3, i3, n3) {
            (e2.is(i3, "function") || !i3) && (n3 = i3 || null);
            var a2 = this.items.length, s2 = a2, o2, l2 = this, h2;
            if (!a2) return this;
            n3 && (h2 = function() {
              !--a2 && n3.call(l2);
            }), i3 = e2.is(i3, Z) ? i3 : h2;
            var u2 = e2.animation(t3, r3, i3, h2);
            for (o2 = this.items[--s2].animate(u2); s2--; ) this.items[s2] && !this.items[s2].removed && this.items[s2].animateWith(o2, u2, u2), this.items[s2] && !this.items[s2].removed || a2--;
            return this;
          }, Pe.insertAfter = function(t3) {
            for (var e3 = this.items.length; e3--; ) this.items[e3].insertAfter(t3);
            return this;
          }, Pe.getBBox = function() {
            for (var t3 = [], e3 = [], r3 = [], i3 = [], n3 = this.items.length; n3--; ) if (!this.items[n3].removed) {
              var a2 = this.items[n3].getBBox();
              t3.push(a2.x), e3.push(a2.y), r3.push(a2.x + a2.width), i3.push(a2.y + a2.height);
            }
            return t3 = G[z](0, t3), e3 = G[z](0, e3), r3 = W[z](0, r3), i3 = W[z](0, i3), {
              x: t3,
              y: e3,
              x2: r3,
              y2: i3,
              width: r3 - t3,
              height: i3 - e3
            };
          }, Pe.clone = function(t3) {
            t3 = this.paper.set();
            for (var e3 = 0, r3 = this.items.length; e3 < r3; e3++) t3.push(this.items[e3].clone());
            return t3;
          }, Pe.toString = function() {
            return "Raphaël‘s set";
          }, Pe.glow = function(t3) {
            var e3 = this.paper.set();
            return this.forEach(function(r3, i3) {
              var n3 = r3.glow(t3);
              null != n3 && n3.forEach(function(t4, r4) {
                e3.push(t4);
              });
            }), e3;
          }, Pe.isPointInside = function(t3, e3) {
            var r3 = false;
            return this.forEach(function(i3) {
              if (i3.isPointInside(t3, e3)) return r3 = true, false;
            }), r3;
          }, e2.registerFont = function(t3) {
            if (!t3.face) return t3;
            this.fonts = this.fonts || {};
            var e3 = {
              w: t3.w,
              face: {},
              glyphs: {}
            }, r3 = t3.face["font-family"];
            for (var i3 in t3.face) t3.face[T](i3) && (e3.face[i3] = t3.face[i3]);
            if (this.fonts[r3] ? this.fonts[r3].push(e3) : this.fonts[r3] = [e3], !t3.svg) {
              e3.face["units-per-em"] = ut(t3.face["units-per-em"], 10);
              for (var n3 in t3.glyphs) if (t3.glyphs[T](n3)) {
                var a2 = t3.glyphs[n3];
                if (e3.glyphs[n3] = {
                  w: a2.w,
                  k: {},
                  d: a2.d && "M" + a2.d.replace(/[mlcxtrv]/g, function(t4) {
                    return {
                      l: "L",
                      c: "C",
                      x: "z",
                      t: "m",
                      r: "l",
                      v: "c"
                    }[t4] || "M";
                  }) + "z"
                }, a2.k) for (var s2 in a2.k) a2[T](s2) && (e3.glyphs[n3].k[s2] = a2.k[s2]);
              }
            }
            return t3;
          }, M.getFont = function(t3, r3, i3, n3) {
            if (n3 = n3 || "normal", i3 = i3 || "normal", r3 = +r3 || {
              normal: 400,
              bold: 700,
              lighter: 300,
              bolder: 800
            }[r3] || 400, e2.fonts) {
              var a2 = e2.fonts[t3];
              if (!a2) {
                var s2 = new RegExp("(^|\\s)" + t3.replace(/[^\w\d\s+!~.:_-]/g, R) + "(\\s|$)", "i");
                for (var o2 in e2.fonts) if (e2.fonts[T](o2) && s2.test(o2)) {
                  a2 = e2.fonts[o2];
                  break;
                }
              }
              var l2;
              if (a2) for (var h2 = 0, u2 = a2.length; h2 < u2 && (l2 = a2[h2], l2.face["font-weight"] != r3 || l2.face["font-style"] != i3 && l2.face["font-style"] || l2.face["font-stretch"] != n3); h2++) ;
              return l2;
            }
          }, M.print = function(t3, r3, i3, n3, a2, s2, o2, l2) {
            s2 = s2 || "middle", o2 = W(G(o2 || 0, 1), -1), l2 = W(G(l2 || 1, 3), 1);
            var h2 = j(i3)[q](R), u2 = 0, c2 = 0, f2 = R, p2;
            if (e2.is(n3, "string") && (n3 = this.getFont(n3)), n3) {
              p2 = (a2 || 16) / n3.face["units-per-em"];
              for (var d2 = n3.face.bbox[q](k), g2 = +d2[0], x2 = d2[3] - d2[1], v2 = 0, y2 = +d2[1] + ("baseline" == s2 ? x2 + +n3.face.descent : x2 / 2), m2 = 0, b2 = h2.length; m2 < b2; m2++) {
                if ("\n" == h2[m2]) u2 = 0, w2 = 0, c2 = 0, v2 += x2 * l2;
                else {
                  var _2 = c2 && n3.glyphs[h2[m2 - 1]] || {}, w2 = n3.glyphs[h2[m2]];
                  u2 += c2 ? (_2.w || n3.w) + (_2.k && _2.k[h2[m2]] || 0) + n3.w * o2 : 0, c2 = 1;
                }
                w2 && w2.d && (f2 += e2.transformPath(w2.d, ["t", u2 * p2, v2 * p2, "s", p2, p2, g2, y2, "t", (t3 - g2) / p2, (r3 - y2) / p2]));
              }
            }
            return this.path(f2).attr({
              fill: "#000",
              stroke: "none"
            });
          }, M.add = function(t3) {
            if (e2.is(t3, "array")) for (var r3 = this.set(), i3 = 0, n3 = t3.length, a2; i3 < n3; i3++) a2 = t3[i3] || {}, B[T](a2.type) && r3.push(this[a2.type]().attr(a2));
            return r3;
          }, e2.format = function(t3, r3) {
            var i3 = e2.is(r3, Q) ? [0][P](r3) : arguments;
            return t3 && e2.is(t3, Z) && i3.length - 1 && (t3 = t3.replace(C, function(t4, e3) {
              return null == i3[++e3] ? R : i3[e3];
            })), t3 || R;
          }, e2.fullfill = /* @__PURE__ */ function() {
            var t3 = /\{([^\}]+)\}/g, e3 = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, r3 = function(t4, r4, i3) {
              var n3 = i3;
              return r4.replace(e3, function(t5, e4, r5, i4, a2) {
                e4 = e4 || i4, n3 && (e4 in n3 && (n3 = n3[e4]), "function" == typeof n3 && a2 && (n3 = n3()));
              }), n3 = (null == n3 || n3 == i3 ? t4 : n3) + "";
            };
            return function(e4, i3) {
              return String(e4).replace(t3, function(t4, e5) {
                return r3(t4, e5, i3);
              });
            };
          }(), e2.ninja = function() {
            if (E.was) A.win.Raphael = E.is;
            else {
              window.Raphael = void 0;
              try {
                delete window.Raphael;
              } catch (t3) {
              }
            }
            return e2;
          }, e2.st = Pe, t2.on("raphael.DOMload", function() {
            w = true;
          }), function(t3, r3, i3) {
            function n3() {
              /in/.test(t3.readyState) ? setTimeout(n3, 9) : e2.eve("raphael.DOMload");
            }
            null == t3.readyState && t3.addEventListener && (t3.addEventListener(r3, i3 = function() {
              t3.removeEventListener(r3, i3, false), t3.readyState = "complete";
            }, false), t3.readyState = "loading"), n3();
          }(document, "DOMContentLoaded"), e2;
        }.apply(e, i), !(void 0 !== n && (t.exports = n));
      }, function(t, e, r) {
        var i, n;
        !function(r2) {
          var a = "0.4.2", s = "hasOwnProperty", o = /[\.\/]/, l = "*", h = function() {
          }, u = function(t2, e2) {
            return t2 - e2;
          }, c, f, p = {
            n: {}
          }, d = function(t2, e2) {
            t2 = String(t2);
            var r3 = p, i2 = f, n2 = Array.prototype.slice.call(arguments, 2), a2 = d.listeners(t2), s2 = 0, o2 = false, l2, h2 = [], g = {}, x = [], v = c, y = [];
            c = t2, f = 0;
            for (var m = 0, b = a2.length; m < b; m++) "zIndex" in a2[m] && (h2.push(a2[m].zIndex), a2[m].zIndex < 0 && (g[a2[m].zIndex] = a2[m]));
            for (h2.sort(u); h2[s2] < 0; ) if (l2 = g[h2[s2++]], x.push(l2.apply(e2, n2)), f) return f = i2, x;
            for (m = 0; m < b; m++) if (l2 = a2[m], "zIndex" in l2) {
              if (l2.zIndex == h2[s2]) {
                if (x.push(l2.apply(e2, n2)), f) break;
                do
                  if (s2++, l2 = g[h2[s2]], l2 && x.push(l2.apply(e2, n2)), f) break;
                while (l2);
              } else g[l2.zIndex] = l2;
            } else if (x.push(l2.apply(e2, n2)), f) break;
            return f = i2, c = v, x.length ? x : null;
          };
          d._events = p, d.listeners = function(t2) {
            var e2 = t2.split(o), r3 = p, i2, n2, a2, s2, h2, u2, c2, f2, d2 = [r3], g = [];
            for (s2 = 0, h2 = e2.length; s2 < h2; s2++) {
              for (f2 = [], u2 = 0, c2 = d2.length; u2 < c2; u2++) for (r3 = d2[u2].n, n2 = [r3[e2[s2]], r3[l]], a2 = 2; a2--; ) i2 = n2[a2], i2 && (f2.push(i2), g = g.concat(i2.f || []));
              d2 = f2;
            }
            return g;
          }, d.on = function(t2, e2) {
            if (t2 = String(t2), "function" != typeof e2) return function() {
            };
            for (var r3 = t2.split(o), i2 = p, n2 = 0, a2 = r3.length; n2 < a2; n2++) i2 = i2.n, i2 = i2.hasOwnProperty(r3[n2]) && i2[r3[n2]] || (i2[r3[n2]] = {
              n: {}
            });
            for (i2.f = i2.f || [], n2 = 0, a2 = i2.f.length; n2 < a2; n2++) if (i2.f[n2] == e2) return h;
            return i2.f.push(e2), function(t3) {
              +t3 == +t3 && (e2.zIndex = +t3);
            };
          }, d.f = function(t2) {
            var e2 = [].slice.call(arguments, 1);
            return function() {
              d.apply(null, [t2, null].concat(e2).concat([].slice.call(arguments, 0)));
            };
          }, d.stop = function() {
            f = 1;
          }, d.nt = function(t2) {
            return t2 ? new RegExp("(?:\\.|\\/|^)" + t2 + "(?:\\.|\\/|$)").test(c) : c;
          }, d.nts = function() {
            return c.split(o);
          }, d.off = d.unbind = function(t2, e2) {
            if (!t2) return void (d._events = p = {
              n: {}
            });
            var r3 = t2.split(o), i2, n2, a2, h2, u2, c2, f2, g = [p];
            for (h2 = 0, u2 = r3.length; h2 < u2; h2++) for (c2 = 0; c2 < g.length; c2 += a2.length - 2) {
              if (a2 = [c2, 1], i2 = g[c2].n, r3[h2] != l) i2[r3[h2]] && a2.push(i2[r3[h2]]);
              else for (n2 in i2) i2[s](n2) && a2.push(i2[n2]);
              g.splice.apply(g, a2);
            }
            for (h2 = 0, u2 = g.length; h2 < u2; h2++) for (i2 = g[h2]; i2.n; ) {
              if (e2) {
                if (i2.f) {
                  for (c2 = 0, f2 = i2.f.length; c2 < f2; c2++) if (i2.f[c2] == e2) {
                    i2.f.splice(c2, 1);
                    break;
                  }
                  !i2.f.length && delete i2.f;
                }
                for (n2 in i2.n) if (i2.n[s](n2) && i2.n[n2].f) {
                  var x = i2.n[n2].f;
                  for (c2 = 0, f2 = x.length; c2 < f2; c2++) if (x[c2] == e2) {
                    x.splice(c2, 1);
                    break;
                  }
                  !x.length && delete i2.n[n2].f;
                }
              } else {
                delete i2.f;
                for (n2 in i2.n) i2.n[s](n2) && i2.n[n2].f && delete i2.n[n2].f;
              }
              i2 = i2.n;
            }
          }, d.once = function(t2, e2) {
            var r3 = function() {
              return d.unbind(t2, r3), e2.apply(this, arguments);
            };
            return d.on(t2, r3);
          }, d.version = a, d.toString = function() {
            return "You are running Eve " + a;
          }, "undefined" != typeof t && t.exports ? t.exports = d : (i = [], n = function() {
            return d;
          }.apply(e, i), !(void 0 !== n && (t.exports = n)));
        }(this);
      }, function(t, e, r) {
        var i, n;
        i = [r(1)], n = function(t2) {
          if (!t2 || t2.svg) {
            var e2 = "hasOwnProperty", r2 = String, i2 = parseFloat, n2 = parseInt, a = Math, s = a.max, o = a.abs, l = a.pow, h = /[, ]+/, u = t2.eve, c = "", f = " ", p = "http://www.w3.org/1999/xlink", d = {
              block: "M5,0 0,2.5 5,5z",
              classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
              diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
              open: "M6,1 1,3.5 6,6",
              oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
            }, g = {};
            t2.toString = function() {
              return "Your browser supports SVG.\nYou are running Raphaël " + this.version;
            };
            var x = function(i3, n3) {
              if (n3) {
                "string" == typeof i3 && (i3 = x(i3));
                for (var a2 in n3) n3[e2](a2) && ("xlink:" == a2.substring(0, 6) ? i3.setAttributeNS(p, a2.substring(6), r2(n3[a2])) : i3.setAttribute(a2, r2(n3[a2])));
              } else i3 = t2._g.doc.createElementNS("http://www.w3.org/2000/svg", i3), i3.style && (i3.style.webkitTapHighlightColor = "rgba(0,0,0,0)");
              return i3;
            }, v = function(e3, n3) {
              var h2 = "linear", u2 = e3.id + n3, f2 = 0.5, p2 = 0.5, d2 = e3.node, g2 = e3.paper, v2 = d2.style, y2 = t2._g.doc.getElementById(u2);
              if (!y2) {
                if (n3 = r2(n3).replace(t2._radial_gradient, function(t3, e4, r3) {
                  if (h2 = "radial", e4 && r3) {
                    f2 = i2(e4), p2 = i2(r3);
                    var n4 = 2 * (p2 > 0.5) - 1;
                    l(f2 - 0.5, 2) + l(p2 - 0.5, 2) > 0.25 && (p2 = a.sqrt(0.25 - l(f2 - 0.5, 2)) * n4 + 0.5) && 0.5 != p2 && (p2 = p2.toFixed(5) - 1e-5 * n4);
                  }
                  return c;
                }), n3 = n3.split(/\s*\-\s*/), "linear" == h2) {
                  var b2 = n3.shift();
                  if (b2 = -i2(b2), isNaN(b2)) return null;
                  var _2 = [0, 0, a.cos(t2.rad(b2)), a.sin(t2.rad(b2))], w2 = 1 / (s(o(_2[2]), o(_2[3])) || 1);
                  _2[2] *= w2, _2[3] *= w2, _2[2] < 0 && (_2[0] = -_2[2], _2[2] = 0), _2[3] < 0 && (_2[1] = -_2[3], _2[3] = 0);
                }
                var k2 = t2._parseDots(n3);
                if (!k2) return null;
                if (u2 = u2.replace(/[\(\)\s,\xb0#]/g, "_"), e3.gradient && u2 != e3.gradient.id && (g2.defs.removeChild(e3.gradient), delete e3.gradient), !e3.gradient) {
                  y2 = x(h2 + "Gradient", {
                    id: u2
                  }), e3.gradient = y2, x(y2, "radial" == h2 ? {
                    fx: f2,
                    fy: p2
                  } : {
                    x1: _2[0],
                    y1: _2[1],
                    x2: _2[2],
                    y2: _2[3],
                    gradientTransform: e3.matrix.invert()
                  }), g2.defs.appendChild(y2);
                  for (var B2 = 0, C2 = k2.length; B2 < C2; B2++) y2.appendChild(x("stop", {
                    offset: k2[B2].offset ? k2[B2].offset : B2 ? "100%" : "0%",
                    "stop-color": k2[B2].color || "#fff",
                    "stop-opacity": isFinite(k2[B2].opacity) ? k2[B2].opacity : 1
                  }));
                }
              }
              return x(d2, {
                fill: m(u2),
                opacity: 1,
                "fill-opacity": 1
              }), v2.fill = c, v2.opacity = 1, v2.fillOpacity = 1, 1;
            }, y = function() {
              var t3 = document.documentMode;
              return t3 && (9 === t3 || 10 === t3);
            }, m = function(t3) {
              if (y()) return "url('#" + t3 + "')";
              var e3 = document.location, r3 = e3.protocol + "//" + e3.host + e3.pathname + e3.search;
              return "url('" + r3 + "#" + t3 + "')";
            }, b = function(t3) {
              var e3 = t3.getBBox(1);
              x(t3.pattern, {
                patternTransform: t3.matrix.invert() + " translate(" + e3.x + "," + e3.y + ")"
              });
            }, _ = function(i3, n3, a2) {
              if ("path" == i3.type) {
                for (var s2 = r2(n3).toLowerCase().split("-"), o2 = i3.paper, l2 = a2 ? "end" : "start", h2 = i3.node, u2 = i3.attrs, f2 = u2["stroke-width"], p2 = s2.length, v2 = "classic", y2, m2, b2, _2, w2, k2 = 3, B2 = 3, C2 = 5; p2--; ) switch (s2[p2]) {
                  case "block":
                  case "classic":
                  case "oval":
                  case "diamond":
                  case "open":
                  case "none":
                    v2 = s2[p2];
                    break;
                  case "wide":
                    B2 = 5;
                    break;
                  case "narrow":
                    B2 = 2;
                    break;
                  case "long":
                    k2 = 5;
                    break;
                  case "short":
                    k2 = 2;
                }
                if ("open" == v2 ? (k2 += 2, B2 += 2, C2 += 2, b2 = 1, _2 = a2 ? 4 : 1, w2 = {
                  fill: "none",
                  stroke: u2.stroke
                }) : (_2 = b2 = k2 / 2, w2 = {
                  fill: u2.stroke,
                  stroke: "none"
                }), i3._.arrows ? a2 ? (i3._.arrows.endPath && g[i3._.arrows.endPath]--, i3._.arrows.endMarker && g[i3._.arrows.endMarker]--) : (i3._.arrows.startPath && g[i3._.arrows.startPath]--, i3._.arrows.startMarker && g[i3._.arrows.startMarker]--) : i3._.arrows = {}, "none" != v2) {
                  var S2 = "raphael-marker-" + v2, T2 = "raphael-marker-" + l2 + v2 + k2 + B2 + "-obj" + i3.id;
                  t2._g.doc.getElementById(S2) ? g[S2]++ : (o2.defs.appendChild(x(x("path"), {
                    "stroke-linecap": "round",
                    d: d[v2],
                    id: S2
                  })), g[S2] = 1);
                  var A2 = t2._g.doc.getElementById(T2), E2;
                  A2 ? (g[T2]++, E2 = A2.getElementsByTagName("use")[0]) : (A2 = x(x("marker"), {
                    id: T2,
                    markerHeight: B2,
                    markerWidth: k2,
                    orient: "auto",
                    refX: _2,
                    refY: B2 / 2
                  }), E2 = x(x("use"), {
                    "xlink:href": "#" + S2,
                    transform: (a2 ? "rotate(180 " + k2 / 2 + " " + B2 / 2 + ") " : c) + "scale(" + k2 / C2 + "," + B2 / C2 + ")",
                    "stroke-width": (1 / ((k2 / C2 + B2 / C2) / 2)).toFixed(4)
                  }), A2.appendChild(E2), o2.defs.appendChild(A2), g[T2] = 1), x(E2, w2);
                  var N2 = b2 * ("diamond" != v2 && "oval" != v2);
                  a2 ? (y2 = i3._.arrows.startdx * f2 || 0, m2 = t2.getTotalLength(u2.path) - N2 * f2) : (y2 = N2 * f2, m2 = t2.getTotalLength(u2.path) - (i3._.arrows.enddx * f2 || 0)), w2 = {}, w2["marker-" + l2] = "url(#" + T2 + ")", (m2 || y2) && (w2.d = t2.getSubpath(u2.path, y2, m2)), x(h2, w2), i3._.arrows[l2 + "Path"] = S2, i3._.arrows[l2 + "Marker"] = T2, i3._.arrows[l2 + "dx"] = N2, i3._.arrows[l2 + "Type"] = v2, i3._.arrows[l2 + "String"] = n3;
                } else a2 ? (y2 = i3._.arrows.startdx * f2 || 0, m2 = t2.getTotalLength(u2.path) - y2) : (y2 = 0, m2 = t2.getTotalLength(u2.path) - (i3._.arrows.enddx * f2 || 0)), i3._.arrows[l2 + "Path"] && x(h2, {
                  d: t2.getSubpath(u2.path, y2, m2)
                }), delete i3._.arrows[l2 + "Path"], delete i3._.arrows[l2 + "Marker"], delete i3._.arrows[l2 + "dx"], delete i3._.arrows[l2 + "Type"], delete i3._.arrows[l2 + "String"];
                for (w2 in g) if (g[e2](w2) && !g[w2]) {
                  var M2 = t2._g.doc.getElementById(w2);
                  M2 && M2.parentNode.removeChild(M2);
                }
              }
            }, w = {
              "-": [3, 1],
              ".": [1, 1],
              "-.": [3, 1, 1, 1],
              "-..": [3, 1, 1, 1, 1, 1],
              ". ": [1, 3],
              "- ": [4, 3],
              "--": [8, 3],
              "- .": [4, 3, 1, 3],
              "--.": [8, 3, 1, 3],
              "--..": [8, 3, 1, 3, 1, 3]
            }, k = function(t3, e3, i3) {
              if (e3 = w[r2(e3).toLowerCase()]) {
                for (var n3 = t3.attrs["stroke-width"] || "1", a2 = {
                  round: n3,
                  square: n3,
                  butt: 0
                }[t3.attrs["stroke-linecap"] || i3["stroke-linecap"]] || 0, s2 = [], o2 = e3.length; o2--; ) s2[o2] = e3[o2] * n3 + (o2 % 2 ? 1 : -1) * a2;
                x(t3.node, {
                  "stroke-dasharray": s2.join(",")
                });
              } else x(t3.node, {
                "stroke-dasharray": "none"
              });
            }, B = function(i3, a2) {
              var l2 = i3.node, u2 = i3.attrs, f2 = l2.style.visibility;
              l2.style.visibility = "hidden";
              for (var d2 in a2) if (a2[e2](d2)) {
                if (!t2._availableAttrs[e2](d2)) continue;
                var g2 = a2[d2];
                switch (u2[d2] = g2, d2) {
                  case "blur":
                    i3.blur(g2);
                    break;
                  case "title":
                    var y2 = l2.getElementsByTagName("title");
                    if (y2.length && (y2 = y2[0])) y2.firstChild.nodeValue = g2;
                    else {
                      y2 = x("title");
                      var m2 = t2._g.doc.createTextNode(g2);
                      y2.appendChild(m2), l2.appendChild(y2);
                    }
                    break;
                  case "href":
                  case "target":
                    var w2 = l2.parentNode;
                    if ("a" != w2.tagName.toLowerCase()) {
                      var B2 = x("a");
                      w2.insertBefore(B2, l2), B2.appendChild(l2), w2 = B2;
                    }
                    "target" == d2 ? w2.setAttributeNS(p, "show", "blank" == g2 ? "new" : g2) : w2.setAttributeNS(p, d2, g2);
                    break;
                  case "cursor":
                    l2.style.cursor = g2;
                    break;
                  case "transform":
                    i3.transform(g2);
                    break;
                  case "arrow-start":
                    _(i3, g2);
                    break;
                  case "arrow-end":
                    _(i3, g2, 1);
                    break;
                  case "clip-rect":
                    var C2 = r2(g2).split(h);
                    if (4 == C2.length) {
                      i3.clip && i3.clip.parentNode.parentNode.removeChild(i3.clip.parentNode);
                      var T2 = x("clipPath"), A2 = x("rect");
                      T2.id = t2.createUUID(), x(A2, {
                        x: C2[0],
                        y: C2[1],
                        width: C2[2],
                        height: C2[3]
                      }), T2.appendChild(A2), i3.paper.defs.appendChild(T2), x(l2, {
                        "clip-path": "url(#" + T2.id + ")"
                      }), i3.clip = A2;
                    }
                    if (!g2) {
                      var E2 = l2.getAttribute("clip-path");
                      if (E2) {
                        var N2 = t2._g.doc.getElementById(E2.replace(/(^url\(#|\)$)/g, c));
                        N2 && N2.parentNode.removeChild(N2), x(l2, {
                          "clip-path": c
                        }), delete i3.clip;
                      }
                    }
                    break;
                  case "path":
                    "path" == i3.type && (x(l2, {
                      d: g2 ? u2.path = t2._pathToAbsolute(g2) : "M0,0"
                    }), i3._.dirty = 1, i3._.arrows && ("startString" in i3._.arrows && _(i3, i3._.arrows.startString), "endString" in i3._.arrows && _(i3, i3._.arrows.endString, 1)));
                    break;
                  case "width":
                    if (l2.setAttribute(d2, g2), i3._.dirty = 1, !u2.fx) break;
                    d2 = "x", g2 = u2.x;
                  case "x":
                    u2.fx && (g2 = -u2.x - (u2.width || 0));
                  case "rx":
                    if ("rx" == d2 && "rect" == i3.type) break;
                  case "cx":
                    l2.setAttribute(d2, g2), i3.pattern && b(i3), i3._.dirty = 1;
                    break;
                  case "height":
                    if (l2.setAttribute(d2, g2), i3._.dirty = 1, !u2.fy) break;
                    d2 = "y", g2 = u2.y;
                  case "y":
                    u2.fy && (g2 = -u2.y - (u2.height || 0));
                  case "ry":
                    if ("ry" == d2 && "rect" == i3.type) break;
                  case "cy":
                    l2.setAttribute(d2, g2), i3.pattern && b(i3), i3._.dirty = 1;
                    break;
                  case "r":
                    "rect" == i3.type ? x(l2, {
                      rx: g2,
                      ry: g2
                    }) : l2.setAttribute(d2, g2), i3._.dirty = 1;
                    break;
                  case "src":
                    "image" == i3.type && l2.setAttributeNS(p, "href", g2);
                    break;
                  case "stroke-width":
                    1 == i3._.sx && 1 == i3._.sy || (g2 /= s(o(i3._.sx), o(i3._.sy)) || 1), l2.setAttribute(d2, g2), u2["stroke-dasharray"] && k(i3, u2["stroke-dasharray"], a2), i3._.arrows && ("startString" in i3._.arrows && _(i3, i3._.arrows.startString), "endString" in i3._.arrows && _(i3, i3._.arrows.endString, 1));
                    break;
                  case "stroke-dasharray":
                    k(i3, g2, a2);
                    break;
                  case "fill":
                    var M2 = r2(g2).match(t2._ISURL);
                    if (M2) {
                      T2 = x("pattern");
                      var L = x("image");
                      T2.id = t2.createUUID(), x(T2, {
                        x: 0,
                        y: 0,
                        patternUnits: "userSpaceOnUse",
                        height: 1,
                        width: 1
                      }), x(L, {
                        x: 0,
                        y: 0,
                        "xlink:href": M2[1]
                      }), T2.appendChild(L), function(e3) {
                        t2._preload(M2[1], function() {
                          var t3 = this.offsetWidth, r3 = this.offsetHeight;
                          x(e3, {
                            width: t3,
                            height: r3
                          }), x(L, {
                            width: t3,
                            height: r3
                          });
                        });
                      }(T2), i3.paper.defs.appendChild(T2), x(l2, {
                        fill: "url(#" + T2.id + ")"
                      }), i3.pattern = T2, i3.pattern && b(i3);
                      break;
                    }
                    var z = t2.getRGB(g2);
                    if (z.error) {
                      if (("circle" == i3.type || "ellipse" == i3.type || "r" != r2(g2).charAt()) && v(i3, g2)) {
                        if ("opacity" in u2 || "fill-opacity" in u2) {
                          var P = t2._g.doc.getElementById(l2.getAttribute("fill").replace(/^url\(#|\)$/g, c));
                          if (P) {
                            var F = P.getElementsByTagName("stop");
                            x(F[F.length - 1], {
                              "stop-opacity": ("opacity" in u2 ? u2.opacity : 1) * ("fill-opacity" in u2 ? u2["fill-opacity"] : 1)
                            });
                          }
                        }
                        u2.gradient = g2, u2.fill = "none";
                        break;
                      }
                    } else delete a2.gradient, delete u2.gradient, !t2.is(u2.opacity, "undefined") && t2.is(a2.opacity, "undefined") && x(l2, {
                      opacity: u2.opacity
                    }), !t2.is(u2["fill-opacity"], "undefined") && t2.is(a2["fill-opacity"], "undefined") && x(l2, {
                      "fill-opacity": u2["fill-opacity"]
                    });
                    z[e2]("opacity") && x(l2, {
                      "fill-opacity": z.opacity > 1 ? z.opacity / 100 : z.opacity
                    });
                  case "stroke":
                    z = t2.getRGB(g2), l2.setAttribute(d2, z.hex), "stroke" == d2 && z[e2]("opacity") && x(l2, {
                      "stroke-opacity": z.opacity > 1 ? z.opacity / 100 : z.opacity
                    }), "stroke" == d2 && i3._.arrows && ("startString" in i3._.arrows && _(i3, i3._.arrows.startString), "endString" in i3._.arrows && _(i3, i3._.arrows.endString, 1));
                    break;
                  case "gradient":
                    ("circle" == i3.type || "ellipse" == i3.type || "r" != r2(g2).charAt()) && v(i3, g2);
                    break;
                  case "opacity":
                    u2.gradient && !u2[e2]("stroke-opacity") && x(l2, {
                      "stroke-opacity": g2 > 1 ? g2 / 100 : g2
                    });
                  case "fill-opacity":
                    if (u2.gradient) {
                      P = t2._g.doc.getElementById(l2.getAttribute("fill").replace(/^url\(#|\)$/g, c)), P && (F = P.getElementsByTagName("stop"), x(F[F.length - 1], {
                        "stop-opacity": g2
                      }));
                      break;
                    }
                  default:
                    "font-size" == d2 && (g2 = n2(g2, 10) + "px");
                    var R = d2.replace(/(\-.)/g, function(t3) {
                      return t3.substring(1).toUpperCase();
                    });
                    l2.style[R] = g2, i3._.dirty = 1, l2.setAttribute(d2, g2);
                }
              }
              S(i3, a2), l2.style.visibility = f2;
            }, C = 1.2, S = function(i3, a2) {
              if ("text" == i3.type && (a2[e2]("text") || a2[e2]("font") || a2[e2]("font-size") || a2[e2]("x") || a2[e2]("y"))) {
                var s2 = i3.attrs, o2 = i3.node, l2 = o2.firstChild ? n2(t2._g.doc.defaultView.getComputedStyle(o2.firstChild, c).getPropertyValue("font-size"), 10) : 10;
                if (a2[e2]("text")) {
                  for (s2.text = a2.text; o2.firstChild; ) o2.removeChild(o2.firstChild);
                  for (var h2 = r2(a2.text).split("\n"), u2 = [], f2, p2 = 0, d2 = h2.length; p2 < d2; p2++) f2 = x("tspan"), p2 && x(f2, {
                    dy: l2 * C,
                    x: s2.x
                  }), f2.appendChild(t2._g.doc.createTextNode(h2[p2])), o2.appendChild(f2), u2[p2] = f2;
                } else for (u2 = o2.getElementsByTagName("tspan"), p2 = 0, d2 = u2.length; p2 < d2; p2++) p2 ? x(u2[p2], {
                  dy: l2 * C,
                  x: s2.x
                }) : x(u2[0], {
                  dy: 0
                });
                x(o2, {
                  x: s2.x,
                  y: s2.y
                }), i3._.dirty = 1;
                var g2 = i3._getBBox(), v2 = s2.y - (g2.y + g2.height / 2);
                g2.height && v2 && t2.is(v2, "finite") && x(u2[0], {
                  dy: v2
                });
              }
            }, T = function(t3) {
              return t3.parentNode && "a" === t3.parentNode.tagName.toLowerCase() ? t3.parentNode : t3;
            }, A = function(e3, r3) {
              var i3 = 0, n3 = 0;
              this[0] = this.node = e3, e3.raphael = true, this.id = t2._oid++, e3.raphaelid = this.id, this.matrix = t2.matrix(), this.realPath = null, this.paper = r3, this.attrs = this.attrs || {}, this._ = {
                transform: [],
                sx: 1,
                sy: 1,
                deg: 0,
                dx: 0,
                dy: 0,
                dirty: 1
              }, !r3.bottom && (r3.bottom = this), this.prev = r3.top, r3.top && (r3.top.next = this), r3.top = this, this.next = null;
            }, E = t2.el;
            A.prototype = E, E.constructor = A, t2._engine.path = function(t3, e3) {
              var r3 = x("path");
              e3.canvas && e3.canvas.appendChild(r3);
              var i3 = new A(r3, e3);
              return i3.type = "path", B(i3, {
                fill: "none",
                stroke: "#000",
                path: t3
              }), i3;
            }, E.rotate = function(t3, e3, n3) {
              if (this.removed) return this;
              if (t3 = r2(t3).split(h), t3.length - 1 && (e3 = i2(t3[1]), n3 = i2(t3[2])), t3 = i2(t3[0]), null == n3 && (e3 = n3), null == e3 || null == n3) {
                var a2 = this.getBBox(1);
                e3 = a2.x + a2.width / 2, n3 = a2.y + a2.height / 2;
              }
              return this.transform(this._.transform.concat([["r", t3, e3, n3]])), this;
            }, E.scale = function(t3, e3, n3, a2) {
              if (this.removed) return this;
              if (t3 = r2(t3).split(h), t3.length - 1 && (e3 = i2(t3[1]), n3 = i2(t3[2]), a2 = i2(t3[3])), t3 = i2(t3[0]), null == e3 && (e3 = t3), null == a2 && (n3 = a2), null == n3 || null == a2) var s2 = this.getBBox(1);
              return n3 = null == n3 ? s2.x + s2.width / 2 : n3, a2 = null == a2 ? s2.y + s2.height / 2 : a2, this.transform(this._.transform.concat([["s", t3, e3, n3, a2]])), this;
            }, E.translate = function(t3, e3) {
              return this.removed ? this : (t3 = r2(t3).split(h), t3.length - 1 && (e3 = i2(t3[1])), t3 = i2(t3[0]) || 0, e3 = +e3 || 0, this.transform(this._.transform.concat([["t", t3, e3]])), this);
            }, E.transform = function(r3) {
              var i3 = this._;
              if (null == r3) return i3.transform;
              if (t2._extractTransform(this, r3), this.clip && x(this.clip, {
                transform: this.matrix.invert()
              }), this.pattern && b(this), this.node && x(this.node, {
                transform: this.matrix
              }), 1 != i3.sx || 1 != i3.sy) {
                var n3 = this.attrs[e2]("stroke-width") ? this.attrs["stroke-width"] : 1;
                this.attr({
                  "stroke-width": n3
                });
              }
              return i3.transform = this.matrix.toTransformString(), this;
            }, E.hide = function() {
              return this.removed || (this.node.style.display = "none"), this;
            }, E.show = function() {
              return this.removed || (this.node.style.display = ""), this;
            }, E.remove = function() {
              var e3 = T(this.node);
              if (!this.removed && e3.parentNode) {
                var r3 = this.paper;
                r3.__set__ && r3.__set__.exclude(this), u.unbind("raphael.*.*." + this.id), this.gradient && r3.defs.removeChild(this.gradient), t2._tear(this, r3), e3.parentNode.removeChild(e3), this.removeData();
                for (var i3 in this) this[i3] = "function" == typeof this[i3] ? t2._removedFactory(i3) : null;
                this.removed = true;
              }
            }, E._getBBox = function() {
              if ("none" == this.node.style.display) {
                this.show();
                var t3 = true;
              }
              var e3 = false, r3;
              this.paper.canvas.parentElement ? r3 = this.paper.canvas.parentElement.style : this.paper.canvas.parentNode && (r3 = this.paper.canvas.parentNode.style), r3 && "none" == r3.display && (e3 = true, r3.display = "");
              var i3 = {};
              try {
                i3 = this.node.getBBox();
              } catch (n3) {
                i3 = {
                  x: this.node.clientLeft,
                  y: this.node.clientTop,
                  width: this.node.clientWidth,
                  height: this.node.clientHeight
                };
              } finally {
                i3 = i3 || {}, e3 && (r3.display = "none");
              }
              return t3 && this.hide(), i3;
            }, E.attr = function(r3, i3) {
              if (this.removed) return this;
              if (null == r3) {
                var n3 = {};
                for (var a2 in this.attrs) this.attrs[e2](a2) && (n3[a2] = this.attrs[a2]);
                return n3.gradient && "none" == n3.fill && (n3.fill = n3.gradient) && delete n3.gradient, n3.transform = this._.transform, n3;
              }
              if (null == i3 && t2.is(r3, "string")) {
                if ("fill" == r3 && "none" == this.attrs.fill && this.attrs.gradient) return this.attrs.gradient;
                if ("transform" == r3) return this._.transform;
                for (var s2 = r3.split(h), o2 = {}, l2 = 0, c2 = s2.length; l2 < c2; l2++) r3 = s2[l2], r3 in this.attrs ? o2[r3] = this.attrs[r3] : t2.is(this.paper.customAttributes[r3], "function") ? o2[r3] = this.paper.customAttributes[r3].def : o2[r3] = t2._availableAttrs[r3];
                return c2 - 1 ? o2 : o2[s2[0]];
              }
              if (null == i3 && t2.is(r3, "array")) {
                for (o2 = {}, l2 = 0, c2 = r3.length; l2 < c2; l2++) o2[r3[l2]] = this.attr(r3[l2]);
                return o2;
              }
              if (null != i3) {
                var f2 = {};
                f2[r3] = i3;
              } else null != r3 && t2.is(r3, "object") && (f2 = r3);
              for (var p2 in f2) u("raphael.attr." + p2 + "." + this.id, this, f2[p2]);
              for (p2 in this.paper.customAttributes) if (this.paper.customAttributes[e2](p2) && f2[e2](p2) && t2.is(this.paper.customAttributes[p2], "function")) {
                var d2 = this.paper.customAttributes[p2].apply(this, [].concat(f2[p2]));
                this.attrs[p2] = f2[p2];
                for (var g2 in d2) d2[e2](g2) && (f2[g2] = d2[g2]);
              }
              return B(this, f2), this;
            }, E.toFront = function() {
              if (this.removed) return this;
              var e3 = T(this.node);
              e3.parentNode.appendChild(e3);
              var r3 = this.paper;
              return r3.top != this && t2._tofront(this, r3), this;
            }, E.toBack = function() {
              if (this.removed) return this;
              var e3 = T(this.node), r3 = e3.parentNode;
              r3.insertBefore(e3, r3.firstChild), t2._toback(this, this.paper);
              var i3 = this.paper;
              return this;
            }, E.insertAfter = function(e3) {
              if (this.removed || !e3) return this;
              var r3 = T(this.node), i3 = T(e3.node || e3[e3.length - 1].node);
              return i3.nextSibling ? i3.parentNode.insertBefore(r3, i3.nextSibling) : i3.parentNode.appendChild(r3), t2._insertafter(this, e3, this.paper), this;
            }, E.insertBefore = function(e3) {
              if (this.removed || !e3) return this;
              var r3 = T(this.node), i3 = T(e3.node || e3[0].node);
              return i3.parentNode.insertBefore(r3, i3), t2._insertbefore(this, e3, this.paper), this;
            }, E.blur = function(e3) {
              var r3 = this;
              if (0 !== +e3) {
                var i3 = x("filter"), n3 = x("feGaussianBlur");
                r3.attrs.blur = e3, i3.id = t2.createUUID(), x(n3, {
                  stdDeviation: +e3 || 1.5
                }), i3.appendChild(n3), r3.paper.defs.appendChild(i3), r3._blur = i3, x(r3.node, {
                  filter: "url(#" + i3.id + ")"
                });
              } else r3._blur && (r3._blur.parentNode.removeChild(r3._blur), delete r3._blur, delete r3.attrs.blur), r3.node.removeAttribute("filter");
              return r3;
            }, t2._engine.circle = function(t3, e3, r3, i3) {
              var n3 = x("circle");
              t3.canvas && t3.canvas.appendChild(n3);
              var a2 = new A(n3, t3);
              return a2.attrs = {
                cx: e3,
                cy: r3,
                r: i3,
                fill: "none",
                stroke: "#000"
              }, a2.type = "circle", x(n3, a2.attrs), a2;
            }, t2._engine.rect = function(t3, e3, r3, i3, n3, a2) {
              var s2 = x("rect");
              t3.canvas && t3.canvas.appendChild(s2);
              var o2 = new A(s2, t3);
              return o2.attrs = {
                x: e3,
                y: r3,
                width: i3,
                height: n3,
                rx: a2 || 0,
                ry: a2 || 0,
                fill: "none",
                stroke: "#000"
              }, o2.type = "rect", x(s2, o2.attrs), o2;
            }, t2._engine.ellipse = function(t3, e3, r3, i3, n3) {
              var a2 = x("ellipse");
              t3.canvas && t3.canvas.appendChild(a2);
              var s2 = new A(a2, t3);
              return s2.attrs = {
                cx: e3,
                cy: r3,
                rx: i3,
                ry: n3,
                fill: "none",
                stroke: "#000"
              }, s2.type = "ellipse", x(a2, s2.attrs), s2;
            }, t2._engine.image = function(t3, e3, r3, i3, n3, a2) {
              var s2 = x("image");
              x(s2, {
                x: r3,
                y: i3,
                width: n3,
                height: a2,
                preserveAspectRatio: "none"
              }), s2.setAttributeNS(p, "href", e3), t3.canvas && t3.canvas.appendChild(s2);
              var o2 = new A(s2, t3);
              return o2.attrs = {
                x: r3,
                y: i3,
                width: n3,
                height: a2,
                src: e3
              }, o2.type = "image", o2;
            }, t2._engine.text = function(e3, r3, i3, n3) {
              var a2 = x("text");
              e3.canvas && e3.canvas.appendChild(a2);
              var s2 = new A(a2, e3);
              return s2.attrs = {
                x: r3,
                y: i3,
                "text-anchor": "middle",
                text: n3,
                "font-family": t2._availableAttrs["font-family"],
                "font-size": t2._availableAttrs["font-size"],
                stroke: "none",
                fill: "#000"
              }, s2.type = "text", B(s2, s2.attrs), s2;
            }, t2._engine.setSize = function(t3, e3) {
              return this.width = t3 || this.width, this.height = e3 || this.height, this.canvas.setAttribute("width", this.width), this.canvas.setAttribute("height", this.height), this._viewBox && this.setViewBox.apply(this, this._viewBox), this;
            }, t2._engine.create = function() {
              var e3 = t2._getContainer.apply(0, arguments), r3 = e3 && e3.container, i3 = e3.x, n3 = e3.y, a2 = e3.width, s2 = e3.height;
              if (!r3) throw new Error("SVG container not found.");
              var o2 = x("svg"), l2 = "overflow:hidden;", h2;
              return i3 = i3 || 0, n3 = n3 || 0, a2 = a2 || 512, s2 = s2 || 342, x(o2, {
                height: s2,
                version: 1.1,
                width: a2,
                xmlns: "http://www.w3.org/2000/svg",
                "xmlns:xlink": "http://www.w3.org/1999/xlink"
              }), 1 == r3 ? (o2.style.cssText = l2 + "position:absolute;left:" + i3 + "px;top:" + n3 + "px", t2._g.doc.body.appendChild(o2), h2 = 1) : (o2.style.cssText = l2 + "position:relative", r3.firstChild ? r3.insertBefore(o2, r3.firstChild) : r3.appendChild(o2)), r3 = new t2._Paper(), r3.width = a2, r3.height = s2, r3.canvas = o2, r3.clear(), r3._left = r3._top = 0, h2 && (r3.renderfix = function() {
              }), r3.renderfix(), r3;
            }, t2._engine.setViewBox = function(t3, e3, r3, i3, n3) {
              u("raphael.setViewBox", this, this._viewBox, [t3, e3, r3, i3, n3]);
              var a2 = this.getSize(), o2 = s(r3 / a2.width, i3 / a2.height), l2 = this.top, h2 = n3 ? "xMidYMid meet" : "xMinYMin", c2, p2;
              for (null == t3 ? (this._vbSize && (o2 = 1), delete this._vbSize, c2 = "0 0 " + this.width + f + this.height) : (this._vbSize = o2, c2 = t3 + f + e3 + f + r3 + f + i3), x(this.canvas, {
                viewBox: c2,
                preserveAspectRatio: h2
              }); o2 && l2; ) p2 = "stroke-width" in l2.attrs ? l2.attrs["stroke-width"] : 1, l2.attr({
                "stroke-width": p2
              }), l2._.dirty = 1, l2._.dirtyT = 1, l2 = l2.prev;
              return this._viewBox = [t3, e3, r3, i3, !!n3], this;
            }, t2.prototype.renderfix = function() {
              var t3 = this.canvas, e3 = t3.style, r3;
              try {
                r3 = t3.getScreenCTM() || t3.createSVGMatrix();
              } catch (i3) {
                r3 = t3.createSVGMatrix();
              }
              var n3 = -r3.e % 1, a2 = -r3.f % 1;
              (n3 || a2) && (n3 && (this._left = (this._left + n3) % 1, e3.left = this._left + "px"), a2 && (this._top = (this._top + a2) % 1, e3.top = this._top + "px"));
            }, t2.prototype.clear = function() {
              t2.eve("raphael.clear", this);
              for (var e3 = this.canvas; e3.firstChild; ) e3.removeChild(e3.firstChild);
              this.bottom = this.top = null, (this.desc = x("desc")).appendChild(t2._g.doc.createTextNode("Created with Raphaël " + t2.version)), e3.appendChild(this.desc), e3.appendChild(this.defs = x("defs"));
            }, t2.prototype.remove = function() {
              u("raphael.remove", this), this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
              for (var e3 in this) this[e3] = "function" == typeof this[e3] ? t2._removedFactory(e3) : null;
            };
            var N = t2.st;
            for (var M in E) E[e2](M) && !N[e2](M) && (N[M] = /* @__PURE__ */ function(t3) {
              return function() {
                var e3 = arguments;
                return this.forEach(function(r3) {
                  r3[t3].apply(r3, e3);
                });
              };
            }(M));
          }
        }.apply(e, i), !(void 0 !== n && (t.exports = n));
      }, function(t, e, r) {
        var i, n;
        i = [r(1)], n = function(t2) {
          if (!t2 || t2.vml) {
            var e2 = "hasOwnProperty", r2 = String, i2 = parseFloat, n2 = Math, a = n2.round, s = n2.max, o = n2.min, l = n2.abs, h = "fill", u = /[, ]+/, c = t2.eve, f = " progid:DXImageTransform.Microsoft", p = " ", d = "", g = {
              M: "m",
              L: "l",
              C: "c",
              Z: "x",
              m: "t",
              l: "r",
              c: "v",
              z: "x"
            }, x = /([clmz]),?([^clmz]*)/gi, v = / progid:\S+Blur\([^\)]+\)/g, y = /-?[^,\s-]+/g, m = "position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)", b = 21600, _ = {
              path: 1,
              rect: 1,
              image: 1
            }, w = {
              circle: 1,
              ellipse: 1
            }, k = function(e3) {
              var i3 = /[ahqstv]/gi, n3 = t2._pathToAbsolute;
              if (r2(e3).match(i3) && (n3 = t2._path2curve), i3 = /[clmz]/g, n3 == t2._pathToAbsolute && !r2(e3).match(i3)) {
                var s2 = r2(e3).replace(x, function(t3, e4, r3) {
                  var i4 = [], n4 = "m" == e4.toLowerCase(), s3 = g[e4];
                  return r3.replace(y, function(t4) {
                    n4 && 2 == i4.length && (s3 += i4 + g["m" == e4 ? "l" : "L"], i4 = []), i4.push(a(t4 * b));
                  }), s3 + i4;
                });
                return s2;
              }
              var o2 = n3(e3), l2, h2;
              s2 = [];
              for (var u2 = 0, c2 = o2.length; u2 < c2; u2++) {
                l2 = o2[u2], h2 = o2[u2][0].toLowerCase(), "z" == h2 && (h2 = "x");
                for (var f2 = 1, v2 = l2.length; f2 < v2; f2++) h2 += a(l2[f2] * b) + (f2 != v2 - 1 ? "," : d);
                s2.push(h2);
              }
              return s2.join(p);
            }, B = function(e3, r3, i3) {
              var n3 = t2.matrix();
              return n3.rotate(-e3, 0.5, 0.5), {
                dx: n3.x(r3, i3),
                dy: n3.y(r3, i3)
              };
            }, C = function(t3, e3, r3, i3, n3, a2) {
              var s2 = t3._, o2 = t3.matrix, u2 = s2.fillpos, c2 = t3.node, f2 = c2.style, d2 = 1, g2 = "", x2, v2 = b / e3, y2 = b / r3;
              if (f2.visibility = "hidden", e3 && r3) {
                if (c2.coordsize = l(v2) + p + l(y2), f2.rotation = a2 * (e3 * r3 < 0 ? -1 : 1), a2) {
                  var m2 = B(a2, i3, n3);
                  i3 = m2.dx, n3 = m2.dy;
                }
                if (e3 < 0 && (g2 += "x"), r3 < 0 && (g2 += " y") && (d2 = -1), f2.flip = g2, c2.coordorigin = i3 * -v2 + p + n3 * -y2, u2 || s2.fillsize) {
                  var _2 = c2.getElementsByTagName(h);
                  _2 = _2 && _2[0], c2.removeChild(_2), u2 && (m2 = B(a2, o2.x(u2[0], u2[1]), o2.y(u2[0], u2[1])), _2.position = m2.dx * d2 + p + m2.dy * d2), s2.fillsize && (_2.size = s2.fillsize[0] * l(e3) + p + s2.fillsize[1] * l(r3)), c2.appendChild(_2);
                }
                f2.visibility = "visible";
              }
            };
            t2.toString = function() {
              return "Your browser doesn’t support SVG. Falling down to VML.\nYou are running Raphaël " + this.version;
            };
            var S = function(t3, e3, i3) {
              for (var n3 = r2(e3).toLowerCase().split("-"), a2 = i3 ? "end" : "start", s2 = n3.length, o2 = "classic", l2 = "medium", h2 = "medium"; s2--; ) switch (n3[s2]) {
                case "block":
                case "classic":
                case "oval":
                case "diamond":
                case "open":
                case "none":
                  o2 = n3[s2];
                  break;
                case "wide":
                case "narrow":
                  h2 = n3[s2];
                  break;
                case "long":
                case "short":
                  l2 = n3[s2];
              }
              var u2 = t3.node.getElementsByTagName("stroke")[0];
              u2[a2 + "arrow"] = o2, u2[a2 + "arrowlength"] = l2, u2[a2 + "arrowwidth"] = h2;
            }, T = function(n3, l2) {
              n3.attrs = n3.attrs || {};
              var c2 = n3.node, f2 = n3.attrs, g2 = c2.style, x2, v2 = _[n3.type] && (l2.x != f2.x || l2.y != f2.y || l2.width != f2.width || l2.height != f2.height || l2.cx != f2.cx || l2.cy != f2.cy || l2.rx != f2.rx || l2.ry != f2.ry || l2.r != f2.r), y2 = w[n3.type] && (f2.cx != l2.cx || f2.cy != l2.cy || f2.r != l2.r || f2.rx != l2.rx || f2.ry != l2.ry), m2 = n3;
              for (var B2 in l2) l2[e2](B2) && (f2[B2] = l2[B2]);
              if (v2 && (f2.path = t2._getPath[n3.type](n3), n3._.dirty = 1), l2.href && (c2.href = l2.href), l2.title && (c2.title = l2.title), l2.target && (c2.target = l2.target), l2.cursor && (g2.cursor = l2.cursor), "blur" in l2 && n3.blur(l2.blur), (l2.path && "path" == n3.type || v2) && (c2.path = k(~r2(f2.path).toLowerCase().indexOf("r") ? t2._pathToAbsolute(f2.path) : f2.path), n3._.dirty = 1, "image" == n3.type && (n3._.fillpos = [f2.x, f2.y], n3._.fillsize = [f2.width, f2.height], C(n3, 1, 1, 0, 0, 0))), "transform" in l2 && n3.transform(l2.transform), y2) {
                var T2 = +f2.cx, E2 = +f2.cy, N2 = +f2.rx || +f2.r || 0, L2 = +f2.ry || +f2.r || 0;
                c2.path = t2.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", a((T2 - N2) * b), a((E2 - L2) * b), a((T2 + N2) * b), a((E2 + L2) * b), a(T2 * b)), n3._.dirty = 1;
              }
              if ("clip-rect" in l2) {
                var z2 = r2(l2["clip-rect"]).split(u);
                if (4 == z2.length) {
                  z2[2] = +z2[2] + +z2[0], z2[3] = +z2[3] + +z2[1];
                  var P = c2.clipRect || t2._g.doc.createElement("div"), F = P.style;
                  F.clip = t2.format("rect({1}px {2}px {3}px {0}px)", z2), c2.clipRect || (F.position = "absolute", F.top = 0, F.left = 0, F.width = n3.paper.width + "px", F.height = n3.paper.height + "px", c2.parentNode.insertBefore(P, c2), P.appendChild(c2), c2.clipRect = P);
                }
                l2["clip-rect"] || c2.clipRect && (c2.clipRect.style.clip = "auto");
              }
              if (n3.textpath) {
                var R = n3.textpath.style;
                l2.font && (R.font = l2.font), l2["font-family"] && (R.fontFamily = '"' + l2["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, d) + '"'), l2["font-size"] && (R.fontSize = l2["font-size"]), l2["font-weight"] && (R.fontWeight = l2["font-weight"]), l2["font-style"] && (R.fontStyle = l2["font-style"]);
              }
              if ("arrow-start" in l2 && S(m2, l2["arrow-start"]), "arrow-end" in l2 && S(m2, l2["arrow-end"], 1), null != l2.opacity || null != l2["stroke-width"] || null != l2.fill || null != l2.src || null != l2.stroke || null != l2["stroke-width"] || null != l2["stroke-opacity"] || null != l2["fill-opacity"] || null != l2["stroke-dasharray"] || null != l2["stroke-miterlimit"] || null != l2["stroke-linejoin"] || null != l2["stroke-linecap"]) {
                var I = c2.getElementsByTagName(h), j = false;
                if (I = I && I[0], !I && (j = I = M(h)), "image" == n3.type && l2.src && (I.src = l2.src), l2.fill && (I.on = true), null != I.on && "none" != l2.fill && null !== l2.fill || (I.on = false), I.on && l2.fill) {
                  var q = r2(l2.fill).match(t2._ISURL);
                  if (q) {
                    I.parentNode == c2 && c2.removeChild(I), I.rotate = true, I.src = q[1], I.type = "tile";
                    var D = n3.getBBox(1);
                    I.position = D.x + p + D.y, n3._.fillpos = [D.x, D.y], t2._preload(q[1], function() {
                      n3._.fillsize = [this.offsetWidth, this.offsetHeight];
                    });
                  } else I.color = t2.getRGB(l2.fill).hex, I.src = d, I.type = "solid", t2.getRGB(l2.fill).error && (m2.type in {
                    circle: 1,
                    ellipse: 1
                  } || "r" != r2(l2.fill).charAt()) && A(m2, l2.fill, I) && (f2.fill = "none", f2.gradient = l2.fill, I.rotate = false);
                }
                if ("fill-opacity" in l2 || "opacity" in l2) {
                  var V = ((+f2["fill-opacity"] + 1 || 2) - 1) * ((+f2.opacity + 1 || 2) - 1) * ((+t2.getRGB(l2.fill).o + 1 || 2) - 1);
                  V = o(s(V, 0), 1), I.opacity = V, I.src && (I.color = "none");
                }
                c2.appendChild(I);
                var O = c2.getElementsByTagName("stroke") && c2.getElementsByTagName("stroke")[0], Y = false;
                !O && (Y = O = M("stroke")), (l2.stroke && "none" != l2.stroke || l2["stroke-width"] || null != l2["stroke-opacity"] || l2["stroke-dasharray"] || l2["stroke-miterlimit"] || l2["stroke-linejoin"] || l2["stroke-linecap"]) && (O.on = true), ("none" == l2.stroke || null === l2.stroke || null == O.on || 0 == l2.stroke || 0 == l2["stroke-width"]) && (O.on = false);
                var W = t2.getRGB(l2.stroke);
                O.on && l2.stroke && (O.color = W.hex), V = ((+f2["stroke-opacity"] + 1 || 2) - 1) * ((+f2.opacity + 1 || 2) - 1) * ((+W.o + 1 || 2) - 1);
                var G = 0.75 * (i2(l2["stroke-width"]) || 1);
                if (V = o(s(V, 0), 1), null == l2["stroke-width"] && (G = f2["stroke-width"]), l2["stroke-width"] && (O.weight = G), G && G < 1 && (V *= G) && (O.weight = 1), O.opacity = V, l2["stroke-linejoin"] && (O.joinstyle = l2["stroke-linejoin"] || "miter"), O.miterlimit = l2["stroke-miterlimit"] || 8, l2["stroke-linecap"] && (O.endcap = "butt" == l2["stroke-linecap"] ? "flat" : "square" == l2["stroke-linecap"] ? "square" : "round"), "stroke-dasharray" in l2) {
                  var H = {
                    "-": "shortdash",
                    ".": "shortdot",
                    "-.": "shortdashdot",
                    "-..": "shortdashdotdot",
                    ". ": "dot",
                    "- ": "dash",
                    "--": "longdash",
                    "- .": "dashdot",
                    "--.": "longdashdot",
                    "--..": "longdashdotdot"
                  };
                  O.dashstyle = H[e2](l2["stroke-dasharray"]) ? H[l2["stroke-dasharray"]] : d;
                }
                Y && c2.appendChild(O);
              }
              if ("text" == m2.type) {
                m2.paper.canvas.style.display = d;
                var X = m2.paper.span, U = 100, $ = f2.font && f2.font.match(/\d+(?:\.\d*)?(?=px)/);
                g2 = X.style, f2.font && (g2.font = f2.font), f2["font-family"] && (g2.fontFamily = f2["font-family"]), f2["font-weight"] && (g2.fontWeight = f2["font-weight"]), f2["font-style"] && (g2.fontStyle = f2["font-style"]), $ = i2(f2["font-size"] || $ && $[0]) || 10, g2.fontSize = $ * U + "px", m2.textpath.string && (X.innerHTML = r2(m2.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>"));
                var Z = X.getBoundingClientRect();
                m2.W = f2.w = (Z.right - Z.left) / U, m2.H = f2.h = (Z.bottom - Z.top) / U, m2.X = f2.x, m2.Y = f2.y + m2.H / 2, ("x" in l2 || "y" in l2) && (m2.path.v = t2.format("m{0},{1}l{2},{1}", a(f2.x * b), a(f2.y * b), a(f2.x * b) + 1));
                for (var Q = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size"], J = 0, K = Q.length; J < K; J++) if (Q[J] in l2) {
                  m2._.dirty = 1;
                  break;
                }
                switch (f2["text-anchor"]) {
                  case "start":
                    m2.textpath.style["v-text-align"] = "left", m2.bbx = m2.W / 2;
                    break;
                  case "end":
                    m2.textpath.style["v-text-align"] = "right", m2.bbx = -m2.W / 2;
                    break;
                  default:
                    m2.textpath.style["v-text-align"] = "center", m2.bbx = 0;
                }
                m2.textpath.style["v-text-kern"] = true;
              }
            }, A = function(e3, a2, s2) {
              e3.attrs = e3.attrs || {};
              var o2 = e3.attrs, l2 = Math.pow, h2, u2, c2 = "linear", f2 = ".5 .5";
              if (e3.attrs.gradient = a2, a2 = r2(a2).replace(t2._radial_gradient, function(t3, e4, r3) {
                return c2 = "radial", e4 && r3 && (e4 = i2(e4), r3 = i2(r3), l2(e4 - 0.5, 2) + l2(r3 - 0.5, 2) > 0.25 && (r3 = n2.sqrt(0.25 - l2(e4 - 0.5, 2)) * (2 * (r3 > 0.5) - 1) + 0.5), f2 = e4 + p + r3), d;
              }), a2 = a2.split(/\s*\-\s*/), "linear" == c2) {
                var g2 = a2.shift();
                if (g2 = -i2(g2), isNaN(g2)) return null;
              }
              var x2 = t2._parseDots(a2);
              if (!x2) return null;
              if (e3 = e3.shape || e3.node, x2.length) {
                e3.removeChild(s2), s2.on = true, s2.method = "none", s2.color = x2[0].color, s2.color2 = x2[x2.length - 1].color;
                for (var v2 = [], y2 = 0, m2 = x2.length; y2 < m2; y2++) x2[y2].offset && v2.push(x2[y2].offset + p + x2[y2].color);
                s2.colors = v2.length ? v2.join() : "0% " + s2.color, "radial" == c2 ? (s2.type = "gradientTitle", s2.focus = "100%", s2.focussize = "0 0", s2.focusposition = f2, s2.angle = 0) : (s2.type = "gradient", s2.angle = (270 - g2) % 360), e3.appendChild(s2);
              }
              return 1;
            }, E = function(e3, r3) {
              this[0] = this.node = e3, e3.raphael = true, this.id = t2._oid++, e3.raphaelid = this.id, this.X = 0, this.Y = 0, this.attrs = {}, this.paper = r3, this.matrix = t2.matrix(), this._ = {
                transform: [],
                sx: 1,
                sy: 1,
                dx: 0,
                dy: 0,
                deg: 0,
                dirty: 1,
                dirtyT: 1
              }, !r3.bottom && (r3.bottom = this), this.prev = r3.top, r3.top && (r3.top.next = this), r3.top = this, this.next = null;
            }, N = t2.el;
            E.prototype = N, N.constructor = E, N.transform = function(e3) {
              if (null == e3) return this._.transform;
              var i3 = this.paper._viewBoxShift, n3 = i3 ? "s" + [i3.scale, i3.scale] + "-1-1t" + [i3.dx, i3.dy] : d, a2;
              i3 && (a2 = e3 = r2(e3).replace(/\.{3}|\u2026/g, this._.transform || d)), t2._extractTransform(this, n3 + e3);
              var s2 = this.matrix.clone(), o2 = this.skew, l2 = this.node, h2, u2 = ~r2(this.attrs.fill).indexOf("-"), c2 = !r2(this.attrs.fill).indexOf("url(");
              if (s2.translate(1, 1), c2 || u2 || "image" == this.type) {
                if (o2.matrix = "1 0 0 1", o2.offset = "0 0", h2 = s2.split(), u2 && h2.noRotation || !h2.isSimple) {
                  l2.style.filter = s2.toFilter();
                  var f2 = this.getBBox(), g2 = this.getBBox(1), x2 = f2.x - g2.x, v2 = f2.y - g2.y;
                  l2.coordorigin = x2 * -b + p + v2 * -b, C(this, 1, 1, x2, v2, 0);
                } else l2.style.filter = d, C(this, h2.scalex, h2.scaley, h2.dx, h2.dy, h2.rotate);
              } else l2.style.filter = d, o2.matrix = r2(s2), o2.offset = s2.offset();
              return null !== a2 && (this._.transform = a2, t2._extractTransform(this, a2)), this;
            }, N.rotate = function(t3, e3, n3) {
              if (this.removed) return this;
              if (null != t3) {
                if (t3 = r2(t3).split(u), t3.length - 1 && (e3 = i2(t3[1]), n3 = i2(t3[2])), t3 = i2(t3[0]), null == n3 && (e3 = n3), null == e3 || null == n3) {
                  var a2 = this.getBBox(1);
                  e3 = a2.x + a2.width / 2, n3 = a2.y + a2.height / 2;
                }
                return this._.dirtyT = 1, this.transform(this._.transform.concat([["r", t3, e3, n3]])), this;
              }
            }, N.translate = function(t3, e3) {
              return this.removed ? this : (t3 = r2(t3).split(u), t3.length - 1 && (e3 = i2(t3[1])), t3 = i2(t3[0]) || 0, e3 = +e3 || 0, this._.bbox && (this._.bbox.x += t3, this._.bbox.y += e3), this.transform(this._.transform.concat([["t", t3, e3]])), this);
            }, N.scale = function(t3, e3, n3, a2) {
              if (this.removed) return this;
              if (t3 = r2(t3).split(u), t3.length - 1 && (e3 = i2(t3[1]), n3 = i2(t3[2]), a2 = i2(t3[3]), isNaN(n3) && (n3 = null), isNaN(a2) && (a2 = null)), t3 = i2(t3[0]), null == e3 && (e3 = t3), null == a2 && (n3 = a2), null == n3 || null == a2) var s2 = this.getBBox(1);
              return n3 = null == n3 ? s2.x + s2.width / 2 : n3, a2 = null == a2 ? s2.y + s2.height / 2 : a2, this.transform(this._.transform.concat([["s", t3, e3, n3, a2]])), this._.dirtyT = 1, this;
            }, N.hide = function() {
              return !this.removed && (this.node.style.display = "none"), this;
            }, N.show = function() {
              return !this.removed && (this.node.style.display = d), this;
            }, N.auxGetBBox = t2.el.getBBox, N.getBBox = function() {
              var t3 = this.auxGetBBox();
              if (this.paper && this.paper._viewBoxShift) {
                var e3 = {}, r3 = 1 / this.paper._viewBoxShift.scale;
                return e3.x = t3.x - this.paper._viewBoxShift.dx, e3.x *= r3, e3.y = t3.y - this.paper._viewBoxShift.dy, e3.y *= r3, e3.width = t3.width * r3, e3.height = t3.height * r3, e3.x2 = e3.x + e3.width, e3.y2 = e3.y + e3.height, e3;
              }
              return t3;
            }, N._getBBox = function() {
              return this.removed ? {} : {
                x: this.X + (this.bbx || 0) - this.W / 2,
                y: this.Y - this.H,
                width: this.W,
                height: this.H
              };
            }, N.remove = function() {
              if (!this.removed && this.node.parentNode) {
                this.paper.__set__ && this.paper.__set__.exclude(this), t2.eve.unbind("raphael.*.*." + this.id), t2._tear(this, this.paper), this.node.parentNode.removeChild(this.node), this.shape && this.shape.parentNode.removeChild(this.shape);
                for (var e3 in this) this[e3] = "function" == typeof this[e3] ? t2._removedFactory(e3) : null;
                this.removed = true;
              }
            }, N.attr = function(r3, i3) {
              if (this.removed) return this;
              if (null == r3) {
                var n3 = {};
                for (var a2 in this.attrs) this.attrs[e2](a2) && (n3[a2] = this.attrs[a2]);
                return n3.gradient && "none" == n3.fill && (n3.fill = n3.gradient) && delete n3.gradient, n3.transform = this._.transform, n3;
              }
              if (null == i3 && t2.is(r3, "string")) {
                if (r3 == h && "none" == this.attrs.fill && this.attrs.gradient) return this.attrs.gradient;
                for (var s2 = r3.split(u), o2 = {}, l2 = 0, f2 = s2.length; l2 < f2; l2++) r3 = s2[l2], r3 in this.attrs ? o2[r3] = this.attrs[r3] : t2.is(this.paper.customAttributes[r3], "function") ? o2[r3] = this.paper.customAttributes[r3].def : o2[r3] = t2._availableAttrs[r3];
                return f2 - 1 ? o2 : o2[s2[0]];
              }
              if (this.attrs && null == i3 && t2.is(r3, "array")) {
                for (o2 = {}, l2 = 0, f2 = r3.length; l2 < f2; l2++) o2[r3[l2]] = this.attr(r3[l2]);
                return o2;
              }
              var p2;
              null != i3 && (p2 = {}, p2[r3] = i3), null == i3 && t2.is(r3, "object") && (p2 = r3);
              for (var d2 in p2) c("raphael.attr." + d2 + "." + this.id, this, p2[d2]);
              if (p2) {
                for (d2 in this.paper.customAttributes) if (this.paper.customAttributes[e2](d2) && p2[e2](d2) && t2.is(this.paper.customAttributes[d2], "function")) {
                  var g2 = this.paper.customAttributes[d2].apply(this, [].concat(p2[d2]));
                  this.attrs[d2] = p2[d2];
                  for (var x2 in g2) g2[e2](x2) && (p2[x2] = g2[x2]);
                }
                p2.text && "text" == this.type && (this.textpath.string = p2.text), T(this, p2);
              }
              return this;
            }, N.toFront = function() {
              return !this.removed && this.node.parentNode.appendChild(this.node), this.paper && this.paper.top != this && t2._tofront(this, this.paper), this;
            }, N.toBack = function() {
              return this.removed ? this : (this.node.parentNode.firstChild != this.node && (this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild), t2._toback(this, this.paper)), this);
            }, N.insertAfter = function(e3) {
              return this.removed ? this : (e3.constructor == t2.st.constructor && (e3 = e3[e3.length - 1]), e3.node.nextSibling ? e3.node.parentNode.insertBefore(this.node, e3.node.nextSibling) : e3.node.parentNode.appendChild(this.node), t2._insertafter(this, e3, this.paper), this);
            }, N.insertBefore = function(e3) {
              return this.removed ? this : (e3.constructor == t2.st.constructor && (e3 = e3[0]), e3.node.parentNode.insertBefore(this.node, e3.node), t2._insertbefore(this, e3, this.paper), this);
            }, N.blur = function(e3) {
              var r3 = this.node.runtimeStyle, i3 = r3.filter;
              return i3 = i3.replace(v, d), 0 !== +e3 ? (this.attrs.blur = e3, r3.filter = i3 + p + f + ".Blur(pixelradius=" + (+e3 || 1.5) + ")", r3.margin = t2.format("-{0}px 0 0 -{0}px", a(+e3 || 1.5))) : (r3.filter = i3, r3.margin = 0, delete this.attrs.blur), this;
            }, t2._engine.path = function(t3, e3) {
              var r3 = M("shape");
              r3.style.cssText = m, r3.coordsize = b + p + b, r3.coordorigin = e3.coordorigin;
              var i3 = new E(r3, e3), n3 = {
                fill: "none",
                stroke: "#000"
              };
              t3 && (n3.path = t3), i3.type = "path", i3.path = [], i3.Path = d, T(i3, n3), e3.canvas && e3.canvas.appendChild(r3);
              var a2 = M("skew");
              return a2.on = true, r3.appendChild(a2), i3.skew = a2, i3.transform(d), i3;
            }, t2._engine.rect = function(e3, r3, i3, n3, a2, s2) {
              var o2 = t2._rectPath(r3, i3, n3, a2, s2), l2 = e3.path(o2), h2 = l2.attrs;
              return l2.X = h2.x = r3, l2.Y = h2.y = i3, l2.W = h2.width = n3, l2.H = h2.height = a2, h2.r = s2, h2.path = o2, l2.type = "rect", l2;
            }, t2._engine.ellipse = function(t3, e3, r3, i3, n3) {
              var a2 = t3.path(), s2 = a2.attrs;
              return a2.X = e3 - i3, a2.Y = r3 - n3, a2.W = 2 * i3, a2.H = 2 * n3, a2.type = "ellipse", T(a2, {
                cx: e3,
                cy: r3,
                rx: i3,
                ry: n3
              }), a2;
            }, t2._engine.circle = function(t3, e3, r3, i3) {
              var n3 = t3.path(), a2 = n3.attrs;
              return n3.X = e3 - i3, n3.Y = r3 - i3, n3.W = n3.H = 2 * i3, n3.type = "circle", T(n3, {
                cx: e3,
                cy: r3,
                r: i3
              }), n3;
            }, t2._engine.image = function(e3, r3, i3, n3, a2, s2) {
              var o2 = t2._rectPath(i3, n3, a2, s2), l2 = e3.path(o2).attr({
                stroke: "none"
              }), u2 = l2.attrs, c2 = l2.node, f2 = c2.getElementsByTagName(h)[0];
              return u2.src = r3, l2.X = u2.x = i3, l2.Y = u2.y = n3, l2.W = u2.width = a2, l2.H = u2.height = s2, u2.path = o2, l2.type = "image", f2.parentNode == c2 && c2.removeChild(f2), f2.rotate = true, f2.src = r3, f2.type = "tile", l2._.fillpos = [i3, n3], l2._.fillsize = [a2, s2], c2.appendChild(f2), C(l2, 1, 1, 0, 0, 0), l2;
            }, t2._engine.text = function(e3, i3, n3, s2) {
              var o2 = M("shape"), l2 = M("path"), h2 = M("textpath");
              i3 = i3 || 0, n3 = n3 || 0, s2 = s2 || "", l2.v = t2.format("m{0},{1}l{2},{1}", a(i3 * b), a(n3 * b), a(i3 * b) + 1), l2.textpathok = true, h2.string = r2(s2), h2.on = true, o2.style.cssText = m, o2.coordsize = b + p + b, o2.coordorigin = "0 0";
              var u2 = new E(o2, e3), c2 = {
                fill: "#000",
                stroke: "none",
                font: t2._availableAttrs.font,
                text: s2
              };
              u2.shape = o2, u2.path = l2, u2.textpath = h2, u2.type = "text", u2.attrs.text = r2(s2), u2.attrs.x = i3, u2.attrs.y = n3, u2.attrs.w = 1, u2.attrs.h = 1, T(u2, c2), o2.appendChild(h2), o2.appendChild(l2), e3.canvas.appendChild(o2);
              var f2 = M("skew");
              return f2.on = true, o2.appendChild(f2), u2.skew = f2, u2.transform(d), u2;
            }, t2._engine.setSize = function(e3, r3) {
              var i3 = this.canvas.style;
              return this.width = e3, this.height = r3, e3 == +e3 && (e3 += "px"), r3 == +r3 && (r3 += "px"), i3.width = e3, i3.height = r3, i3.clip = "rect(0 " + e3 + " " + r3 + " 0)", this._viewBox && t2._engine.setViewBox.apply(this, this._viewBox), this;
            }, t2._engine.setViewBox = function(e3, r3, i3, n3, a2) {
              t2.eve("raphael.setViewBox", this, this._viewBox, [e3, r3, i3, n3, a2]);
              var s2 = this.getSize(), o2 = s2.width, l2 = s2.height, h2, u2;
              return a2 && (h2 = l2 / n3, u2 = o2 / i3, i3 * h2 < o2 && (e3 -= (o2 - i3 * h2) / 2 / h2), n3 * u2 < l2 && (r3 -= (l2 - n3 * u2) / 2 / u2)), this._viewBox = [e3, r3, i3, n3, !!a2], this._viewBoxShift = {
                dx: -e3,
                dy: -r3,
                scale: s2
              }, this.forEach(function(t3) {
                t3.transform("...");
              }), this;
            };
            var M;
            t2._engine.initWin = function(t3) {
              var e3 = t3.document;
              e3.styleSheets.length < 31 ? e3.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)") : e3.styleSheets[0].addRule(".rvml", "behavior:url(#default#VML)");
              try {
                !e3.namespaces.rvml && e3.namespaces.add("rvml", "urn:schemas-microsoft-com:vml"), M = function(t4) {
                  return e3.createElement("<rvml:" + t4 + ' class="rvml">');
                };
              } catch (r3) {
                M = function(t4) {
                  return e3.createElement("<" + t4 + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
                };
              }
            }, t2._engine.initWin(t2._g.win), t2._engine.create = function() {
              var e3 = t2._getContainer.apply(0, arguments), r3 = e3.container, i3 = e3.height, n3, a2 = e3.width, s2 = e3.x, o2 = e3.y;
              if (!r3) throw new Error("VML container not found.");
              var l2 = new t2._Paper(), h2 = l2.canvas = t2._g.doc.createElement("div"), u2 = h2.style;
              return s2 = s2 || 0, o2 = o2 || 0, a2 = a2 || 512, i3 = i3 || 342, l2.width = a2, l2.height = i3, a2 == +a2 && (a2 += "px"), i3 == +i3 && (i3 += "px"), l2.coordsize = 1e3 * b + p + 1e3 * b, l2.coordorigin = "0 0", l2.span = t2._g.doc.createElement("span"), l2.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;", h2.appendChild(l2.span), u2.cssText = t2.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", a2, i3), 1 == r3 ? (t2._g.doc.body.appendChild(h2), u2.left = s2 + "px", u2.top = o2 + "px", u2.position = "absolute") : r3.firstChild ? r3.insertBefore(h2, r3.firstChild) : r3.appendChild(h2), l2.renderfix = function() {
              }, l2;
            }, t2.prototype.clear = function() {
              t2.eve("raphael.clear", this), this.canvas.innerHTML = d, this.span = t2._g.doc.createElement("span"), this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;", this.canvas.appendChild(this.span), this.bottom = this.top = null;
            }, t2.prototype.remove = function() {
              t2.eve("raphael.remove", this), this.canvas.parentNode.removeChild(this.canvas);
              for (var e3 in this) this[e3] = "function" == typeof this[e3] ? t2._removedFactory(e3) : null;
              return true;
            };
            var L = t2.st;
            for (var z in N) N[e2](z) && !L[e2](z) && (L[z] = /* @__PURE__ */ function(t3) {
              return function() {
                var e3 = arguments;
                return this.forEach(function(r3) {
                  r3[t3].apply(r3, e3);
                });
              };
            }(z));
          }
        }.apply(e, i), !(void 0 !== n && (t.exports = n));
      }]);
    });
  }
});

// node_modules/tui-chart/dist/tui-chart.js
var require_tui_chart = __commonJS({
  "node_modules/tui-chart/dist/tui-chart.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object") module.exports = factory(require_raphael_min());
      else if (typeof define === "function" && define.amd) define(["raphael"], factory);
      else if (typeof exports === "object") exports["chart"] = factory(require_raphael_min());
      else root["tui"] = root["tui"] || {}, root["tui"]["chart"] = factory(root["Raphael"]);
    })(exports, function(__WEBPACK_EXTERNAL_MODULE_4__) {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module2 = installedModules[moduleId] = {
              /******/
              exports: {},
              /******/
              id: moduleId,
              /******/
              loaded: false
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.loaded = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.p = "/dist/";
          return __webpack_require__(0);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = __webpack_require__(2);
          },
          ,
          /* 2 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _pluginRaphael = __webpack_require__(3);
            var _chart = __webpack_require__(48);
            var _chart2 = _interopRequireDefault(_chart);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            var _colorutil = __webpack_require__(167);
            var _colorutil2 = _interopRequireDefault(_colorutil);
            __webpack_require__(176);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            _chart2["default"].registerPlugin("Raphael", _pluginRaphael.pluginRaphael, _pluginRaphael.callback);
            _chart2["default"].renderUtil = _renderUtil2["default"];
            _chart2["default"].arrayUtil = _arrayUtil2["default"];
            _chart2["default"].colorutil = _colorutil2["default"];
            module2.exports = _chart2["default"];
          },
          /* 3 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2.callback = exports2.pluginRaphael = void 0;
            var _raphael = __webpack_require__(4);
            var _raphael2 = _interopRequireDefault(_raphael);
            var _raphaelBarChart = __webpack_require__(5);
            var _raphaelBarChart2 = _interopRequireDefault(_raphaelBarChart);
            var _raphaelBoxplotChart = __webpack_require__(29);
            var _raphaelBoxplotChart2 = _interopRequireDefault(_raphaelBoxplotChart);
            var _raphaelBulletChart = __webpack_require__(30);
            var _raphaelBulletChart2 = _interopRequireDefault(_raphaelBulletChart);
            var _raphaelLineChart = __webpack_require__(31);
            var _raphaelLineChart2 = _interopRequireDefault(_raphaelLineChart);
            var _raphaelAreaChart = __webpack_require__(34);
            var _raphaelAreaChart2 = _interopRequireDefault(_raphaelAreaChart);
            var _raphaelPieChart = __webpack_require__(36);
            var _raphaelPieChart2 = _interopRequireDefault(_raphaelPieChart);
            var _raphaelRadialLineSeries = __webpack_require__(37);
            var _raphaelRadialLineSeries2 = _interopRequireDefault(_raphaelRadialLineSeries);
            var _raphaelCoordinateTypeChart = __webpack_require__(38);
            var _raphaelCoordinateTypeChart2 = _interopRequireDefault(_raphaelCoordinateTypeChart);
            var _raphaelBoxTypeChart = __webpack_require__(39);
            var _raphaelBoxTypeChart2 = _interopRequireDefault(_raphaelBoxTypeChart);
            var _raphaelMapChart = __webpack_require__(40);
            var _raphaelMapChart2 = _interopRequireDefault(_raphaelMapChart);
            var _raphaelLegendComponent = __webpack_require__(41);
            var _raphaelLegendComponent2 = _interopRequireDefault(_raphaelLegendComponent);
            var _raphaelMapLegend = __webpack_require__(43);
            var _raphaelMapLegend2 = _interopRequireDefault(_raphaelMapLegend);
            var _raphaelCircleLegend = __webpack_require__(44);
            var _raphaelCircleLegend2 = _interopRequireDefault(_raphaelCircleLegend);
            var _raphaelTitleComponent = __webpack_require__(45);
            var _raphaelTitleComponent2 = _interopRequireDefault(_raphaelTitleComponent);
            var _raphaelAxisComponent = __webpack_require__(46);
            var _raphaelAxisComponent2 = _interopRequireDefault(_raphaelAxisComponent);
            var _raphaelRadialPlot = __webpack_require__(47);
            var _raphaelRadialPlot2 = _interopRequireDefault(_raphaelRadialPlot);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var pluginRaphael = exports2.pluginRaphael = {
              bar: _raphaelBarChart2["default"],
              boxplot: _raphaelBoxplotChart2["default"],
              bullet: _raphaelBulletChart2["default"],
              column: _raphaelBarChart2["default"],
              line: _raphaelLineChart2["default"],
              area: _raphaelAreaChart2["default"],
              pie: _raphaelPieChart2["default"],
              bubble: _raphaelCoordinateTypeChart2["default"],
              scatter: _raphaelCoordinateTypeChart2["default"],
              heatmap: _raphaelBoxTypeChart2["default"],
              treemap: _raphaelBoxTypeChart2["default"],
              map: _raphaelMapChart2["default"],
              radial: _raphaelRadialLineSeries2["default"],
              legend: _raphaelLegendComponent2["default"],
              mapLegend: _raphaelMapLegend2["default"],
              circleLegend: _raphaelCircleLegend2["default"],
              radialPlot: _raphaelRadialPlot2["default"],
              title: _raphaelTitleComponent2["default"],
              axis: _raphaelAxisComponent2["default"]
            };
            var callback = exports2.callback = function callback2(container, dimension) {
              var paper = (0, _raphael2["default"])(container, dimension.width, dimension.height);
              var rect = paper.rect(0, 0, dimension.width, dimension.height);
              if (paper.raphael.svg) {
                appendGlowFilterToDefs(paper);
                appendShadowFilterToDefs(paper);
              }
              paper.pushDownBackgroundToBottom = function() {
                rect.toBack();
              };
              paper.changeChartBackgroundColor = function(color) {
                rect.attr({
                  fill: color
                });
              };
              paper.changeChartBackgroundOpacity = function(opacity) {
                rect.attr({
                  "fill-opacity": opacity
                });
              };
              paper.resizeBackground = function(width, height) {
                rect.attr({
                  width,
                  height
                });
              };
              rect.attr({
                fill: "#fff",
                "stroke-width": 0
              });
              return paper;
            };
            function appendGlowFilterToDefs(paper) {
              var filter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
              var feGaussianBlur = document.createElementNS("http://www.w3.org/2000/svg", "feGaussianBlur");
              var feFlood = document.createElementNS("http://www.w3.org/2000/svg", "feFlood");
              var feComposite = document.createElementNS("http://www.w3.org/2000/svg", "feComposite");
              var feMorphology = document.createElementNS("http://www.w3.org/2000/svg", "feMorphology");
              var feMerge = document.createElementNS("http://www.w3.org/2000/svg", "feMerge");
              var feMergeNodeColoredBlur = document.createElementNS("http://www.w3.org/2000/svg", "feMergeNode");
              var feMergeNodeSourceGraphic = document.createElementNS("http://www.w3.org/2000/svg", "feMergeNode");
              filter.id = "glow";
              feFlood.setAttribute("result", "flood");
              feFlood.setAttribute("flood-color", "#ffffff");
              feFlood.setAttribute("flood-opacity", "0.5");
              feComposite.setAttribute("in", "flood");
              feComposite.setAttribute("result", "mask");
              feComposite.setAttribute("in2", "SourceGraphic");
              feComposite.setAttribute("operator", "in");
              feMorphology.setAttribute("in", "mask");
              feMorphology.setAttribute("result", "dilated");
              feMorphology.setAttribute("operator", "dilate");
              feMorphology.setAttribute("radius", "2");
              feGaussianBlur.setAttribute("in", "dilated");
              feGaussianBlur.setAttribute("result", "blurred");
              feGaussianBlur.setAttribute("stdDeviation", "1");
              feMergeNodeColoredBlur.setAttribute("in", "blurred");
              feMergeNodeSourceGraphic.setAttribute("in", "SourceGraphic");
              filter.appendChild(feFlood);
              filter.appendChild(feComposite);
              filter.appendChild(feMorphology);
              filter.appendChild(feGaussianBlur);
              filter.appendChild(feMerge);
              feMerge.appendChild(feMergeNodeColoredBlur);
              feMerge.appendChild(feMergeNodeSourceGraphic);
              paper.defs.appendChild(filter);
            }
            function appendShadowFilterToDefs(paper) {
              var filter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
              var feOffset = document.createElementNS("http://www.w3.org/2000/svg", "feOffset");
              var feGaussianBlur = document.createElementNS("http://www.w3.org/2000/svg", "feGaussianBlur");
              var feBlend = document.createElementNS("http://www.w3.org/2000/svg", "feBlend");
              filter.setAttributeNS(null, "id", "shadow");
              filter.setAttributeNS(null, "x", "-15%");
              filter.setAttributeNS(null, "y", "-15%");
              filter.setAttributeNS(null, "width", "180%");
              filter.setAttributeNS(null, "height", "180%");
              feOffset.setAttributeNS(null, "result", "offOut");
              feOffset.setAttributeNS(null, "in", "SourceAlpha");
              feOffset.setAttributeNS(null, "dx", "2");
              feOffset.setAttributeNS(null, "dy", "2");
              feGaussianBlur.setAttributeNS(null, "result", "blurOut");
              feGaussianBlur.setAttributeNS(null, "in", "offOut");
              feGaussianBlur.setAttributeNS(null, "stdDeviation", "2");
              feBlend.setAttributeNS(null, "in", "SourceGraphic");
              feBlend.setAttributeNS(null, "in2", "blurOut");
              feBlend.setAttributeNS(null, "mode", "normal");
              filter.appendChild(feOffset);
              filter.appendChild(feGaussianBlur);
              filter.appendChild(feBlend);
              paper.defs.appendChild(filter);
            }
          },
          /* 4 */
          /***/
          function(module2, exports2) {
            module2.exports = __WEBPACK_EXTERNAL_MODULE_4__;
          },
          /* 5 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _raphael = __webpack_require__(4);
            var _raphael2 = _interopRequireDefault(_raphael);
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _isObject = __webpack_require__(7);
            var _isObject2 = _interopRequireDefault(_isObject);
            var _forEach = __webpack_require__(8);
            var _forEach2 = _interopRequireDefault(_forEach);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _toConsumableArray(arr) {
              if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              } else {
                return Array.from(arr);
              }
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var ANIMATION_DURATION = 700;
            var EMPHASIS_OPACITY = 1;
            var DE_EMPHASIS_OPACITY = 0.3;
            var DEFAULT_LUMINANC = 0.2;
            var BAR_HOVER_SPARE_SIZE = 8;
            var SERIES_EXTRA_VISUAL_AREA_FOR_ZERO = 2;
            var SERIES_EXTRA_VISUAL_OPACITY_FOR_ZERO = 0.4;
            var RaphaelBarChart = function() {
              function RaphaelBarChart2() {
                _classCallCheck(this, RaphaelBarChart2);
              }
              RaphaelBarChart2.prototype.render = function render(paper, data) {
                var groupBounds = data.groupBounds, theme = data.theme, seriesDataModel = data.seriesDataModel, chartType = data.chartType, options = data.options;
                if (!groupBounds) {
                  return null;
                }
                this.paper = paper;
                this.theme = theme;
                this.seriesDataModel = seriesDataModel;
                this.chartType = chartType;
                this.paper.setStart();
                this.options = options;
                this.theme = theme;
                this.groupBars = this._renderBars(groupBounds);
                this.groupBorders = this._renderBarBorders(groupBounds);
                this.overlay = this._renderOverlay();
                this.groupBounds = groupBounds;
                return this.paper.setFinish();
              };
              RaphaelBarChart2.prototype._renderOverlay = function _renderOverlay() {
                var bound = {
                  width: 1,
                  height: 1,
                  left: 0,
                  top: 0
                };
                var attributes = {
                  "fill-opacity": 0
                };
                var overlay = this._renderBar(bound, "#fff", attributes);
                overlay.node.setAttribute("class", "auto-shape-rendering");
                return overlay;
              };
              RaphaelBarChart2.prototype._renderBar = function _renderBar(bound, color, attributes) {
                if (bound.width < 0 || bound.height < 0) {
                  return null;
                }
                var rect = _raphaelRenderUtil2["default"].renderRect(this.paper, bound, Object.assign({
                  fill: color,
                  stroke: "none"
                }, attributes)).toFront();
                rect.node.setAttribute("class", "auto-shape-rendering");
                return rect;
              };
              RaphaelBarChart2.prototype._renderBars = function _renderBars(groupBounds) {
                var _this = this;
                var colors = this.theme.colors;
                var _options = this.options, colorByPoint = _options.colorByPoint, animationDuration = _options.animationDuration;
                var groupBars = groupBounds.map(function(bounds, groupIndex) {
                  return bounds.map(function(bound, index) {
                    if (!bound) {
                      return null;
                    }
                    var item = _this.seriesDataModel.getSeriesItem(groupIndex, index);
                    var color = colorByPoint ? colors[groupIndex] : colors[index];
                    var rect = _this._renderBar(animationDuration ? bound.start : bound.end, color);
                    return {
                      rect,
                      color,
                      bound: bound.end,
                      item,
                      groupIndex,
                      index,
                      isRange: item.isRange
                    };
                  });
                });
                return groupBars;
              };
              RaphaelBarChart2.prototype._makeRectPoints = function _makeRectPoints(bound) {
                return {
                  leftTop: {
                    left: Math.ceil(bound.left),
                    top: Math.ceil(bound.top)
                  },
                  rightTop: {
                    left: Math.ceil(bound.left + bound.width),
                    top: Math.ceil(bound.top)
                  },
                  rightBottom: {
                    left: Math.ceil(bound.left + bound.width),
                    top: Math.ceil(bound.top + bound.height)
                  },
                  leftBottom: {
                    left: Math.ceil(bound.left),
                    top: Math.ceil(bound.top + bound.height)
                  }
                };
              };
              RaphaelBarChart2.prototype._makeTopLinePath = function _makeTopLinePath(points, chartType, item) {
                var value = item.value;
                var linePath = null;
                if (chartType === "bar" || value >= 0 || item.isRange) {
                  var cloneLeftTop = Object.assign({}, points.leftTop);
                  cloneLeftTop.left -= chartType === "column" || value < 0 ? 1 : 0;
                  linePath = _raphaelRenderUtil2["default"].makeLinePath(cloneLeftTop, points.rightTop).join(" ");
                }
                return linePath;
              };
              RaphaelBarChart2.prototype._makeRightLinePath = function _makeRightLinePath(points, chartType, item) {
                var linePath = null;
                if (chartType === "column" || item.value >= 0 || item.isRange) {
                  linePath = _raphaelRenderUtil2["default"].makeLinePath(points.rightTop, points.rightBottom).join(" ");
                }
                return linePath;
              };
              RaphaelBarChart2.prototype._makeBottomLinePath = function _makeBottomLinePath(points, chartType, item) {
                var linePath = null;
                if (chartType === "bar" || item.value < 0 || item.isRange) {
                  linePath = _raphaelRenderUtil2["default"].makeLinePath(points.leftBottom, points.rightBottom).join(" ");
                }
                return linePath;
              };
              RaphaelBarChart2.prototype._makeLeftLinePath = function _makeLeftLinePath(points, chartType, item) {
                var linePath = null;
                if (chartType === "column" || item.value < 0 || item.isRange) {
                  linePath = _raphaelRenderUtil2["default"].makeLinePath(points.leftTop, points.leftBottom).join(" ");
                }
                return linePath;
              };
              RaphaelBarChart2.prototype._makeBorderLinesPaths = function _makeBorderLinesPaths(bound, chartType, item) {
                var points = this._makeRectPoints(bound);
                var paths = {
                  top: this._makeTopLinePath(points, chartType, item),
                  right: this._makeRightLinePath(points, chartType, item),
                  bottom: this._makeBottomLinePath(points, chartType, item),
                  left: this._makeLeftLinePath(points, chartType, item)
                };
                Object.keys(paths).forEach(function(type) {
                  if (!paths[type]) {
                    delete paths[type];
                  }
                });
                return paths;
              };
              RaphaelBarChart2.prototype._renderBorderLines = function _renderBorderLines(bound, borderColor, chartType, item) {
                var borderLinePaths = this._makeBorderLinesPaths(bound, chartType, item);
                var lines = {};
                Object.entries(borderLinePaths).forEach(function(_ref) {
                  var _ref2 = _slicedToArray(_ref, 2), name = _ref2[0], path = _ref2[1];
                  lines[name] = _raphaelRenderUtil2["default"].renderLine(self.paper, path, {
                    color: borderColor,
                    strokeWidth: 1
                  });
                });
                return lines;
              };
              RaphaelBarChart2.prototype._renderBarBorders = function _renderBarBorders(groupBounds) {
                var _this2 = this;
                var borderColor = this.theme.borderColor;
                if (!borderColor) {
                  return null;
                }
                var groupBorders = groupBounds.map(function(bounds, groupIndex) {
                  return bounds.map(function(bound, index) {
                    if (!bound) {
                      return null;
                    }
                    var seriesItem = _this2.seriesDataModel.getSeriesItem(groupIndex, index);
                    return _this2._renderBorderLines(bound.start, borderColor, self.chartType, seriesItem);
                  });
                });
                return groupBorders;
              };
              RaphaelBarChart2.prototype._animateRect = function _animateRect(rect, bound, animationDuration) {
                rect.animate({
                  x: bound.width ? bound.left : bound.left - SERIES_EXTRA_VISUAL_AREA_FOR_ZERO / 2,
                  y: bound.height ? bound.top : bound.top - SERIES_EXTRA_VISUAL_AREA_FOR_ZERO / 2,
                  width: bound.width ? bound.width : SERIES_EXTRA_VISUAL_AREA_FOR_ZERO,
                  height: bound.height ? bound.height : SERIES_EXTRA_VISUAL_AREA_FOR_ZERO,
                  opacity: bound.height && bound.width ? 1 : SERIES_EXTRA_VISUAL_OPACITY_FOR_ZERO
                }, animationDuration, ">");
              };
              RaphaelBarChart2.prototype._animateBorders = function _animateBorders(lines, bound, chartType, item) {
                var paths = this._makeBorderLinesPaths(bound, chartType, item);
                (0, _forEach2["default"])(lines, function(line, name) {
                  line.animate({
                    path: paths[name]
                  }, ANIMATION_DURATION, ">");
                });
              };
              RaphaelBarChart2.prototype.animate = function animate(onFinish) {
                var _this3 = this;
                var groupBorders = this.groupBorders || [];
                var animationDuration = this.options.animationDuration;
                _raphaelRenderUtil2["default"].forEach2dArray(this.groupBars, function(bar, groupIndex, index) {
                  var lines = groupBorders[groupIndex] && groupBorders[groupIndex][index];
                  if (!bar) {
                    return;
                  }
                  if (animationDuration) {
                    _this3._animateRect(bar.rect, bar.bound, animationDuration);
                  }
                  if (lines) {
                    _this3._animateBorders(lines, bar.bound, _this3.chartType, bar.item);
                  }
                });
                if (onFinish) {
                  this.callbackTimeout = setTimeout(function() {
                    onFinish();
                    delete _this3.callbackTimeout;
                  }, animationDuration);
                }
              };
              RaphaelBarChart2.prototype.showAnimation = function showAnimation(data) {
                var bar = this.groupBars[data.groupIndex][data.index];
                var bound = bar.bound;
                this.overlay.attr({
                  width: bound.width + BAR_HOVER_SPARE_SIZE,
                  height: bound.height + BAR_HOVER_SPARE_SIZE,
                  stroke: "#fff",
                  "stroke-width": "1",
                  x: bound.left - 4,
                  y: bound.top - 4,
                  "fill-opacity": 1
                });
                this.resortBarIndex(data.groupIndex);
                this.overlay.toFront();
                bar.rect.toFront();
                if (this.labelSet) {
                  this.labelSet.toFront();
                }
                this.overlay.node.setAttribute("filter", "url(#shadow)");
              };
              RaphaelBarChart2.prototype.hideAnimation = function hideAnimation(data) {
                this.resortBarIndex(data.groupIndex);
                this.overlay.attr({
                  width: 1,
                  height: 1,
                  x: 0,
                  y: 0,
                  "fill-opacity": 0
                });
                if (this.labelSet) {
                  this.labelSet.toFront();
                }
              };
              RaphaelBarChart2.prototype.resortBarIndex = function resortBarIndex(groupIndex) {
                this.groupBars[groupIndex].forEach(function(barItem) {
                  barItem.rect.toFront();
                });
              };
              RaphaelBarChart2.prototype._updateRectBound = function _updateRectBound(rect, bound) {
                rect.attr({
                  x: bound.left,
                  y: bound.top,
                  width: bound.width,
                  height: bound.height
                });
              };
              RaphaelBarChart2.prototype.resize = function resize(params) {
                var _this4 = this;
                var groupBorders = this.groupBorders || [];
                var dimension = params.dimension, groupBounds = params.groupBounds;
                this.groupBounds = groupBounds;
                this.paper.setSize(dimension.width, dimension.height);
                _raphaelRenderUtil2["default"].forEach2dArray(this.groupBars, function(bar, groupIndex, index) {
                  if (!bar) {
                    return;
                  }
                  var lines = groupBorders[groupIndex] && groupBorders[groupIndex][index];
                  var bound = groupBounds[groupIndex][index].end;
                  bar.bound = bound;
                  _raphaelRenderUtil2["default"].updateRectBound(bar.rect, bound);
                  if (lines) {
                    _this4._updateBordersPath(lines, bound, _this4.chartType, bar.item);
                  }
                });
              };
              RaphaelBarChart2.prototype._changeBordersColor = function _changeBordersColor(lines, borderColor) {
                (0, _forEach2["default"])(lines, function(line) {
                  line.attr({
                    stroke: borderColor
                  });
                });
              };
              RaphaelBarChart2.prototype._changeBarColor = function _changeBarColor(indexes, color, borderColor) {
                var bar = this.groupBars[indexes.groupIndex][indexes.index];
                bar.rect.attr({
                  fill: color
                });
                if (borderColor) {
                  var lines = this.groupBorders[indexes.groupIndex][indexes.index];
                  this._changeBordersColor(lines, borderColor);
                }
              };
              RaphaelBarChart2.prototype.selectSeries = function selectSeries(indexes) {
                var bar = this.groupBars[indexes.groupIndex][indexes.index];
                var objColor = _raphael2["default"].color(bar.color);
                var selectionColorTheme = this.theme.selectionColor;
                var color = selectionColorTheme || _raphaelRenderUtil2["default"].makeChangedLuminanceColor(objColor.hex, DEFAULT_LUMINANC);
                var borderColor = this.theme.borderColor;
                if (borderColor) {
                  var objBorderColor = _raphael2["default"].color(borderColor);
                  borderColor = _raphaelRenderUtil2["default"].makeChangedLuminanceColor(objBorderColor.hex, DEFAULT_LUMINANC);
                }
                this._changeBarColor(indexes, color, borderColor);
              };
              RaphaelBarChart2.prototype.unselectSeries = function unselectSeries(indexes) {
                var bar = this.groupBars[indexes.groupIndex][indexes.index];
                var borderColor = this.theme.borderColor;
                this._changeBarColor(indexes, bar.color, borderColor);
              };
              RaphaelBarChart2.prototype.selectLegend = function selectLegend(legendIndex) {
                var groupBorders = this.groupBorders || [];
                var noneSelected = (0, _isNull2["default"])(legendIndex);
                _raphaelRenderUtil2["default"].forEach2dArray(this.groupBars, function(bar, groupIndex, index) {
                  if (!bar) {
                    return;
                  }
                  var lines = groupBorders[groupIndex] && groupBorders[groupIndex][index];
                  var opacity = noneSelected || legendIndex === index ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
                  bar.rect.attr({
                    "fill-opacity": opacity
                  });
                  if (lines) {
                    (0, _forEach2["default"])(lines, function(line) {
                      line.attr({
                        "stroke-opacity": opacity
                      });
                    });
                  }
                });
              };
              RaphaelBarChart2.prototype.renderSeriesLabel = function renderSeriesLabel(paper, groupPositions, groupLabels, labelTheme, isStacked) {
                var textAnchor = isStacked || this.chartType === "column" ? "middle" : "start";
                var attributes = {
                  "font-size": labelTheme.fontSize,
                  "font-family": labelTheme.fontFamily,
                  "font-weight": labelTheme.fontWeight,
                  fill: labelTheme.color,
                  opacity: 0,
                  "text-anchor": textAnchor
                };
                var labelSet = this.labelSet = paper.set();
                groupLabels.forEach(function(categoryLabel, categoryIndex) {
                  categoryLabel.forEach(function(label, seriesIndex) {
                    var position = groupPositions[categoryIndex][seriesIndex];
                    var endLabel = _raphaelRenderUtil2["default"].renderText(paper, position.end, label.end, attributes);
                    var enaLabelNodeStyle = endLabel.node.style;
                    enaLabelNodeStyle.userSelect = "none";
                    enaLabelNodeStyle.cursor = "default";
                    labelSet.push(endLabel);
                    if (position.start) {
                      var startLabel = _raphaelRenderUtil2["default"].renderText(paper, position.start, label.start, attributes);
                      startLabel.node.style.userSelect = "none";
                      startLabel.node.style.cursor = "default";
                      labelSet.push(startLabel);
                    }
                  });
                });
                return labelSet;
              };
              RaphaelBarChart2.prototype._calculateConnectorPosition = function _calculateConnectorPosition(bound, group) {
                var connectorModel = [];
                var barChart = this.chartType === "bar";
                var _bound = _slicedToArray(bound, 2), startBound = _bound[0], endBound = _bound[1];
                var _group = _slicedToArray(group, 2), startGroups = _group[0], endGroups = _group[1];
                for (var seriesIdx = 0; seriesIdx < startBound.length; seriesIdx += 1) {
                  var isStartValueNegative = startGroups.items[seriesIdx].value < 0;
                  var isEndValueNegative = endGroups.items[seriesIdx].value < 0;
                  var _startBound$seriesIdx = startBound[seriesIdx].end, top = _startBound$seriesIdx.top, left = _startBound$seriesIdx.left, width = _startBound$seriesIdx.width, height = _startBound$seriesIdx.height;
                  var _endBound$seriesIdx$e = endBound[seriesIdx].end, endTop = _endBound$seriesIdx$e.top, endLeft = _endBound$seriesIdx$e.left, endHeight = _endBound$seriesIdx$e.height, endWidth = _endBound$seriesIdx$e.width;
                  connectorModel.push([{
                    top: top + (!barChart && isStartValueNegative ? height : 0) + (barChart ? height : 0),
                    left: left + (barChart && isStartValueNegative ? 0 : width)
                  }, {
                    top: endTop + (!barChart && isEndValueNegative ? endHeight : 0),
                    left: endLeft + (barChart && !isEndValueNegative ? endWidth : 0)
                  }]);
                }
                return connectorModel;
              };
              RaphaelBarChart2.prototype._makeConnectorModel = function _makeConnectorModel(seriesData) {
                var groupBounds = seriesData.groupBounds, seriesDataModel = seriesData.seriesDataModel;
                var groups = seriesDataModel.groups;
                var connectorModel = [];
                for (var boundIdx = 0; boundIdx < groupBounds.length - 1; boundIdx += 1) {
                  var bound = [groupBounds[boundIdx], groupBounds[boundIdx + 1]];
                  var group = [groups[boundIdx], groups[boundIdx + 1]];
                  connectorModel.push.apply(connectorModel, _toConsumableArray(this._calculateConnectorPosition(bound, group)));
                }
                return connectorModel;
              };
              RaphaelBarChart2.prototype.renderConnector = function renderConnector(paper, seriesData, stack) {
                var connectorModels = this._makeConnectorModel(seriesData);
                var connectorSet = this.connectorSet = paper.set();
                var connector = stack.connector;
                var hasConnectorStyle = (0, _isObject2["default"])(connector);
                var strokeWidth = hasConnectorStyle && connector.width || 1;
                var color = hasConnectorStyle && connector.color || "#ddd";
                var dotted = hasConnectorStyle && connector.type === "dotted" || false;
                connectorModels.forEach(function(model) {
                  var _model = _slicedToArray(model, 2), from = _model[0], to = _model[1];
                  connectorSet.push(_raphaelRenderUtil2["default"].renderLine(paper, _raphaelRenderUtil2["default"].makeLinePath(from, to).join(" "), {
                    color,
                    strokeWidth,
                    dotted,
                    connector: true
                  }));
                });
                return connectorSet;
              };
              return RaphaelBarChart2;
            }();
            exports2["default"] = RaphaelBarChart;
          },
          /* 6 */
          /***/
          function(module2, exports2) {
            "use strict";
            function isNull(obj) {
              return obj === null;
            }
            module2.exports = isNull;
          },
          /* 7 */
          /***/
          function(module2, exports2) {
            "use strict";
            function isObject(obj) {
              return obj === Object(obj);
            }
            module2.exports = isObject;
          },
          /* 8 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var isArray = __webpack_require__(9);
            var forEachArray = __webpack_require__(10);
            var forEachOwnProperties = __webpack_require__(11);
            function forEach(obj, iteratee, context) {
              if (isArray(obj)) {
                forEachArray(obj, iteratee, context);
              } else {
                forEachOwnProperties(obj, iteratee, context);
              }
            }
            module2.exports = forEach;
          },
          /* 9 */
          /***/
          function(module2, exports2) {
            "use strict";
            function isArray(obj) {
              return obj instanceof Array;
            }
            module2.exports = isArray;
          },
          /* 10 */
          /***/
          function(module2, exports2) {
            "use strict";
            function forEachArray(arr, iteratee, context) {
              var index = 0;
              var len = arr.length;
              context = context || null;
              for (; index < len; index += 1) {
                if (iteratee.call(context, arr[index], index, arr) === false) {
                  break;
                }
              }
            }
            module2.exports = forEachArray;
          },
          /* 11 */
          /***/
          function(module2, exports2) {
            "use strict";
            function forEachOwnProperties(obj, iteratee, context) {
              var key;
              context = context || null;
              for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                  if (iteratee.call(context, obj[key], key, obj) === false) {
                    break;
                  }
                }
              }
            }
            module2.exports = forEachOwnProperties;
          },
          /* 12 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _range = __webpack_require__(13);
            var _range2 = _interopRequireDefault(_range);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _decodeHTMLEntity = __webpack_require__(16);
            var _decodeHTMLEntity2 = _interopRequireDefault(_decodeHTMLEntity);
            var _raphael = __webpack_require__(4);
            var _raphael2 = _interopRequireDefault(_raphael);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var LINE_HEIGHT_FOR_CALCULATE = 1.11;
            var storeForGetTextDimension = {
              cacheFontInfo: "",
              elementForTextSize: null,
              canvasElement: getCanvasForTextDimension()
            };
            exports2["default"] = {
              /**
               * Make line path.
               * @memberOf module:raphaelRenderUtil
               * @param {{top: number, left: number}} fromPos from position
               * @param {{top: number, left: number}} toPos to position
               * @param {number} width width
               * @returns {string} path
               */
              makeLinePath: function makeLinePath(fromPos, toPos) {
                var width = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
                var fromPoint = [fromPos.left, fromPos.top];
                var toPoint = [toPos.left, toPos.top];
                var additionalPoint = width % 2 / 2;
                fromPoint.forEach(function(from, index) {
                  if (from === toPoint[index]) {
                    fromPoint[index] = toPoint[index] = Math.round(from) - additionalPoint;
                  }
                });
                return ["M"].concat(fromPoint, ["L"], toPoint);
              },
              /**
               * Render line.
               * @memberOf module:raphaelRenderUtil
               * @param {object} paper raphael paper
               * @param {string} path line path
               * @param {object} options line options
               * @param {string} options.color line color
               * @param {number} [options.strokeWidth] stroke width
               * @param {boolean} [options.dotted] dotted line
               * @param {boolean} [options.connector] whether connector line
               * @returns {object} raphael line
               */
              renderLine: function renderLine(paper, path, options) {
                var color = options.color, strokeWidth = options.strokeWidth, dotted = options.dotted, connector = options.connector;
                var line = paper.path([path]);
                var strokeStyle = {
                  stroke: color,
                  "stroke-width": (0, _isUndefined2["default"])(strokeWidth) ? 2 : strokeWidth,
                  "stroke-linecap": "butt",
                  opacity: connector ? 0 : 1
                };
                if (color === "transparent") {
                  strokeStyle.stroke = "#fff";
                  strokeStyle["stroke-opacity"] = 0;
                }
                line.attr(strokeStyle).node.setAttribute("class", "auto-shape-rendering");
                if (dotted) {
                  line.attr(strokeStyle).node.setAttribute("class", "stroke-dasharray");
                }
                return line;
              },
              /**
               * text ellipsis for fixed width
               * @param {string} text - target text
               * @param {number} fixedWidth - width for ellipsis
               * @param {object} theme - label theme
               * @returns {string}
               */
              getEllipsisText: function getEllipsisText(text, fixedWidth, theme) {
                var textArray = String(text).split("");
                var textLength = textArray.length;
                var dotWidth = this.getRenderedTextSize(".", theme.fontSize, theme.fontFamily).width;
                var newString = "";
                var textWidth = dotWidth * 2;
                for (var i = 0; i < textLength; i += 1) {
                  textWidth += this.getRenderedTextSize(textArray[i], theme.fontSize, theme.fontFamily).width;
                  if (textWidth >= fixedWidth) {
                    newString += "..";
                    break;
                  }
                  newString += textArray[i];
                }
                return newString;
              },
              /**
               * Render text
               * @param {object} paper - Raphael paper object
               * @param {{left: number, top: number}} pos - text object position
               * @param {string} text - text content
               * @param {object} [attributes] - text object's attributes
               * @returns {object}
               */
              renderText: function renderText(paper, pos, text, attributes) {
                var textObj = paper.text(pos.left, pos.top, (0, _decodeHTMLEntity2["default"])(String(text)));
                if (attributes) {
                  if (attributes["dominant-baseline"]) {
                    textObj.node.setAttribute("dominant-baseline", attributes["dominant-baseline"]);
                  } else {
                    textObj.node.setAttribute("dominant-baseline", "central");
                  }
                  textObj.attr(attributes);
                }
                return textObj;
              },
              /**
               * Render area graph.
               * @param {object} paper raphael paper
               * @param {string} path path
               * @param {object} fillStyle fill style
               *      @param {string} fillStyle.fill fill color
               *      @param {?number} fillStyle.opacity fill opacity
               *      @param {string} fillStyle.stroke stroke color
               *      @param {?number} fillStyle.stroke-opacity stroke opacity
               * @returns {Array.<object>} raphael object
               */
              renderArea: function renderArea(paper, path, fillStyle) {
                var area = paper.path(path);
                fillStyle = Object.assign({
                  "stroke-opacity": 0
                }, fillStyle);
                area.attr(fillStyle);
                return area;
              },
              /**
               * Render circle.
               * @param {object} paper - raphael object
               * @param {{left: number, top: number}} position - position
               * @param {number} radius - radius
               * @param {object} attributes - attributes
               * @returns {object}
               */
              renderCircle: function renderCircle(paper, position, radius, attributes) {
                var circle = paper.circle(position.left, position.top, radius);
                if (attributes) {
                  circle.attr(attributes);
                }
                return circle;
              },
              /**
               * Render rect.
               * @param {object} paper - raphael object
               * @param {{left: number, top: number, width: number, height, number}} bound - bound
               * @param {object} attributes - attributes
               * @returns {*}
               */
              renderRect: function renderRect(paper, bound, attributes) {
                var rect = paper.rect(bound.left, bound.top, bound.width, bound.height);
                if (attributes) {
                  rect.attr(attributes);
                }
                return rect;
              },
              /**
               * Update rect bound
               * @param {object} rect raphael object
               * @param {{left: number, top: number, width: number, height: number}} bound bound
               */
              updateRectBound: function updateRectBound(rect, bound) {
                rect.attr({
                  x: bound.left,
                  y: bound.top,
                  width: bound.width,
                  height: bound.height
                });
              },
              /**
               * Render items of line type chart.
               * @param {Array.<Array.<object>>} groupItems group items
               * @param {function} funcRenderItem function
               */
              forEach2dArray: function forEach2dArray(groupItems, funcRenderItem) {
                if (groupItems) {
                  groupItems.forEach(function(items, groupIndex) {
                    items.forEach(function(item, index) {
                      funcRenderItem(item, groupIndex, index);
                    });
                  });
                }
              },
              /**
               * Make changed luminance color.
               * @param {string} hex hax color
               * @param {number} lum luminance
               * @returns {string} changed color
               */
              makeChangedLuminanceColor: function makeChangedLuminanceColor(hex, lum) {
                hex = hex.replace("#", "");
                lum = lum || 0;
                var changedHex = (0, _range2["default"])(3).map(function(index) {
                  var hd = parseInt(hex.substr(index * 2, 2), 16);
                  var newHd = hd + hd * lum;
                  newHd = Math.round(Math.min(Math.max(0, newHd), 255)).toString(16);
                  return _renderUtil2["default"].formatToZeroFill(newHd, 2);
                }).join("");
                return "#" + changedHex;
              },
              /**
               * Get rendered text element size
               * @param {string} text text content
               * @param {number} fontSize font-size attribute
               * @param {string} fontFamily font-family attribute
               * @returns {{
               *     width: number,
               *     height: number
               * }}
               */
              getRenderedTextSize: function getRenderedTextSize(text) {
                var fontSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 11;
                var fontFamily = arguments[2];
                var canvasElement = storeForGetTextDimension.canvasElement;
                if (canvasElement) {
                  return this._getTextDimensionWithCanvas(text, fontSize, fontFamily);
                }
                return this._getTextDimensionUseHtmlElement(text, fontSize, fontFamily);
              },
              /**
               * Get rendered text element size (Use Canvas)
               * @param {string} text text content
               * @param {number} fontSize font-size attribute
               * @param {string} fontFamily font-family attribute
               * @returns {{
               *     width: number,
               *     height: number
               * }}
               * @private
               */
              _getTextDimensionWithCanvas: function _getTextDimensionWithCanvas(text, fontSize, fontFamily) {
                var canvasElement = storeForGetTextDimension.canvasElement, cacheFontInfo = storeForGetTextDimension.cacheFontInfo;
                var ctx = canvasElement.getContext("2d");
                var fontInfo = fontSize + "px " + fontFamily;
                if (cacheFontInfo !== fontInfo) {
                  storeForGetTextDimension.cacheFontInfo = fontInfo;
                  ctx.font = fontInfo;
                }
                return {
                  width: ctx.measureText(text).width,
                  height: fontSize * LINE_HEIGHT_FOR_CALCULATE
                };
              },
              /**
               * Get rendered text element size (Use HTMLElement)
               * @param {string} text text content
               * @param {number} fontSize font-size attribute
               * @param {string} fontFamily font-family attribute
               * @returns {{
               *     width: number,
               *     height: number
               * }}
               * @private
               */
              _getTextDimensionUseHtmlElement: function _getTextDimensionUseHtmlElement(text, fontSize, fontFamily) {
                var cacheFontInfo = storeForGetTextDimension.cacheFontInfo;
                var elementForTextSize = storeForGetTextDimension.elementForTextSize;
                if (!elementForTextSize) {
                  elementForTextSize = document.createElement("div");
                  var elementStyle = elementForTextSize.style;
                  this._setBasicHtmlElementStyleForGetTextSize(elementStyle);
                  document.body.appendChild(elementForTextSize);
                  storeForGetTextDimension.elementForTextSize = elementForTextSize;
                }
                var fontInfo = fontSize + "px " + fontFamily;
                if (cacheFontInfo !== fontInfo) {
                  var _elementStyle = elementForTextSize.style;
                  _elementStyle.fontFamily = fontFamily;
                  _elementStyle.fontSize = fontSize + "px";
                  storeForGetTextDimension.cacheFontInfo = fontInfo;
                }
                elementForTextSize.innerHTML = text;
                return {
                  width: elementForTextSize.clientWidth,
                  height: elementForTextSize.clientHeight
                };
              },
              /**
               * Set basic style for get text dimension element
               * @param {object} elementStyle style object for the element to get the text dimension
               */
              _setBasicHtmlElementStyleForGetTextSize: function _setBasicHtmlElementStyleForGetTextSize(elementStyle) {
                elementStyle.visibility = "hidden";
                elementStyle.position = "absolute";
                elementStyle.margin = 0;
                elementStyle.padding = 0;
                elementStyle.lineHeight = LINE_HEIGHT_FOR_CALCULATE;
                elementStyle.whiteSpace = "nowrap";
              },
              /**
               * Animate given element's opacity
               * @param {object} element element
               * @param {number} startOpacity endOpacity default is '0'
               * @param {number} endOpacity endOpacity default is '1'
               * @param {number} duration endOpacity default is '600'
               */
              animateOpacity: function animateOpacity(element, startOpacity, endOpacity, duration) {
                var animationDuration = isNumber(duration) ? duration : 600;
                var animationStartOpacity = isNumber(startOpacity) ? startOpacity : 0;
                var animationEndOpacity = isNumber(endOpacity) ? endOpacity : 1;
                var animation = _raphael2["default"].animation({
                  opacity: animationEndOpacity
                }, animationDuration);
                element.attr({
                  opacity: animationStartOpacity
                });
                element.animate(animation);
              },
              /**
               * get default animation duration
               * @param {string} chartType - chart type
               * @returns {number} duration - default duration
               * @private
               */
              getDefaultAnimationDuration: function getDefaultAnimationDuration(chartType) {
                switch (chartType) {
                  case "boxplot":
                  case "combo":
                  case "pie":
                  case "scatter":
                  case "bubble":
                  case "area":
                  case "line":
                  case "column":
                  case "bar":
                    return 700;
                  case "heatmap":
                  case "treemap":
                    return 600;
                  default:
                    return 0;
                }
              }
            };
            function isNumber(numberSuspect) {
              return (0, _isExisty2["default"])(numberSuspect) && typeof numberSuspect === "number";
            }
            function getCanvasForTextDimension() {
              var isSupportCanvasContext = !!document.createElement("canvas").getContext;
              if (!isSupportCanvasContext) {
                return null;
              }
              var canvas = document.createElement("canvas");
              var context = canvas.getContext("2d");
              if (typeof context.fillText === "function") {
                return canvas;
              }
              return null;
            }
          },
          /* 13 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var isUndefined = __webpack_require__(14);
            function range(start, stop, step) {
              var arr = [];
              var flag;
              if (isUndefined(stop)) {
                stop = start || 0;
                start = 0;
              }
              step = step || 1;
              flag = step < 0 ? -1 : 1;
              stop *= flag;
              for (; start * flag < stop; start += step) {
                arr.push(start);
              }
              return arr;
            }
            module2.exports = range;
          },
          /* 14 */
          /***/
          function(module2, exports2) {
            "use strict";
            function isUndefined(obj) {
              return obj === void 0;
            }
            module2.exports = isUndefined;
          },
          /* 15 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var isUndefined = __webpack_require__(14);
            var isNull = __webpack_require__(6);
            function isExisty(param) {
              return !isUndefined(param) && !isNull(param);
            }
            module2.exports = isExisty;
          },
          /* 16 */
          /***/
          function(module2, exports2) {
            "use strict";
            function decodeHTMLEntity(htmlEntity) {
              var entities = {
                "&quot;": '"',
                "&amp;": "&",
                "&lt;": "<",
                "&gt;": ">",
                "&#39;": "'",
                "&nbsp;": " "
              };
              return htmlEntity.replace(/&amp;|&lt;|&gt;|&quot;|&#39;|&nbsp;/g, function(m0) {
                return entities[m0] ? entities[m0] : m0;
              });
            }
            module2.exports = decodeHTMLEntity;
          },
          /* 17 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isArray = __webpack_require__(9);
            var _isArray2 = _interopRequireDefault(_isArray);
            var _isDate = __webpack_require__(18);
            var _isDate2 = _interopRequireDefault(_isDate);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isNumber = __webpack_require__(19);
            var _isNumber2 = _interopRequireDefault(_isNumber);
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _formatDate = __webpack_require__(20);
            var _formatDate2 = _interopRequireDefault(_formatDate);
            var _forEach = __webpack_require__(8);
            var _forEach2 = _interopRequireDefault(_forEach);
            var _forEachArray = __webpack_require__(10);
            var _forEachArray2 = _interopRequireDefault(_forEachArray);
            var _browser = __webpack_require__(22);
            var _browser2 = _interopRequireDefault(_browser);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _domHandler = __webpack_require__(24);
            var _domHandler2 = _interopRequireDefault(_domHandler);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _toConsumableArray(arr) {
              if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              } else {
                return Array.from(arr);
              }
            }
            var _isOldBrowser = _browser2["default"].msie && _browser2["default"].version <= 8;
            var hasComputedStyle = window.getComputedStyle || false;
            var CLIP_RECT_ID = "clipRectForAnimation";
            var lineBaseChartCount = 0;
            var renderUtil = {
              /**
               * Concat string.
               * @params {...string} target strings
               * @returns {string} concat string
               * @memberof module:renderUtil
               */
              concatStr: function concatStr() {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                return String.prototype.concat.apply("", args);
              },
              /**
               * oneline trim tag for template literal
               * @params {...string} target strings
               * @returns {string} templating string
               * @memberof module:renderUtil
               */
              oneLineTrim: function oneLineTrim() {
                var normalTag = function normalTag2(template) {
                  for (var _len2 = arguments.length, expressions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                    expressions[_key2 - 1] = arguments[_key2];
                  }
                  return template.reduce(function(accumulator, part, i) {
                    return accumulator + expressions[i - 1] + part;
                  });
                };
                return normalTag.apply(void 0, arguments).replace(/\n\s*/g, "");
              },
              /**
               * Make cssText for font.
               * @param {{fontSize: number, fontFamily: string, color: string}} theme font theme
               * @returns {string} cssText
               * @memberof module:renderUtil
               */
              makeFontCssText: function makeFontCssText() {
                var theme = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                var cssTexts = [];
                if (theme.fontSize) {
                  cssTexts.push(this.concatStr("font-size:", theme.fontSize, "px"));
                }
                if (theme.fontFamily) {
                  cssTexts.push(this.concatStr("font-family:", theme.fontFamily));
                }
                if (theme.color) {
                  cssTexts.push(this.concatStr("color:", theme.color));
                }
                if (theme.fontWeight) {
                  cssTexts.push(this.concatStr("font-weight:", theme.fontWeight));
                }
                return cssTexts.length ? cssTexts.join(";") : "";
              },
              /**
               * Make caching key.
               * @param {string} label labek
               * @param {{fontSize: number, fontFamily: string}} theme theme
               * @param {string} offsetType offset type (offsetWidth or offsetHeight)
               * @returns {string} key
               * @private
               */
              _makeCachingKey: function _makeCachingKey(label, theme, offsetType) {
                var keys = [label, offsetType];
                (0, _forEach2["default"])(theme, function(key, value) {
                  keys.push(key + value);
                });
                return keys.join("-");
              },
              /**
               * Add css style.
               * @param {HTMLElement} div div element
               * @param {{fontSize: number, fontFamily: string, cssText: string}} theme theme
               * @private
               */
              _addCssStyle: function _addCssStyle(div) {
                var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, fontSize = _ref.fontSize, fontFamily = _ref.fontFamily, fontWeight = _ref.fontWeight, cssText = _ref.cssText;
                div.style.fontSize = (fontSize || _const2["default"].DEFAULT_LABEL_FONT_SIZE) + "px";
                if (fontFamily) {
                  div.style.fontFamily = fontFamily;
                }
                if (fontWeight) {
                  div.style.fontWeight = fontWeight;
                }
                if (cssText) {
                  div.style.cssText += cssText;
                }
              },
              /**
               * Size cache.
               * @type {object}
               * @private
               */
              sizeCache: {},
              /**
               * Get rendered label size (width or height).
               * @memberOf module:renderUtil
               * @param {string | number} label label
               * @param {object} theme theme
               * @param {string} offsetType offset type (offsetWidth or offsetHeight)
               * @returns {number} size
               * @private
               */
              _getRenderedLabelSize: function _getRenderedLabelSize() {
                var label = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
                var theme = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var offsetType = arguments[2];
                label = String(label);
                if (!label) {
                  return 0;
                }
                var key = this._makeCachingKey(label, theme, offsetType);
                var labelSize = this.sizeCache[key];
                if (!labelSize) {
                  var div = this._createSizeCheckEl();
                  var span = div.firstChild;
                  span.innerText = label;
                  this._addCssStyle(div, theme);
                  document.body.appendChild(div);
                  labelSize = span[offsetType];
                  document.body.removeChild(div);
                  this.sizeCache[key] = labelSize;
                }
                return labelSize;
              },
              checkEl: null,
              /**
               * Create element for size check.
               * @memberof module:renderUtil
               * @returns {HTMLElement} element
               * @private
               */
              _createSizeCheckEl: function _createSizeCheckEl() {
                if (!this.checkEl) {
                  var div = _domHandler2["default"].create("DIV", "tui-chart-size-check-element");
                  var span = _domHandler2["default"].create("SPAN");
                  div.appendChild(span);
                  this.checkEl = div;
                } else {
                  this.checkEl.style.cssText = "";
                }
                return this.checkEl;
              },
              /**
               * Get rendered label width.
               * @memberof module:renderUtil
               * @param {string} label label
               * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
               * @returns {number} width
               */
              getRenderedLabelWidth: function getRenderedLabelWidth(label, theme) {
                return this._getRenderedLabelSize(label, theme, "offsetWidth");
              },
              /**
               * Get rendered label height.
               * @memberof module:renderUtil
               * @param {string} label label
               * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
               * @returns {number} height
               */
              getRenderedLabelHeight: function getRenderedLabelHeight(label, theme) {
                return this._getRenderedLabelSize(label, theme, "offsetHeight");
              },
              /**
               * Get Rendered Labels Max Size(width or height).
               * @memberof module:renderUtil
               * @param {string[]} labels labels
               * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
               * @param {function} iteratee iteratee
               * @returns {number} max size (width or height)
               * @private
               */
              _getRenderedLabelsMaxSize: function _getRenderedLabelsMaxSize(labels, theme, iteratee) {
                var maxSize = 0;
                if (labels && labels.length) {
                  var sizes = labels.map(function(label) {
                    return iteratee(label, theme);
                  });
                  maxSize = _arrayUtil2["default"].max(sizes);
                }
                return maxSize;
              },
              /**
               * Get rendered labels max width.
               * @memberof module:renderUtil
               * @param {string[]} labels labels
               * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
               * @param {number} [maxWidth] - max width
               * @returns {number} max width
               * @private
               */
              getRenderedLabelsMaxWidth: function getRenderedLabelsMaxWidth(labels, theme, maxWidth) {
                var iteratee = this.getRenderedLabelWidth.bind(this);
                var labelMaxSize = this._getRenderedLabelsMaxSize(labels, theme, iteratee);
                return maxWidth ? Math.min(maxWidth, labelMaxSize) : labelMaxSize;
              },
              /**
               * Get rendered labels max height.
               * @memberof module:renderUtil
               * @param {string[]} labels labels
               * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
               * @returns {number} max height
               */
              getRenderedLabelsMaxHeight: function getRenderedLabelsMaxHeight(labels, theme) {
                var iteratee = this.getRenderedLabelHeight.bind(this);
                return this._getRenderedLabelsMaxSize(labels, theme, iteratee);
              },
              /**
               * Render dimension.
               * @memberof module:renderUtil
               * @param {HTMLElement} el target element
               * @param {{width: number, height: number}} dimension dimension
               */
              renderDimension: function renderDimension(el, _ref2) {
                var _ref2$width = _ref2.width, width = _ref2$width === void 0 ? 0 : _ref2$width, _ref2$height = _ref2.height, height = _ref2$height === void 0 ? 0 : _ref2$height;
                el.style.cssText = [this.concatStr("width:", width, "px"), this.concatStr("height:", height, "px")].join(";");
              },
              /**
               * Render position(top, right).
               * @memberof module:renderUtil
               * @param {HTMLElement} el target element
               * @param {{top: number, left: number, right: number}} position position
               */
              renderPosition: function renderPosition(el, position) {
                if ((0, _isUndefined2["default"])(position)) {
                  return;
                }
                (0, _forEachArray2["default"])(["top", "bottom", "left", "right"], function(key) {
                  var value = position[key];
                  if ((0, _isNumber2["default"])(value)) {
                    el.style[key] = value + "px";
                  }
                });
              },
              /**
               * Render background.
               * @memberof module:renderUtil
               * @param {HTMLElement} el target element
               * @param {string} background background option
               */
              renderBackground: function renderBackground(el, background) {
                if (background) {
                  el.style.background = background;
                }
              },
              /**
               * Render font family.
               * @memberof module:renderUtil
               * @param {HTMLElement} el target element
               * @param {string} fontFamily font family option
               */
              renderFontFamily: function renderFontFamily(el, fontFamily) {
                if (!fontFamily) {
                  return;
                }
                el.style.fontFamily = fontFamily;
              },
              /**
               * Render title.
               * @memberof module:renderUtil
               * @param {string} title title
               * @param {{fontSize: number, color: string, background: string}} theme title theme
               * @param {string} className css class name
               * @returns {HTMLElement} title element
               */
              renderTitle: function renderTitle(title, theme, className) {
                if (!title) {
                  return null;
                }
                var cssText = renderUtil.makeFontCssText(theme);
                var elTitle = _domHandler2["default"].create("DIV", className);
                elTitle.innerHTML = title;
                if (theme.background) {
                  cssText += ";" + this.concatStr("background:", theme.background);
                }
                elTitle.style.cssText = cssText;
                return elTitle;
              },
              /**
               * Expand dimension.
               * @param {{
               *      dimension: {width: number, height: number},
               *      position: {left: number, top: number}
               * }} bound series bound
               * @returns {{
               *      dimension: {width: number, height: number},
               *      position: {left: number, top: number}
               * }} expended bound
               * @memberof module:renderUtil
               */
              expandBound: function expandBound(_ref3) {
                var dimension = _ref3.dimension, position = _ref3.position;
                return {
                  dimension: {
                    width: dimension.width + _const2["default"].SERIES_EXPAND_SIZE * 2,
                    height: dimension.height + _const2["default"].SERIES_EXPAND_SIZE * 2
                  },
                  position: {
                    left: position.left - _const2["default"].SERIES_EXPAND_SIZE,
                    top: position.top - _const2["default"].SERIES_EXPAND_SIZE
                  }
                };
              },
              /**
               * Proper case.
               * @param {string} value - string value
               * @returns {string}
               */
              _properCase: function _properCase(value) {
                return value.substring(0, 1).toUpperCase() + value.substring(1);
              },
              /**
               * Make mouse event detector name.
               * @param {string} prefix prefix
               * @param {string} value value
               * @param {string} suffix suffix
               * @returns {string} mouse event detector name
               * @memberof module:renderUtil
               */
              makeMouseEventDetectorName: function makeMouseEventDetectorName(prefix, value, suffix) {
                return prefix + this._properCase(value) + this._properCase(suffix);
              },
              /**
               * Format value.
               * @param {object} params - raw data
               *     @param {number} params.value value
               *     @param {Array.<function>} params.formatFunctions - functions for format
               *     @param {string} params.chartType - type of chart
               *     @param {string} params.areaType - type of area like yAxis, xAxis, series, circleLegend
               *     @param {string} [params.valueType] - type of value
               *     @param {string} [params.legendName] - legendName
               * @returns {string} formatted value
               * @memberof module:renderUtil
               */
              formatValue: function formatValue(params) {
                var value = params.value, formatFunctions = params.formatFunctions, _params$valueType = params.valueType, valueType = _params$valueType === void 0 ? "value" : _params$valueType, areaType = params.areaType, legendName = params.legendName, chartType = params.chartType;
                var fns = [String(value)].concat(_toConsumableArray(formatFunctions || []));
                return fns.reduce(function(stored, fn) {
                  return fn(stored, chartType, areaType, valueType, legendName);
                });
              },
              /**
               * Format values.
               * @param {Array.<number>} values values
               * @param {Array.<function>} formatFunctions functions for format
               * @param {object} typeInfos - type of chart
               *     @param {string} typeInfos.chartType - type of chart
               *     @param {string} typeInfos.areaType - type of area like yAxis, xAxis, series, circleLegend
               *     @param {string} typeInfos.valueType - type of value
               * @returns {Array.<string>}
               * @memberof module:renderUtil
               */
              formatValues: function formatValues(values, formatFunctions) {
                var typeInfos = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                var chartType = typeInfos.chartType, areaType = typeInfos.areaType, valueType = typeInfos.valueType;
                if (!formatFunctions || !formatFunctions.length) {
                  return values;
                }
                return values.map(function(value) {
                  return renderUtil.formatValue({
                    value,
                    formatFunctions,
                    chartType,
                    areaType,
                    valueType
                  });
                });
              },
              /**
               * Format date.
               * @param {string | number | date} value - value
               * @param {string} format - date format
               * @returns {string}
               * @memberof module:renderUtil
               */
              formatDate: function formatDate(value) {
                var format = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _const2["default"].DEFAULT_DATE_FORMAT;
                var date = (0, _isDate2["default"])(value) ? value : new Date(value);
                return (0, _formatDate2["default"])(format, date) || value;
              },
              /**
               * Format dates.
               * @param {Array.<string | number | date>} values - values
               * @param {string} format - date format
               * @returns {Array}
               * @memberof module:renderUtil
               */
              formatDates: function formatDates(values) {
                var _this = this;
                var format = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _const2["default"].DEFAULT_DATE_FORMAT;
                return values.map(function(value) {
                  return _this.formatDate(value, format);
                });
              },
              /**
               * Cancel animation
               * @param {{id: number}} animation animaion object
               * @memberof module:renderUtil
               */
              cancelAnimation: function cancelAnimation(animation) {
                if (animation && animation.id) {
                  cancelAnimationFrame(animation.id);
                  delete animation.id;
                }
              },
              /**
               * Start animation.
               * @param {number} animationTime - animation time
               * @param {function} onAnimation - animation callback function
               * @param {function} onCompleted - completed callback function
               * @returns {{id: number}} requestAnimationFrame id
               * @memberof module:renderUtil
               */
              startAnimation: function startAnimation(animationTime, onAnimation, onCompleted) {
                var animation = {};
                var startTime = (/* @__PURE__ */ new Date()).getTime();
                function animate() {
                  var diffTime = (/* @__PURE__ */ new Date()).getTime() - startTime;
                  var ratio = Math.min(diffTime / animationTime, 1);
                  onAnimation(ratio);
                  if (ratio === 1) {
                    delete animation.id;
                    if (onCompleted) {
                      onCompleted();
                    }
                  } else {
                    animation.id = requestAnimationFrame(animate);
                  }
                }
                animation.id = requestAnimationFrame(animate);
                return animation;
              },
              /**
               * Whether oldBrowser or not.
               * @memberof module:renderUtil
               * @returns {boolean} result boolean
               */
              isOldBrowser: function isOldBrowser() {
                return _isOldBrowser;
              },
              /**
               * Format to zero fill.
               * @param {string} value target value
               * @param {number} len length of result
               * @returns {string} formatted value
               * @private
               */
              formatToZeroFill: function formatToZeroFill(value, len) {
                var zero = "0";
                value = String(value);
                if (value.length >= len) {
                  return value;
                }
                while (value.length < len) {
                  value = zero + value;
                }
                return value;
              },
              /**
               * Format to Decimal.
               * @param {string} value target value
               * @param {number} len length of under decimal point
               * @returns {string} formatted value
               * @memberof module:renderUtil
               */
              formatToDecimal: function formatToDecimal(value, len) {
                var DECIMAL = 10;
                var pow = Math.pow(DECIMAL, len);
                if (len === 0) {
                  return Math.round(value);
                }
                value = Math.round(value * pow) / pow;
                value = parseFloat(value).toFixed(len);
                return value;
              },
              /**
               * Format to Comma.
               * @param {string} value target value
               * @returns {string} formatted value
               * @private
               */
              formatToComma: function formatToComma(value) {
                value = String(value);
                var comma = ",";
                var betweenLen = 3;
                var orgValue = value;
                var sign = value.indexOf("-") > -1 ? "-" : "";
                var underPointValue = "";
                var values = void 0;
                var lastIndex = void 0;
                var formattedValue = void 0;
                if (value.indexOf(".") > -1) {
                  values = value.split(".");
                  value = String(Math.abs(values[0]));
                  underPointValue = "." + values[1];
                } else {
                  value = String(Math.abs(value));
                }
                if (value.length <= betweenLen) {
                  formattedValue = orgValue;
                } else {
                  var _ref4;
                  values = value.split("").reverse();
                  lastIndex = values.length - 1;
                  values = values.map(function(char, index) {
                    var result = [char];
                    if (index < lastIndex && (index + 1) % betweenLen === 0) {
                      result.push(comma);
                    }
                    return result;
                  });
                  formattedValue = sign + (_ref4 = []).concat.apply(_ref4, _toConsumableArray(values)).reverse().join("") + underPointValue;
                }
                return formattedValue;
              },
              /**
               * Make cssText from map.
               * @param {object} cssMap - css map
               * @returns {string}
               * @memberof module:renderUtil
               */
              makeCssTextFromMap: function makeCssTextFromMap(cssMap) {
                return cssMap.map(function(value, name) {
                  return renderUtil.concatStr(name, ":", value);
                }).join(";");
              },
              /**
               * Perse String.
               * @param {string} value - string
               * @returns {string}
               */
              _perseString: function _perseString(value) {
                return typeof value === "string" || typeof value === "number" ? String(value) : "";
              },
              /**
               * Add prefix or suffix to label.
               * @param {array} labels - labels
               * @param {string} prefix - string
               * @param {string} suffix - string
               * @returns {array}
               * @memberof module:renderUtil
               */
              addPrefixSuffix: function addPrefixSuffix(labels) {
                var _this2 = this;
                var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
                var suffix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
                prefix = this._perseString(prefix);
                suffix = this._perseString(suffix);
                if (!(prefix === "" && suffix === "")) {
                  return labels.map(function(label) {
                    return _this2.addPrefixSuffixItem(label, prefix, suffix);
                  });
                }
                return labels;
              },
              /**
               * Add prefix or suffix for one item
               * @param {string} label - labels
               * @param {string} prefix - string
               * @param {string} suffix - string
               * @returns {string}
               * @memberof module:renderUtil
               */
              addPrefixSuffixItem: function addPrefixSuffixItem(label) {
                var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
                var suffix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
                prefix = this._perseString(prefix);
                suffix = this._perseString(suffix);
                return prefix + label + suffix;
              },
              /**
               * Returns element's style value defined at css file
               * @param {HTMLElement} target - Current element
               * @returns {Object} Style object of element
               * @memberof module:renderUtil
               */
              getStyle: function getStyle(target) {
                var computedObj = void 0;
                if (hasComputedStyle) {
                  computedObj = window.getComputedStyle(target, "");
                } else {
                  computedObj = target.currentStyle;
                }
                return computedObj;
              },
              /**
               * Get clip rect id
               * @returns {string} create unique id by line base chart count
               */
              generateClipRectId: function generateClipRectId() {
                var id = CLIP_RECT_ID + lineBaseChartCount;
                lineBaseChartCount += 1;
                return id;
              }
            };
            function setOpacity(elements, iteratee) {
              elements = (0, _isArray2["default"])(elements) ? elements : [elements];
              (0, _forEachArray2["default"])(elements, iteratee);
            }
            function makeCssFilterOpacityString(opacity) {
              return "alpha(opacity=" + opacity * _const2["default"].OLD_BROWSER_OPACITY_100 + ")";
            }
            if (_isOldBrowser) {
              renderUtil.makeOpacityCssText = function(opacity) {
                var cssText = "";
                if ((0, _isExisty2["default"])(opacity)) {
                  var cssOpacityString = makeCssFilterOpacityString(opacity);
                  cssText = ";filter:" + cssOpacityString;
                }
                return cssText;
              };
              renderUtil.setOpacity = function(elements, opacity) {
                var filter = makeCssFilterOpacityString(opacity);
                setOpacity(elements, function(element) {
                  element.style.filter = filter;
                });
              };
            } else {
              renderUtil.makeOpacityCssText = function(opacity) {
                var cssText = "";
                if ((0, _isExisty2["default"])(opacity)) {
                  cssText = ";opacity:" + opacity;
                }
                return cssText;
              };
              renderUtil.setOpacity = function(elements, opacity) {
                setOpacity(elements, function(element) {
                  element.style.opacity = opacity;
                });
              };
            }
            exports2["default"] = renderUtil;
          },
          /* 18 */
          /***/
          function(module2, exports2) {
            "use strict";
            function isDate(obj) {
              return obj instanceof Date;
            }
            module2.exports = isDate;
          },
          /* 19 */
          /***/
          function(module2, exports2) {
            "use strict";
            function isNumber(obj) {
              return typeof obj === "number" || obj instanceof Number;
            }
            module2.exports = isNumber;
          },
          /* 20 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var pick = __webpack_require__(21);
            var isDate = __webpack_require__(18);
            var tokens = /[\\]*YYYY|[\\]*YY|[\\]*MMMM|[\\]*MMM|[\\]*MM|[\\]*M|[\\]*DD|[\\]*D|[\\]*HH|[\\]*H|[\\]*A/gi;
            var MONTH_STR = ["Invalid month", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            var MONTH_DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            var replaceMap = {
              M: function(date) {
                return Number(date.month);
              },
              MM: function(date) {
                var month = date.month;
                return Number(month) < 10 ? "0" + month : month;
              },
              MMM: function(date) {
                return MONTH_STR[Number(date.month)].substr(0, 3);
              },
              MMMM: function(date) {
                return MONTH_STR[Number(date.month)];
              },
              D: function(date) {
                return Number(date.date);
              },
              d: function(date) {
                return replaceMap.D(date);
              },
              DD: function(date) {
                var dayInMonth = date.date;
                return Number(dayInMonth) < 10 ? "0" + dayInMonth : dayInMonth;
              },
              dd: function(date) {
                return replaceMap.DD(date);
              },
              YY: function(date) {
                return Number(date.year) % 100;
              },
              yy: function(date) {
                return replaceMap.YY(date);
              },
              YYYY: function(date) {
                var prefix = "20", year = date.year;
                if (year > 69 && year < 100) {
                  prefix = "19";
                }
                return Number(year) < 100 ? prefix + String(year) : year;
              },
              yyyy: function(date) {
                return replaceMap.YYYY(date);
              },
              A: function(date) {
                return date.meridiem;
              },
              a: function(date) {
                return date.meridiem;
              },
              hh: function(date) {
                var hour = date.hour;
                return Number(hour) < 10 ? "0" + hour : hour;
              },
              HH: function(date) {
                return replaceMap.hh(date);
              },
              h: function(date) {
                return String(Number(date.hour));
              },
              H: function(date) {
                return replaceMap.h(date);
              },
              m: function(date) {
                return String(Number(date.minute));
              },
              mm: function(date) {
                var minute = date.minute;
                return Number(minute) < 10 ? "0" + minute : minute;
              }
            };
            function isValidDate(year, month, date) {
              var isValidYear, isValidMonth, isValid, lastDayInMonth;
              year = Number(year);
              month = Number(month);
              date = Number(date);
              isValidYear = year > -1 && year < 100 || year > 1969 && year < 2070;
              isValidMonth = month > 0 && month < 13;
              if (!isValidYear || !isValidMonth) {
                return false;
              }
              lastDayInMonth = MONTH_DAYS[month];
              if (month === 2 && year % 4 === 0) {
                if (year % 100 !== 0 || year % 400 === 0) {
                  lastDayInMonth = 29;
                }
              }
              isValid = date > 0 && date <= lastDayInMonth;
              return isValid;
            }
            function formatDate(form, date, option) {
              var am = pick(option, "meridiemSet", "AM") || "AM";
              var pm = pick(option, "meridiemSet", "PM") || "PM";
              var meridiem, nDate, resultStr;
              if (isDate(date)) {
                nDate = {
                  year: date.getFullYear(),
                  month: date.getMonth() + 1,
                  date: date.getDate(),
                  hour: date.getHours(),
                  minute: date.getMinutes()
                };
              } else {
                nDate = {
                  year: date.year,
                  month: date.month,
                  date: date.date,
                  hour: date.hour,
                  minute: date.minute
                };
              }
              if (!isValidDate(nDate.year, nDate.month, nDate.date)) {
                return false;
              }
              nDate.meridiem = "";
              if (/([^\\]|^)[aA]\b/.test(form)) {
                meridiem = nDate.hour > 11 ? pm : am;
                if (nDate.hour > 12) {
                  nDate.hour %= 12;
                }
                if (nDate.hour === 0) {
                  nDate.hour = 12;
                }
                nDate.meridiem = meridiem;
              }
              resultStr = form.replace(tokens, function(key) {
                if (key.indexOf("\\") > -1) {
                  return key.replace(/\\/, "");
                }
                return replaceMap[key](nDate) || "";
              });
              return resultStr;
            }
            module2.exports = formatDate;
          },
          /* 21 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var isUndefined = __webpack_require__(14);
            var isNull = __webpack_require__(6);
            function pick(obj, paths) {
              var args = arguments;
              var target = args[0];
              var i = 1;
              var length = args.length;
              for (; i < length; i += 1) {
                if (isUndefined(target) || isNull(target)) {
                  return;
                }
                target = target[args[i]];
              }
              return target;
            }
            module2.exports = pick;
          },
          /* 22 */
          /***/
          function(module2, exports2) {
            "use strict";
            var browser = {
              chrome: false,
              firefox: false,
              safari: false,
              msie: false,
              edge: false,
              others: false,
              version: 0
            };
            if (window && window.navigator) {
              detectBrowser();
            }
            function detectBrowser() {
              var nav = window.navigator;
              var appName = nav.appName.replace(/\s/g, "_");
              var userAgent = nav.userAgent;
              var rIE = /MSIE\s([0-9]+[.0-9]*)/;
              var rIE11 = /Trident.*rv:11\./;
              var rEdge = /Edge\/(\d+)\./;
              var versionRegex = {
                firefox: /Firefox\/(\d+)\./,
                chrome: /Chrome\/(\d+)\./,
                safari: /Version\/([\d.]+).*Safari\/(\d+)/
              };
              var key, tmp;
              var detector = {
                Microsoft_Internet_Explorer: function() {
                  var detectedVersion = userAgent.match(rIE);
                  if (detectedVersion) {
                    browser.msie = true;
                    browser.version = parseFloat(detectedVersion[1]);
                  } else {
                    browser.others = true;
                  }
                },
                Netscape: function() {
                  var detected = false;
                  if (rIE11.exec(userAgent)) {
                    browser.msie = true;
                    browser.version = 11;
                    detected = true;
                  } else if (rEdge.exec(userAgent)) {
                    browser.edge = true;
                    browser.version = userAgent.match(rEdge)[1];
                    detected = true;
                  } else {
                    for (key in versionRegex) {
                      if (versionRegex.hasOwnProperty(key)) {
                        tmp = userAgent.match(versionRegex[key]);
                        if (tmp && tmp.length > 1) {
                          browser[key] = detected = true;
                          browser.version = parseFloat(tmp[1] || 0);
                          break;
                        }
                      }
                    }
                  }
                  if (!detected) {
                    browser.others = true;
                  }
                }
              };
              var fn = detector[appName];
              if (fn) {
                detector[appName]();
              }
            }
            module2.exports = browser;
          },
          /* 23 */
          /***/
          function(module2, exports2) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = {
              /** tui class names
               * @type {string}
               */
              CLASS_NAME_LEGEND_LABEL: "tui-chart-legend-label",
              /** @type {string} */
              CLASS_NAME_LEGEND_CHECKBOX: "tui-chart-legend-checkbox",
              /** @type {string} */
              CLASS_NAME_SERIES_LABEL: "tui-chart-series-label",
              /** @type {string} */
              CLASS_NAME_SERIES_LEGEND: "tui-chart-series-legend",
              /** @type {string} */
              CLASS_NAME_RESET_ZOOM_BTN: "tui-chart-reset-zoom-btn",
              /** @type {string} */
              CLASS_NAME_ZOOM_OUT_BTN: "tui-chart-zoom-out-btn",
              /** @type {string} */
              CLASS_NAME_CHART_EXPORT_MENU_AREA: "tui-chart-chartExportMenu-area",
              /** @type {string} */
              CLASS_NAME_CHART_EXPORT_MENU_ITEM: "tui-chart-chartExportMenu-item",
              /** @type {string} */
              CLASS_NAME_CHART_EXPORT_MENU_BUTTON: "tui-chart-chartExportMenu-button",
              /** @type {string} */
              CLASS_NAME_CHART_EXPORT_MENU_HEAD: "tui-chart-chartExportMenu-head",
              CLASS_NAME_CHART_EXPORT_MENU_BODY: "tui-chart-chartExportMenu-body",
              CLASS_NAME_TOOLTIP_VALUE: "tui-chart-tooltip-value",
              /** @type {string} */
              CLASS_NAME_TOOLTIP_HEAD: "tui-chart-tooltip-head",
              /** @type {string} */
              CLASS_NAME_TOOLTIP_BODY: "tui-chart-tooltip-body",
              /** @type {string} */
              CLASS_NAME_SVG_AUTOSHAPE: "auto-shape-rendering",
              /** chart type
               * @type {string}
               */
              CHART_TYPE_BAR: "bar",
              /** @type {string} */
              CHART_TYPE_COLUMN: "column",
              /** @type {string} */
              CHART_TYPE_LINE: "line",
              /** @type {string} */
              CHART_TYPE_AREA: "area",
              /** @type {string} */
              CHART_TYPE_COMBO: "combo",
              /** @type {string} */
              CHART_TYPE_COLUMN_LINE_COMBO: "columnLineCombo",
              /** @type {string} */
              CHART_TYPE_LINE_SCATTER_COMBO: "lineScatterCombo",
              /** @type {string} */
              CHART_TYPE_LINE_AREA_COMBO: "lineAreaCombo",
              /** @type {string} */
              CHART_TYPE_PIE_DONUT_COMBO: "pieDonutCombo",
              /** @type {string} */
              CHART_TYPE_PIE: "pie",
              /** @type {string} */
              CHART_TYPE_BUBBLE: "bubble",
              /** @type {string} */
              CHART_TYPE_SCATTER: "scatter",
              /** @type {string} */
              CHART_TYPE_HEATMAP: "heatmap",
              /** @type {string} */
              CHART_TYPE_TREEMAP: "treemap",
              /** @type {string} */
              CHART_TYPE_MAP: "map",
              /** @type {string} */
              CHART_TYPE_RADIAL: "radial",
              /** @type {string} */
              CHART_TYPE_BOXPLOT: "boxplot",
              /** @type {string} */
              CHART_TYPE_BULLET: "bullet",
              /** chart padding */
              CHART_PADDING: 10,
              /** chart default width */
              CHART_DEFAULT_WIDTH: 500,
              /** chart default height */
              CHART_DEFAULT_HEIGHT: 400,
              /** overlapping width of xAxis and yAxis */
              OVERLAPPING_WIDTH: 1,
              /** rendered text padding */
              TEXT_PADDING: 2,
              /** series expand size */
              SERIES_EXPAND_SIZE: 10,
              /** series area vertical padding */
              SERIES_AREA_V_PADDING: 10,
              /** series label padding */
              SERIES_LABEL_PADDING: 5,
              /** series event margins for the value zero */
              SERIES_EXTRA_EVENT_AREA_FOR_ZERO: 2,
              /** default font size of title */
              DEFAULT_TITLE_FONT_SIZE: 14,
              /** default font size of axis title */
              DEFAULT_AXIS_TITLE_FONT_SIZE: 10,
              /** default font size of label */
              DEFAULT_LABEL_FONT_SIZE: 12,
              /** default font size of series label */
              DEFAULT_SERIES_LABEL_FONT_SIZE: 11,
              /** default graph plugin
               * @type {string}
               */
              DEFAULT_PLUGIN: "Raphael",
              /** default tick color
               * @type {string}
               */
              DEFAULT_TICK_COLOR: "black",
              /** default theme name
               * @type {string}
               */
              DEFAULT_THEME_NAME: "default",
              MAX_HEIGHT_WORD: "A",
              /** stack type
               * @type {string}
               */
              NORMAL_STACK_TYPE: "normal",
              /** @type {string} */
              PERCENT_STACK_TYPE: "percent",
              /** default stack
               * @type {string}
               */
              DEFAULT_STACK: "___DEFAULT___STACK___",
              /** dummy key
               * @type {string}
               */
              DUMMY_KEY: "___DUMMY___KEY___",
              /** root id of treemap
               * @type {string}
               */
              TREEMAP_ROOT_ID: "___TUI_TREEMAP_ROOT___",
              /** id prefix of treemap
               * @type {string}
               */
              TREEMAP_ID_PREFIX: "___TUI_TREEMAP_ID___",
              /** prefix for caching seriesItems
               * @type {string}
               */
              TREEMAP_DEPTH_KEY_PREFIX: "___TUI_TREEMAP_DEPTH___",
              /** @type {string} */
              TREEMAP_PARENT_KEY_PREFIX: "___TUI_TREEMAP_PARENT___",
              /** @type {string} */
              TREEMAP_LEAF_KEY_PREFIX: "___TUI_TREEMAP_LEAF___",
              /** @type {string} */
              TREEMAP_LIMIT_DEPTH_KEY_PREFIX: "___TUI_TREEMAP_LIMIT_DEPTH___",
              /** default border color for treemap chart
               * @type {string}
               */
              TREEMAP_DEFAULT_BORDER: "#ffffff",
              TREEMAP_DEFAULT_BORDER_WIDTH: 4,
              /** empty axis label */
              EMPTY_AXIS_LABEL: "",
              /** angel */
              ANGLE_85: 85,
              ANGLE_90: 90,
              ANGLE_360: 360,
              /** radian */
              RAD: Math.PI / 180,
              RERENDER_TIME: 700,
              ADDING_DATA_ANIMATION_DURATION: 300,
              /** series label align outer
               * @type {string}
               */
              LABEL_ALIGN_OUTER: "outer",
              /** @type {string} */
              LEGEND_ALIGN_TOP: "top",
              /** @type {string} */
              LEGEND_ALIGN_BOTTOM: "bottom",
              /** @type {string} */
              LEGEND_ALIGN_LEFT: "left",
              /** @type {number} */
              LEGEND_PAGINATION_BUTTON_WIDTH: 20,
              /** @type {number} */
              LEGEND_PAGINATION_BUTTON_PADDING_RIGHT: 6,
              /** series outer label padding */
              SERIES_OUTER_LABEL_PADDING: 20,
              /** default ratio for pie graph */
              PIE_GRAPH_DEFAULT_RATIO: 0.9,
              /** small ratio for pie graph */
              PIE_GRAPH_SMALL_RATIO: 0.75,
              /** pie chart legend label size */
              PIE_GRAPH_LEGEND_LABEL_SIZE: 16,
              /** pie chart legend label size */
              PIE_GRAPH_LEGEND_LABEL_INTERVAL: 20,
              /** tick count for spectrum legend */
              SPECTRUM_LEGEND_TICK_COUNT: 4,
              /** legend & lable concat separator */
              LABEL_SEPARATOR: "\n",
              /** default position ratio of map chart label
               * @type {object}
               */
              MAP_CHART_LABEL_DEFAULT_POSITION_RATIO: {
                x: 0.5,
                y: 0.5
              },
              /** map chart zoom area width */
              MAP_CHART_ZOOM_AREA_WIDTH: 24,
              /** map chart zoom area height */
              MAP_CHART_ZOOM_AREA_HEIGHT: 58,
              /** dot radius */
              DOT_RADIUS: 4,
              /** radius for circle of scatter chart*/
              SCATTER_RADIUS: 7,
              /**
               * theme properties
               * @type {{yAxis: Array.<string>, series: Array.<string>}}
               */
              THEME_PROPS_MAP: {
                yAxis: ["tickColor", "title", "label"],
                series: ["label", "colors", "borderColor", "borderWidth", "selectionColor", "startColor", "endColor", "overColor", "dot", "ranges"]
              },
              /** title area width padding */
              TITLE_AREA_WIDTH_PADDING: 20,
              /** chart export menu width, height */
              CHART_EXPORT_MENU_SIZE: 24,
              /** top margin of x axis label */
              XAXIS_LABEL_TOP_MARGIN: 10,
              /** right padding of vertical label */
              V_LABEL_RIGHT_PADDING: 10,
              /** tooltip prefix
               * @type {string}
               */
              TOOLTIP_PREFIX: "tui-chart-tooltip",
              /** tooltip z-index **/
              TOOLTIP_ZINDEX: 500,
              /** tooltip animation time */
              TOOLTIP_ANIMATION_TIME: 10,
              /** tooltip animation time for pie chart */
              TOOLTIP_PIE_ANIMATION_TIME: 50,
              /** minimum pixel type step size */
              MIN_PIXEL_TYPE_STEP_SIZE: 45,
              /** maximum pixel type step size */
              MAX_PIXEL_TYPE_STEP_SIZE: 65,
              /** axis scale for percent stack option
               * @type {object}
               */
              PERCENT_STACKED_AXIS_SCALE: {
                limit: {
                  min: 0,
                  max: 100
                },
                step: 25,
                labels: [0, 25, 50, 75, 100]
              },
              /** axis scale for minus percent stack option
               * @type {object}
               */
              MINUS_PERCENT_STACKED_AXIS_SCALE: {
                limit: {
                  min: -100,
                  max: 0
                },
                step: 25,
                labels: [0, -25, -50, -75, -100]
              },
              /** axis scale of dual percent stack option
               * @type {object}
               */
              DUAL_PERCENT_STACKED_AXIS_SCALE: {
                limit: {
                  min: -100,
                  max: 100
                },
                step: 25,
                labels: [-100, -75, -50, -25, 0, 25, 50, 75, 100]
              },
              /** axis scale of diverging percent stack option
               * @type {object}
               */
              DIVERGING_PERCENT_STACKED_AXIS_SCALE: {
                limit: {
                  min: -100,
                  max: 100
                },
                step: 25,
                labels: [100, 75, 50, 25, 0, 25, 50, 75, 100]
              },
              /**
               * datetime axis type
               * @type {string}
               */
              AXIS_TYPE_DATETIME: "datetime",
              /**
               * default dateFormat
               * @type {string}
               */
              DEFAULT_DATE_FORMAT: "YYYY.MM.DD hh:mm:dd",
              /**
               * date type
               * @type {string}
               */
              DATE_TYPE_YEAR: "year",
              DATE_TYPE_MONTH: "month",
              DATE_TYPE_WEEK: "week",
              DATE_TYPE_DATE: "date",
              DATE_TYPE_HOUR: "hour",
              DATE_TYPE_MINUTE: "minute",
              DATE_TYPE_SECOND: "second",
              /** title add padding */
              TITLE_PADDING: 20,
              TITLE_ALIGN_CENTER: "center",
              TITLE_ALIGN_RIGHT: "right",
              TITLE_ALIGN_LEFT: "left",
              /** default header height */
              DEFAULT_HEADER_HEIGHT: 10,
              /** legend area horizontal padding */
              LEGEND_AREA_H_PADDING: 15,
              /** legend area vertical padding */
              LEGEND_AREA_V_PADDING: 7,
              /** legend checkbox width */
              LEGEND_CHECKBOX_SIZE: 14,
              LEGEND_ICON_WIDTH: 10,
              LEGEND_ICON_HEIGHT: 10,
              /** lgend label left padding */
              LEGEND_LABEL_LEFT_PADDING: 8,
              /** vertical legend right padding */
              LEGEND_V_LABEL_RIGHT_PADDING: 20,
              /** horizontal legend right padding */
              LEGEND_H_LABEL_RIGHT_PADDING: 25,
              /** lgend line icon svg path */
              LEGEND_LINE_ICON_PATH: "M1,9 L1,3 C1,1.8954305 1.8954305,1 3,1 L3,1 C4.1045695,1 5,1.8954305 5,3 L5,7 C5,8.1045695 5.8954305,9 7,9 L7,9 C8.1045695,9 9,8.1045695 9,7 L9,1",
              MIN_LEGEND_WIDTH: 100,
              /** map legend area padding */
              MAP_LEGEND_AREA_PADDING_WIDE: 22,
              /** vertical map legend area padding */
              VERTICAL_MAP_LEGEND_AREA_TOP_PADDING: 26,
              /** map legend padding before spectrum graph area */
              MAP_LEGEND_AREA_PADDING_NARROW: 10,
              /** map legend tooltip vertical padding */
              MAP_LEGEND_TOOLTIP_VERTICAL_PADDING: 4,
              /** map legend tooltip horizontal padding */
              MAP_LEGEND_TOOLTIP_HORIZONTAL_PADDING: 6,
              /** map legend wedge size */
              MAP_LEGEND_WEDGE_SIZE: 4,
              /** map legend padding between wedge and spectrum graph */
              MAP_LEGEND_PADDING_BTW_GRAPH_AND_WEDGE: 4,
              /** vertical map legend height */
              VERTICAL_MAP_LEGEND_HEIGHT: 320,
              /** horizontal map legend height */
              HORIZONTAL_MAP_LEGEND_WIDTH: 400,
              /** map legend graph size */
              MAP_LEGEND_GRAPH_SIZE: 6,
              /** map legend label padding */
              MAP_LEGEND_LABEL_PADDING: 5,
              CIRCLE_LEGEND_LABEL_FONT_SIZE: 9,
              CIRCLE_LEGEND_PADDING: 10,
              HALF_RATIO: 0.5,
              AXIS_BACKGROUND_RIGHT_PADDING: 4,
              /** X-AXIS LABEL PADDING */
              X_AXIS_LABEL_PADDING: 7,
              /** X-AXIS title padding */
              X_AXIS_TITLE_PADDING: 5,
              /** Y-AXIS LABEL PADDING */
              Y_AXIS_LABEL_PADDING: 17,
              Y_AXIS_TITLE_PADDING: 7,
              /** rotations degree candidates */
              DEGREE_CANDIDATES: [25, 45, 65, 85],
              /**
               * auto tick interval
               * @type {string}
               */
              TICK_INTERVAL_AUTO: "auto",
              /** yAxis align option
               * @type {string}
               */
              YAXIS_ALIGN_CENTER: "center",
              /** xAxis label gutter */
              XAXIS_LABEL_GUTTER: 2,
              /**
               * Standard multiple nums of axis
               * @type {Array}
               */
              AXIS_STANDARD_MULTIPLE_NUMS: [1, 2, 5, 10, 20, 50, 100],
              /**
               * Last standard multiple num of axis
               */
              AXIS_LAST_STANDARD_MULTIPLE_NUM: 100,
              AXIS_EDGE_RATIO: 8,
              /** label padding top */
              LABEL_PADDING_TOP: 7,
              /** line margin top */
              LINE_MARGIN_TOP: 14,
              /** tooltip gap */
              TOOLTIP_GAP: 5,
              /** tooltip direction
               * @type {string}
               */
              TOOLTIP_DIRECTION_FORWARD: "forword",
              /** @type {string} */
              TOOLTIP_DIRECTION_CENTER: "center",
              /** @type {string} */
              TOOLTIP_DIRECTION_BACKWARD: "backword",
              /** tooltip align options
               * @type {string}
               */
              TOOLTIP_DEFAULT_ALIGN_OPTION: "center top",
              /** @type {string} */
              TOOLTIP_DEFAULT_HORIZONTAL_ALIGN_OPTION: "right middle",
              /** @type {string} */
              TOOLTIP_DEFAULT_GROUP_ALIGN_OPTION: "right middle",
              /** @type {string} */
              TOOLTIP_DEFAULT_GROUP_HORIZONTAL_ALIGN_OPTION: "center bottom",
              /** hide delay */
              HIDE_DELAY: 200,
              OLD_BROWSER_OPACITY_100: 100,
              SERIES_LABEL_OPACITY: 0.3,
              WHEEL_TICK: 120,
              MAX_ZOOM_MAGN: 5,
              ZOOM_POSITION_TOP_EXIST_TITLE: 5,
              ZOOM_POSITION_TOP_NONE_TITLE: 1,
              FF_WHEELDELTA_ADJUSTING_VALUE: -40,
              /** prefix for public event
               * @type {string}
               */
              PUBLIC_EVENT_PREFIX: "public_",
              /** public event map
               * @type {object}
               */
              PUBLIC_EVENT_MAP: {
                load: true,
                selectLegend: true,
                selectSeries: true,
                unselectSeries: true,
                beforeShowTooltip: true,
                afterShowTooltip: true,
                beforeHideTooltip: true,
                changeCheckedLegends: true,
                zoom: true
              },
              /** for radial */
              RADIAL_PLOT_PADDING: 15,
              // Prevent cross paper boundaries by line width
              RADIAL_MARGIN_FOR_CATEGORY: 60,
              RADIAL_CATEGORY_PADDING: 20,
              COMPONENT_TYPE_DOM: "DOM",
              COMPONENT_TYPE_RAPHAEL: "Raphael",
              IMAGE_EXTENSIONS: ["png", "jpeg"],
              DATA_EXTENSIONS: ["xls", "csv"],
              GUIDE_AREACHART_AREAOPACITY_TYPE: "areaOpacity should be a number between 0 and 1",
              /** for bullet */
              BULLET_TYPE_ACTUAL: "Actual",
              BULLET_TYPE_RANGE: "Ranges",
              BULLET_TYPE_MARKER: "Markers",
              BULLET_MARKER_STROKE_TICK: 3,
              BULLET_MARKER_BUFFER_POSITION: 5,
              BULLET_RANGES_HEIGHT_RATIO: 0.7,
              BULLET_ACTUAL_HEIGHT_RATIO: 0.28,
              BULLET_MARKERS_HEIGHT_RATIO: 0.55,
              BULLET_MARKER_DETECT_PADDING: 3
            };
          },
          /* 24 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isArray = __webpack_require__(9);
            var _isArray2 = _interopRequireDefault(_isArray);
            var _isString = __webpack_require__(25);
            var _isString2 = _interopRequireDefault(_isString);
            var _inArray = __webpack_require__(26);
            var _inArray2 = _interopRequireDefault(_inArray);
            var _forEachArray = __webpack_require__(10);
            var _forEachArray2 = _interopRequireDefault(_forEachArray);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _toConsumableArray(arr) {
              if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              } else {
                return Array.from(arr);
              }
            }
            exports2["default"] = {
              /**
               * Create element.
               * @memberOf module:domHandler
               * @param {string} tag html tag
               * @param {string} newClass class name
               * @returns {HTMLElement} created element
               */
              create: function create(tag, newClass) {
                var el = document.createElement(tag);
                if (newClass) {
                  this.addClass(el, newClass);
                }
                return el;
              },
              /**
               * Get class names.
               * @memberOf module:domHandler
               * @param {HTMLElement} el target element
               * @returns {Array} names
               * @private
               */
              _getClassNames: function _getClassNames(el) {
                var className = void 0;
                var classNames = void 0;
                if (el.classList) {
                  classNames = [].concat(_toConsumableArray(el.classList));
                } else {
                  className = el.className || "";
                  classNames = className && (0, _isString2["default"])(className) ? className.split(" ") : [];
                }
                return classNames;
              },
              /**
               * Add css class to target element.
               * @memberOf module:domHandler
               * @param {HTMLElement} el target element
               * @param {string} newClass add class name
               */
              addClass: function addClass(el, newClass) {
                if (!el || !newClass) {
                  return;
                }
                var classNames = this._getClassNames(el);
                var index = (0, _inArray2["default"])(newClass, classNames);
                if (index > -1) {
                  return;
                }
                classNames.push(newClass);
                el.className = classNames.join(" ");
              },
              /**
               * Remove css class from target element.
               * @memberOf module:domHandler
               * @param {HTMLElement} el target element
               * @param {string} rmClass remove class name
               */
              removeClass: function removeClass(el, rmClass) {
                var classNames = this._getClassNames(el);
                var index = (0, _inArray2["default"])(rmClass, classNames);
                if (index === -1) {
                  return;
                }
                classNames.splice(index, 1);
                el.className = classNames.join(" ");
              },
              /**
               * Whether class exist or not.
               * @memberOf module:domHandler
               * @param {HTMLElement} el target element
               * @param {string} findClass target css class
               * @returns {boolean} has class
               */
              hasClass: function hasClass(el, findClass) {
                var classNames = this._getClassNames(el);
                var index = (0, _inArray2["default"])(findClass, classNames);
                return index > -1;
              },
              /**
               * Find parent by class name.
               * @memberOf module:domHandler
               * @param {HTMLElement} el target element
               * @param {string} className target css class
               * @param {string} lastClass last css class
               * @returns {HTMLElement} result element
               */
              findParentByClass: function findParentByClass(el, className, lastClass) {
                var parent = el.parentNode;
                var result = void 0;
                if (!parent) {
                  result = null;
                } else if (this.hasClass(parent, className)) {
                  result = parent;
                } else if (parent.nodeName === "BODY" || this.hasClass(parent, lastClass)) {
                  result = null;
                } else {
                  result = this.findParentByClass(parent, className, lastClass);
                }
                return result;
              },
              /**
               * Append child element.
               * @memberOf module:domHandler
               * @param {HTMLElement} container container element
               * @param {HTMLElement} children child element
               */
              append: function append(container, children) {
                if (!container || !children) {
                  return;
                }
                children = (0, _isArray2["default"])(children) ? children : [children];
                (0, _forEachArray2["default"])(children, function(child) {
                  if (!child) {
                    return;
                  }
                  container.appendChild(child);
                });
              }
            };
          },
          /* 25 */
          /***/
          function(module2, exports2) {
            "use strict";
            function isString(obj) {
              return typeof obj === "string" || obj instanceof String;
            }
            module2.exports = isString;
          },
          /* 26 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var isArray = __webpack_require__(9);
            function inArray(searchElement, array, startIndex) {
              var i;
              var length;
              startIndex = startIndex || 0;
              if (!isArray(array)) {
                return -1;
              }
              if (Array.prototype.indexOf) {
                return Array.prototype.indexOf.call(array, searchElement, startIndex);
              }
              length = array.length;
              for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
                if (array[i] === searchElement) {
                  return i;
                }
              }
              return -1;
            }
            module2.exports = inArray;
          },
          /* 27 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _isBoolean = __webpack_require__(28);
            var _isBoolean2 = _interopRequireDefault(_isBoolean);
            var _inArray = __webpack_require__(26);
            var _inArray2 = _interopRequireDefault(_inArray);
            var _forEach = __webpack_require__(8);
            var _forEach2 = _interopRequireDefault(_forEach);
            var _forEachArray = __webpack_require__(10);
            var _forEachArray2 = _interopRequireDefault(_forEachArray);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _toConsumableArray(arr) {
              if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              } else {
                return Array.from(arr);
              }
            }
            function min(arr, condition, context) {
              var result = void 0;
              if (!condition) {
                result = Math.min.apply(Math, _toConsumableArray(arr));
              } else {
                var _arr = _slicedToArray(arr, 1);
                result = _arr[0];
                var rest = arr.slice(1);
                var minValue = condition.call(context, result, 0);
                rest.forEach(function(item, index) {
                  var compareValue = condition.call(context, item, index + 1);
                  if (compareValue < minValue) {
                    minValue = compareValue;
                    result = item;
                  }
                });
              }
              return result;
            }
            function max(arr, condition, context) {
              var result = void 0;
              if (!condition) {
                result = Math.max.apply(Math, _toConsumableArray(arr));
              } else {
                var _arr2 = _slicedToArray(arr, 1);
                result = _arr2[0];
                var rest = arr.slice(1);
                var maxValue = condition.call(context, result, 0);
                (0, _forEachArray2["default"])(rest, function(item, index) {
                  var compareValue = condition.call(context, item, index + 1);
                  if (compareValue > maxValue) {
                    maxValue = compareValue;
                    result = item;
                  }
                });
              }
              return result;
            }
            function any(collection, condition, context) {
              var result = false;
              (0, _forEach2["default"])(collection, function(item, key) {
                if (condition.call(context, item, key, collection)) {
                  result = true;
                }
                return !result;
              });
              return result;
            }
            function all(collection, condition, context) {
              var result = !!(collection || []).length;
              (0, _forEach2["default"])(collection, function(item, key) {
                if (!condition.call(context, item, key, collection)) {
                  result = false;
                }
                return result !== false;
              });
              return result;
            }
            function unique(arr, sorted, iteratee, context) {
              var result = [];
              if (!(0, _isBoolean2["default"])(sorted)) {
                context = iteratee;
                iteratee = sorted;
                sorted = false;
              }
              iteratee = iteratee || function(value) {
                return value;
              };
              if (sorted) {
                var prevValue = void 0;
                (0, _forEachArray2["default"])(arr, function(value, index) {
                  value = iteratee.call(context, value, index, arr);
                  if (!index || prevValue !== value) {
                    result.push(value);
                  }
                  prevValue = value;
                });
              } else {
                (0, _forEachArray2["default"])(arr, function(value, index) {
                  value = iteratee.call(context, value, index, arr);
                  if ((0, _inArray2["default"])(value, result) === -1) {
                    result.push(value);
                  }
                });
              }
              return result;
            }
            function pivot(arr2d) {
              var result = [];
              var len = max(arr2d.map(function(arr) {
                return arr.length;
              }));
              arr2d.forEach(function(arr) {
                for (var index = 0; index < len; index += 1) {
                  if (!result[index]) {
                    result[index] = [];
                  }
                  result[index].push(arr[index]);
                }
              });
              return result;
            }
            function findIndexFromDateTypeArray(dateArray, date) {
              var dateValue = Number(date);
              var foundIndex = -1;
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = void 0;
              try {
                for (var _iterator = dateArray.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var _step$value = _slicedToArray(_step.value, 2), idx = _step$value[0], value = _step$value[1];
                  if (Number(value) === dateValue) {
                    foundIndex = idx;
                    break;
                  }
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }
              return foundIndex;
            }
            exports2["default"] = {
              min,
              max,
              any,
              all,
              unique,
              pivot,
              findIndexFromDateTypeArray
            };
          },
          /* 28 */
          /***/
          function(module2, exports2) {
            "use strict";
            function isBoolean(obj) {
              return typeof obj === "boolean" || obj instanceof Boolean;
            }
            module2.exports = isBoolean;
          },
          /* 29 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _templateObject = _taggedTemplateLiteral(["\n            M", ",", "\n            V", "\n        "], ["\n            M", ",", "\n            V", "\n        "]);
            var _raphael = __webpack_require__(4);
            var _raphael2 = _interopRequireDefault(_raphael);
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _isNumber = __webpack_require__(19);
            var _isNumber2 = _interopRequireDefault(_isNumber);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _taggedTemplateLiteral(strings, raw) {
              return Object.freeze(Object.defineProperties(strings, {
                raw: {
                  value: Object.freeze(raw)
                }
              }));
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var EMPHASIS_OPACITY = 1;
            var DE_EMPHASIS_OPACITY = 0.3;
            var DEFAULT_LUMINANC = 0.2;
            var EDGE_LINE_WIDTH = 1;
            var MEDIAN_LINE_WIDTH = 1;
            var WHISKER_LINE_WIDTH = 1;
            var RaphaelBoxplotChart = function() {
              function RaphaelBoxplotChart2() {
                _classCallCheck(this, RaphaelBoxplotChart2);
              }
              RaphaelBoxplotChart2.prototype.render = function render(paper, data) {
                var groupBounds = data.groupBounds;
                if (!groupBounds) {
                  return null;
                }
                this.paper = paper;
                this.theme = data.theme;
                this.options = data.options;
                this.seriesDataModel = data.seriesDataModel;
                this.chartType = data.chartType;
                this.animationDuration = data.options.animationDuration;
                this.paper.setStart();
                this.groupWhiskers = [];
                this.groupMedians = [];
                this.groupBoxes = this._renderBoxplots(groupBounds);
                this.groupBorders = this._renderBoxBorders(groupBounds);
                this.circleOverlay = this._renderCircleOverlay();
                this.groupBounds = groupBounds;
                return this.paper.setFinish();
              };
              RaphaelBoxplotChart2.prototype._renderCircleOverlay = function _renderCircleOverlay() {
                var position = {
                  left: 0,
                  top: 0
                };
                var attributes = {
                  "fill-opacity": 0
                };
                return _raphaelRenderUtil2["default"].renderCircle(this.paper, position, 0, Object.assign({
                  "stroke-width": 0
                }, attributes));
              };
              RaphaelBoxplotChart2.prototype._renderBox = function _renderBox(bound, color, attributes) {
                if (bound.width < 0 || bound.height < 0) {
                  return null;
                }
                var rect = _raphaelRenderUtil2["default"].renderRect(this.paper, bound, Object.assign({
                  fill: color,
                  stroke: "none"
                }, attributes));
                return rect;
              };
              RaphaelBoxplotChart2.prototype._renderBoxes = function _renderBoxes(groupBounds) {
                var _this = this;
                var colors = this.theme.colors;
                var colorByPoint = this.options.colorByPoint;
                return groupBounds.map(function(bounds, groupIndex) {
                  return bounds.map(function(bound, index) {
                    if (!bound) {
                      return null;
                    }
                    var item = _this.seriesDataModel.getSeriesItem(groupIndex, index);
                    var color = colorByPoint ? colors[groupIndex] : colors[index];
                    var boundStart = _this.animationDuration ? bound.start : bound.end;
                    var rect = void 0;
                    if (boundStart) {
                      rect = _this._renderBox(boundStart, color);
                    }
                    return {
                      rect,
                      color,
                      bound: bound.end,
                      item,
                      groupIndex,
                      index
                    };
                  });
                });
              };
              RaphaelBoxplotChart2.prototype._renderBoxplots = function _renderBoxplots(groupBounds) {
                var groupBoxes = this._renderBoxes(groupBounds);
                this.groupWhiskers = this._renderWhiskers(groupBounds);
                this.groupMedians = this._renderMedianLines(groupBounds);
                this.groupOutliers = this._renderOutliers(groupBounds);
                return groupBoxes;
              };
              RaphaelBoxplotChart2.prototype._renderWhisker = function _renderWhisker(end, start, color) {
                var paper = this.paper, animationDuration = this.animationDuration;
                var topDistance = start.top - end.top;
                var whiskerDirection = topDistance > 0 ? 1 : -1;
                var left = end.left, width = end.width;
                var quartileWidth = width / 4;
                var edgePath = "M" + (left + quartileWidth) + "," + end.top + "H" + (left + quartileWidth * 3);
                var whiskerPath = _renderUtil2["default"].oneLineTrim(_templateObject, left + quartileWidth * 2, end.top, end.top + Math.abs(topDistance) * whiskerDirection);
                var edge = _raphaelRenderUtil2["default"].renderLine(paper, edgePath, {
                  color,
                  strokeWidth: EDGE_LINE_WIDTH
                });
                var whisker = _raphaelRenderUtil2["default"].renderLine(paper, whiskerPath, {
                  color,
                  strokeWidth: WHISKER_LINE_WIDTH
                });
                var whiskers = [];
                edge.attr({
                  opacity: animationDuration ? 0 : 1
                });
                whisker.attr({
                  opacity: animationDuration ? 0 : 1
                });
                whiskers.push(edge);
                whiskers.push(whisker);
                return whiskers;
              };
              RaphaelBoxplotChart2.prototype._renderWhiskers = function _renderWhiskers(groupBounds) {
                var _this2 = this;
                var colors = this.theme.colors;
                var colorByPoint = this.options.colorByPoint;
                var groupWhiskers = [];
                groupBounds.forEach(function(bounds, groupIndex) {
                  var whiskers = [];
                  bounds.forEach(function(bound, index) {
                    var color = colorByPoint ? colors[groupIndex] : colors[index];
                    if (!bound) {
                      return;
                    }
                    whiskers = whiskers.concat(_this2._renderWhisker(bound.min, bound.start, color));
                    whiskers = whiskers.concat(_this2._renderWhisker(bound.max, bound.end, color));
                  });
                  groupWhiskers.push(whiskers);
                });
                return groupWhiskers;
              };
              RaphaelBoxplotChart2.prototype._renderMedianLine = function _renderMedianLine(bound) {
                var width = bound.width;
                var medianLinePath = "M" + bound.left + "," + bound.top + ",H" + (bound.left + width);
                var median = _raphaelRenderUtil2["default"].renderLine(this.paper, medianLinePath, {
                  color: "#fff",
                  strokeWidth: MEDIAN_LINE_WIDTH
                });
                median.attr({
                  opacity: this.animationDuration ? 0 : 1
                });
                return median;
              };
              RaphaelBoxplotChart2.prototype._renderMedianLines = function _renderMedianLines(groupBounds) {
                var _this3 = this;
                var groupMedians = [];
                groupBounds.forEach(function(bounds) {
                  var medians = [];
                  bounds.forEach(function(bound) {
                    if (!bound) {
                      return;
                    }
                    medians.push(_this3._renderMedianLine(bound.median));
                  });
                  groupMedians.push(medians);
                });
                return groupMedians;
              };
              RaphaelBoxplotChart2.prototype._renderOutlier = function _renderOutlier(bound, color) {
                var outlier = _raphaelRenderUtil2["default"].renderCircle(this.paper, {
                  left: bound.left,
                  top: bound.top
                }, 3.5, {
                  stroke: color,
                  "stroke-width": 2
                });
                outlier.attr({
                  opacity: this.animationDuration ? 0 : 1
                });
                return outlier;
              };
              RaphaelBoxplotChart2.prototype._renderOutliers = function _renderOutliers(groupBounds) {
                var _this4 = this;
                var colors = this.theme.colors;
                var colorByPoint = this.options.colorByPoint;
                var groupOutliers = [];
                groupBounds.forEach(function(bounds, groupIndex) {
                  var outliers = [];
                  bounds.forEach(function(bound, index) {
                    var color = colorByPoint ? colors[groupIndex] : colors[index];
                    var seriesOutliers = [];
                    if (!bound) {
                      return;
                    }
                    if (bound.outliers.length) {
                      bound.outliers.forEach(function(outlier) {
                        seriesOutliers.push(_this4._renderOutlier(outlier, color));
                      });
                    }
                    outliers.push(seriesOutliers);
                  });
                  groupOutliers.push(outliers);
                });
                return groupOutliers;
              };
              RaphaelBoxplotChart2.prototype._makeRectPoints = function _makeRectPoints(bound) {
                return {
                  leftTop: {
                    left: Math.ceil(bound.left),
                    top: Math.ceil(bound.top)
                  },
                  rightTop: {
                    left: Math.ceil(bound.left + bound.width),
                    top: Math.ceil(bound.top)
                  },
                  rightBottom: {
                    left: Math.ceil(bound.left + bound.width),
                    top: Math.ceil(bound.top + bound.height)
                  },
                  leftBottom: {
                    left: Math.ceil(bound.left),
                    top: Math.ceil(bound.top + bound.height)
                  }
                };
              };
              RaphaelBoxplotChart2.prototype._renderBorderLines = function _renderBorderLines(bound, borderColor, chartType, item) {
                var _this5 = this;
                var borderLinePaths = this._makeBorderLinesPaths(bound, chartType, item);
                var lines = {};
                Object.entries(borderLinePaths).forEach(function(_ref) {
                  var _ref2 = _slicedToArray(_ref, 2), name = _ref2[0], path = _ref2[1];
                  lines[name] = _raphaelRenderUtil2["default"].renderLine(_this5.paper, path, {
                    color: borderColor,
                    strokeWidth: 1
                  });
                });
                return lines;
              };
              RaphaelBoxplotChart2.prototype._renderBoxBorders = function _renderBoxBorders(groupBounds) {
                var _this6 = this;
                var borderColor = this.theme.borderColor;
                if (!borderColor) {
                  return null;
                }
                return groupBounds.map(function(bounds, groupIndex) {
                  return bounds.map(function(bound, index) {
                    if (!bound) {
                      return null;
                    }
                    var seriesItem = _this6.seriesDataModel.getSeriesItem(groupIndex, index);
                    return _this6._renderBorderLines(bound.start, borderColor, _this6.chartType, seriesItem);
                  });
                });
              };
              RaphaelBoxplotChart2.prototype._animateRect = function _animateRect(rect, bound, duration) {
                rect.animate({
                  x: bound.left,
                  y: bound.top,
                  width: bound.width,
                  height: bound.height
                }, duration, ">");
              };
              RaphaelBoxplotChart2.prototype.animate = function animate(onFinish) {
                var _this7 = this;
                if (this.animationDuration) {
                  var animation = _raphael2["default"].animation({
                    opacity: 1
                  }, this.animationDuration);
                  _raphaelRenderUtil2["default"].forEach2dArray(this.groupBoxes, function(box) {
                    if (!box) {
                      return;
                    }
                    _this7._animateRect(box.rect, box.bound, _this7.animationDuration);
                  });
                  _raphaelRenderUtil2["default"].forEach2dArray(this.groupWhiskers, function(whisker) {
                    whisker.animate(animation.delay(_this7.animationDuration));
                  });
                  _raphaelRenderUtil2["default"].forEach2dArray(this.groupMedians, function(median) {
                    median.animate(animation.delay(_this7.animationDuration));
                  });
                  _raphaelRenderUtil2["default"].forEach2dArray(this.groupOutliers, function(outliers) {
                    outliers.forEach(function(outlier) {
                      outlier.animate(animation.delay(_this7.animationDuration));
                    });
                  });
                  if (onFinish) {
                    this.callbackTimeout = setTimeout(function() {
                      onFinish();
                      delete _this7.callbackTimeout;
                    }, this.animationDuration);
                  }
                }
              };
              RaphaelBoxplotChart2.prototype.showAnimation = function showAnimation(data) {
                if ((0, _isNumber2["default"])(data.outlierIndex)) {
                  this.showOutlierAnimation(data);
                } else {
                  this.showRectAnimation(data);
                }
              };
              RaphaelBoxplotChart2.prototype.showRectAnimation = function showRectAnimation(data) {
                var bar = this.groupBoxes[data.groupIndex][data.index];
                this.hoveredBar = bar.rect;
                this.hoveredBar.attr({
                  stroke: "#ffffff",
                  "stroke-width": 4
                });
                this.hoveredBar.node.setAttribute("filter", "url(#shadow)");
              };
              RaphaelBoxplotChart2.prototype.showOutlierAnimation = function showOutlierAnimation(data) {
                var targetAttr = this.groupOutliers[data.groupIndex][data.index][data.outlierIndex].attr();
                this.circleOverlay.attr({
                  r: targetAttr.r,
                  cx: targetAttr.cx,
                  cy: targetAttr.cy,
                  fill: targetAttr.stroke,
                  "fill-opacity": 1,
                  stroke: targetAttr.stroke,
                  "stroke-width": 4
                });
              };
              RaphaelBoxplotChart2.prototype.hideAnimation = function hideAnimation() {
                this.circleOverlay.attr({
                  width: 1,
                  height: 1,
                  x: 0,
                  y: 0,
                  "fill-opacity": 0,
                  "stroke-width": 2
                });
                this.hoveredBar.attr({
                  stroke: "none"
                });
                this.hoveredBar.node.setAttribute("filter", "none");
              };
              RaphaelBoxplotChart2.prototype._updateRectBound = function _updateRectBound(rect, bound) {
                rect.attr({
                  x: bound.left,
                  y: bound.top,
                  width: bound.width,
                  height: bound.height
                });
              };
              RaphaelBoxplotChart2.prototype.resize = function resize(params) {
                var dimension = params.dimension, groupBounds = params.groupBounds;
                this.groupBounds = groupBounds;
                this.paper.setSize(dimension.width, dimension.height);
                _raphaelRenderUtil2["default"].forEach2dArray(this.groupBoxes, function(bar, groupIndex, index) {
                  if (!bar) {
                    return;
                  }
                  var bound = groupBounds[groupIndex][index].end;
                  bar.bound = bound;
                  _raphaelRenderUtil2["default"].updateRectBound(bar.rect, bound);
                });
              };
              RaphaelBoxplotChart2.prototype._changeBordersColor = function _changeBordersColor(lines, borderColor) {
                lines.forEach(function(line) {
                  line.attr({
                    stroke: borderColor
                  });
                });
              };
              RaphaelBoxplotChart2.prototype._changeBoxColor = function _changeBoxColor(indexes, color, borderColor) {
                var bar = this.groupBoxes[indexes.groupIndex][indexes.index];
                bar.rect.attr({
                  stroke: color
                });
                if (borderColor) {
                  var lines = this.groupBorders[indexes.groupIndex][indexes.index];
                  this._changeBordersColor(lines, borderColor);
                }
              };
              RaphaelBoxplotChart2.prototype.selectSeries = function selectSeries(indexes) {
                var bar = this.groupBoxes[indexes.groupIndex][indexes.index];
                var objColor = _raphael2["default"].color(bar.color);
                var selectionColorTheme = this.theme.selectionColor;
                var makeColor = _raphaelRenderUtil2["default"].makeChangedLuminanceColor;
                var color = selectionColorTheme || makeColor(objColor.hex, DEFAULT_LUMINANC);
                var borderColor = this.theme.borderColor;
                if (borderColor) {
                  var objBorderColor = _raphael2["default"].color(borderColor);
                  borderColor = _raphaelRenderUtil2["default"].makeChangedLuminanceColor(objBorderColor.hex, DEFAULT_LUMINANC);
                }
                this._changeBoxColor(indexes, color, borderColor);
              };
              RaphaelBoxplotChart2.prototype.unselectSeries = function unselectSeries(indexes) {
                var bar = this.groupBoxes[indexes.groupIndex][indexes.index];
                var borderColor = this.theme.borderColor;
                this._changeBoxColor(indexes, bar.color, borderColor);
              };
              RaphaelBoxplotChart2.prototype.selectLegend = function selectLegend(legendIndex) {
                var noneSelected = (0, _isNull2["default"])(legendIndex);
                _raphaelRenderUtil2["default"].forEach2dArray(this.groupBoxes, function(box, groupIndex, index) {
                  if (!box) {
                    return;
                  }
                  var opacity = noneSelected || legendIndex === index ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
                  box.rect.attr({
                    "stroke-opacity": opacity
                  });
                });
                _raphaelRenderUtil2["default"].forEach2dArray(this.groupWhiskers, function(whisker, groupIndex, index) {
                  var opacity = noneSelected || legendIndex === index ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
                  whisker.attr({
                    "stroke-opacity": opacity
                  });
                });
                _raphaelRenderUtil2["default"].forEach2dArray(this.groupMedians, function(median, groupIndex, index) {
                  var opacity = noneSelected || legendIndex === index ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
                  median.attr({
                    "stroke-opacity": opacity
                  });
                });
              };
              RaphaelBoxplotChart2.prototype.renderSeriesLabel = function renderSeriesLabel(paper, groupPositions, groupLabels, labelTheme, isStacked) {
                var attributes = {
                  "font-size": labelTheme.fontSize,
                  "font-family": labelTheme.fontFamily,
                  "font-weight": labelTheme.fontWeight,
                  fill: labelTheme.color,
                  opacity: 0,
                  "text-anchor": isStacked ? "middle" : "start"
                };
                var labelSet = paper.set();
                groupLabels.forEach(function(categoryLabel, categoryIndex) {
                  categoryLabel.forEach(function(label, seriesIndex) {
                    var position = groupPositions[categoryIndex][seriesIndex];
                    var endLabel = _raphaelRenderUtil2["default"].renderText(paper, position.end, label.end, attributes);
                    endLabel.node.style.userSelect = "none";
                    endLabel.node.style.cursor = "default";
                    endLabel.node.setAttribute("filter", "url(#glow)");
                    labelSet.push(endLabel);
                    if (position.start) {
                      var startLabel = _raphaelRenderUtil2["default"].renderText(paper, position.start, label.start, attributes);
                      startLabel.node.style.userSelect = "none";
                      startLabel.node.style.cursor = "default";
                      startLabel.node.setAttribute("filter", "url(#glow)");
                      labelSet.push(startLabel);
                    }
                  });
                });
                return labelSet;
              };
              return RaphaelBoxplotChart2;
            }();
            exports2["default"] = RaphaelBoxplotChart;
          },
          /* 30 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _browser = __webpack_require__(22);
            var _browser2 = _interopRequireDefault(_browser);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var IS_LTE_IE8 = _browser2["default"].msie && _browser2["default"].version <= 8;
            var EMPHASIS_OPACITY = 1;
            var DE_EMPHASIS_OPACITY = 0.3;
            var EVENT_DETECTOR_PADDING = 20;
            var RaphaelBulletChart = function() {
              function RaphaelBulletChart2() {
                _classCallCheck(this, RaphaelBulletChart2);
              }
              RaphaelBulletChart2.prototype.render = function render(paper, data) {
                var groupBounds = data.groupBounds, seriesDataModel = data.seriesDataModel;
                if (!groupBounds || !groupBounds.length) {
                  return null;
                }
                this.paper = paper;
                this.theme = data.theme;
                this.dimension = data.dimension;
                this.position = data.position;
                this.options = data.options;
                this.chartType = data.chartType;
                this.isVertical = data.isVertical;
                this.animationDuration = data.options.animationDuration;
                this.seriesDataModel = seriesDataModel;
                this.maxRangeCount = seriesDataModel.maxRangeCount;
                this.maxMarkerCount = seriesDataModel.maxMarkerCount;
                this._graphColors = [];
                this.rangeOpacities = {};
                this.paper.setStart();
                this._renderBounds(groupBounds);
                return this.paper.setFinish();
              };
              RaphaelBulletChart2.prototype._getRangeOpacity = function _getRangeOpacity(index) {
                var maxRangeCount = this.maxRangeCount;
                if (this.prevMaxRangeCount !== maxRangeCount) {
                  this._updateOpacityStep(maxRangeCount);
                }
                if (index < maxRangeCount && !this.rangeOpacities[index]) {
                  this.rangeOpacities[index] = 1 - this.opacityStep * (index + 1);
                }
                return this.rangeOpacities[index];
              };
              RaphaelBulletChart2.prototype._updateOpacityStep = function _updateOpacityStep(maxRangeCount) {
                this.rangeOpacities = {};
                this.opacityStep = Number(1 / (maxRangeCount + 1)).toFixed(2);
                this.prevMaxRangeCount = maxRangeCount;
              };
              RaphaelBulletChart2.prototype._renderBounds = function _renderBounds(groupBounds) {
                var _this = this;
                var rangeThemes = this.theme.ranges;
                var paper = this.paper;
                this.groupBars = [];
                this.groupLines = [];
                groupBounds.forEach(function(bounds, groupIndex) {
                  var seriesColor = _this.theme.colors[groupIndex];
                  var rangeIndex = 0;
                  var barSet = paper.set();
                  var lineSet = paper.set();
                  bounds.forEach(function(bound) {
                    var type = bound.type;
                    if (type === _const2["default"].BULLET_TYPE_ACTUAL) {
                      barSet.push(_this._renderActual(bound, seriesColor));
                    } else if (type === _const2["default"].BULLET_TYPE_RANGE) {
                      barSet.push(_this._renderRange(bound, seriesColor, rangeIndex, rangeThemes[rangeIndex]));
                      rangeIndex += 1;
                    } else if (type === _const2["default"].BULLET_TYPE_MARKER) {
                      lineSet.push(_this._renderMarker(bound, seriesColor));
                    }
                  });
                  _this.groupBars.push(barSet);
                  _this.groupLines.push(lineSet);
                }, this);
              };
              RaphaelBulletChart2.prototype._renderActual = function _renderActual(bound, seriesColor) {
                if (!bound) {
                  return null;
                }
                return this._renderBar(bound, seriesColor);
              };
              RaphaelBulletChart2.prototype._renderRange = function _renderRange(bound, seriesColor, rangeIndex, rangeTheme) {
                var opacity = this._getRangeOpacity(rangeIndex);
                var attr = {
                  opacity
                };
                var color = seriesColor;
                if (!bound) {
                  return null;
                }
                if (rangeTheme) {
                  color = rangeTheme.color || color;
                  attr.opacity = rangeTheme.opacity || opacity;
                }
                return this._renderBar(bound, color, attr);
              };
              RaphaelBulletChart2.prototype._renderBar = function _renderBar(bound, color, attributes) {
                if (bound.width < 0 || bound.height < 0) {
                  return null;
                }
                return _raphaelRenderUtil2["default"].renderRect(this.paper, bound, Object.assign({
                  fill: color,
                  stroke: "none"
                }, attributes));
              };
              RaphaelBulletChart2.prototype._renderMarker = function _renderMarker(bound, seriesColor) {
                if (!bound) {
                  return null;
                }
                return this._renderLine(bound, seriesColor);
              };
              RaphaelBulletChart2.prototype._renderLine = function _renderLine(bound, color) {
                var top = bound.top, left = bound.left, length = bound.length;
                var endPosition = this.isVertical ? "L" + (left + length) + "," + top : "L" + left + "," + (top + length);
                var path = "M" + left + "," + (top + endPosition);
                return _raphaelRenderUtil2["default"].renderLine(this.paper, path, {
                  color,
                  strokeWidth: _const2["default"].BULLET_MARKER_STROKE_TICK
                });
              };
              RaphaelBulletChart2.prototype.animate = function animate(onFinish, seriesSet) {
                var _this2 = this;
                var paper = this.paper, dimension = this.dimension, position = this.position, animationDuration = this.animationDuration;
                var clipRectId = this._getClipRectId();
                var clipRectWidth = dimension.width - EVENT_DETECTOR_PADDING;
                var clipRectHeight = dimension.height - EVENT_DETECTOR_PADDING;
                var startDimension = {};
                var animateAttr = {};
                var clipRect = this.clipRect;
                if (this.isVertical) {
                  startDimension.width = clipRectWidth;
                  startDimension.height = animationDuration ? 0 : clipRectHeight;
                  animateAttr.height = clipRectHeight;
                } else {
                  startDimension.width = animationDuration ? 0 : clipRectWidth;
                  startDimension.height = clipRectHeight;
                  animateAttr.width = clipRectWidth;
                }
                if (!IS_LTE_IE8 && dimension) {
                  if (!clipRect) {
                    clipRect = createClipPathRectWithLayout(paper, position, startDimension, clipRectId);
                    this.clipRect = clipRect;
                  } else {
                    clipRect.attr({
                      x: position.left,
                      y: position.top
                    });
                    clipRect.attr(startDimension);
                  }
                  seriesSet.forEach(function(element) {
                    if (element.type === "set") {
                      element.forEach(function(item) {
                        item.node.setAttribute("clip-path", "url(#" + clipRectId + ")");
                      });
                    } else {
                      element.node.setAttribute("clip-path", "url(#" + clipRectId + ")");
                    }
                  });
                  if (animationDuration) {
                    clipRect.animate(animateAttr, animationDuration, ">", onFinish);
                  }
                }
                if (onFinish) {
                  this.callbackTimeout = setTimeout(function() {
                    onFinish();
                    delete _this2.callbackTimeout;
                  }, animationDuration);
                }
              };
              RaphaelBulletChart2.prototype.resize = function resize(params) {
                var dimension = params.dimension, groupBounds = params.groupBounds;
                var width = dimension.width, height = dimension.height;
                this.dimension = params.dimension;
                this.groupBounds = groupBounds;
                this.resizeClipRect(width, height);
                this.paper.setSize(width, height);
              };
              RaphaelBulletChart2.prototype.resizeClipRect = function resizeClipRect(width, height) {
                var clipRect = this.paper.getById(this._getClipRectId() + "_rect");
                if (clipRect) {
                  clipRect.attr({
                    width,
                    height
                  });
                }
              };
              RaphaelBulletChart2.prototype._getClipRectId = function _getClipRectId() {
                if (!this.clipRectId) {
                  this.clipRectId = _renderUtil2["default"].generateClipRectId();
                }
                return this.clipRectId;
              };
              RaphaelBulletChart2.prototype._changeBordersColor = function _changeBordersColor(lines, borderColor) {
                lines.forEach(function(line) {
                  line.attr({
                    stroke: borderColor
                  });
                });
              };
              RaphaelBulletChart2.prototype.selectLegend = function selectLegend(legendIndex) {
                var _this3 = this;
                var allEmphasized = (0, _isNull2["default"])(legendIndex);
                this.groupBars.forEach(function(bars, groupIndex) {
                  var opacity = allEmphasized || legendIndex === groupIndex ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
                  _this3.groupBars[groupIndex].attr({
                    "fill-opacity": opacity
                  });
                  _this3.groupLabels[groupIndex].attr({
                    opacity
                  });
                  _this3.groupLabels[groupIndex].forEach(function(label) {
                    label.attr({
                      opacity
                    });
                  });
                });
              };
              RaphaelBulletChart2.prototype.renderSeriesLabel = function renderSeriesLabel(paper, positionData, labelData, labelTheme) {
                var _this4 = this;
                var attributes = {
                  "font-size": labelTheme.fontSize,
                  "font-family": labelTheme.fontFamily,
                  "font-weight": labelTheme.fontWeight,
                  fill: labelTheme.color,
                  opacity: 0,
                  "text-anchor": this.isVertical ? "middle" : "start"
                };
                var set = paper.set();
                this.groupLabels = labelData.map(function(labels, groupIndex) {
                  var labelSet = paper.set();
                  labels.forEach(function(label, index) {
                    var labelElement = _this4._renderLabel(paper, positionData[groupIndex][index], attributes, label);
                    labelSet.push(labelElement);
                    set.push(labelElement);
                  });
                  return labelSet;
                }, this);
                return set;
              };
              RaphaelBulletChart2.prototype._renderLabel = function _renderLabel(paper, position, attributes, labelText) {
                var label = _raphaelRenderUtil2["default"].renderText(paper, position, labelText, attributes);
                var node = label.node;
                var style = node.style;
                style.userSelect = "none";
                style.cursor = "default";
                node.setAttribute("filter", "url(#glow)");
                return label;
              };
              RaphaelBulletChart2.prototype.getGraphColors = function getGraphColors() {
                var _this5 = this;
                if (!this._graphColors.length) {
                  this._graphColors = this.groupBars.map(function(barSet, groupIndex) {
                    var barColors = [];
                    var markerCount = _this5.groupLines[groupIndex].length;
                    barSet.forEach(function(item) {
                      barColors.push(item.attrs.fill);
                    });
                    var legendColor = barColors[barColors.length - 1];
                    for (var i = 0; i <= markerCount; i += 1) {
                      barColors.push(legendColor);
                    }
                    return barColors;
                  });
                }
                return this._graphColors;
              };
              return RaphaelBulletChart2;
            }();
            function createClipPathRectWithLayout(paper, position, dimension, id) {
              var clipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
              var rect = paper.rect(position.left, position.top, dimension.width, dimension.height);
              rect.id = id + "_rect";
              clipPath.id = id;
              clipPath.appendChild(rect.node);
              paper.defs.appendChild(clipPath);
              return rect;
            }
            exports2["default"] = RaphaelBulletChart;
          },
          /* 31 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _isNumber = __webpack_require__(19);
            var _isNumber2 = _interopRequireDefault(_isNumber);
            var _raphaelLineTypeBase = __webpack_require__(32);
            var _raphaelLineTypeBase2 = _interopRequireDefault(_raphaelLineTypeBase);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var EMPHASIS_OPACITY = 1;
            var DE_EMPHASIS_OPACITY = 0.3;
            var RaphaelLineChart = function(_RaphaelLineBase) {
              _inherits(RaphaelLineChart2, _RaphaelLineBase);
              function RaphaelLineChart2() {
                _classCallCheck(this, RaphaelLineChart2);
                var _this = _possibleConstructorReturn(this, _RaphaelLineBase.call(this));
                _this.selectedLegendIndex = null;
                _this.chartType = "line";
                _this.lineWidth = 6;
                return _this;
              }
              RaphaelLineChart2.prototype.render = function render(paper, data) {
                var dimension = data.dimension, groupPositions = data.groupPositions, theme = data.theme, options = data.options, position = data.position;
                var colors = theme.colors;
                var opacity = options.showDot ? 1 : 0;
                var isSpline = options.spline;
                var lineWidth = this.lineWidth = (0, _isNumber2["default"])(options.pointWidth) ? options.pointWidth : this.lineWidth;
                var borderStyle = this.makeBorderStyle(theme.dot.strokeColor, opacity, theme.dot.strokeWidth);
                var outDotStyle = this.makeOutDotStyle(opacity, borderStyle);
                var groupPaths = void 0;
                if (isSpline) {
                  groupPaths = this._getSplineLinesPath(groupPositions, options.connectNulls);
                } else {
                  groupPaths = this._getLinesPath(groupPositions, options.connectNulls);
                }
                this.paper = paper;
                this.theme = theme;
                this.isSpline = isSpline;
                this.dimension = dimension;
                this.position = position;
                paper.setStart();
                this.groupLines = this._renderLines(paper, groupPaths, colors, lineWidth);
                this.tooltipLine = this._renderTooltipLine(paper, dimension.height);
                this.groupDots = this._renderDots(paper, groupPositions, colors, opacity);
                if (options.allowSelect) {
                  this.selectionDot = this._makeSelectionDot(paper);
                  this.selectionColor = theme.selectionColor;
                }
                this.colors = colors;
                this.borderStyle = borderStyle;
                this.outDotStyle = outDotStyle;
                this.groupPositions = groupPositions;
                this.groupPaths = groupPaths;
                this.dotOpacity = opacity;
                this.animationDuration = options.animationDuration;
                delete this.pivotGroupDots;
                if (paper.raphael.svg) {
                  this.appendShadowFilterToDefs();
                }
                return paper.setFinish();
              };
              RaphaelLineChart2.prototype.appendShadowFilterToDefs = function appendShadowFilterToDefs() {
                var filter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
                var feOffset = document.createElementNS("http://www.w3.org/2000/svg", "feOffset");
                var feGaussianBlur = document.createElementNS("http://www.w3.org/2000/svg", "feGaussianBlur");
                var feBlend = document.createElementNS("http://www.w3.org/2000/svg", "feBlend");
                filter.setAttributeNS(null, "id", "shadow");
                filter.setAttributeNS(null, "x", "-50%");
                filter.setAttributeNS(null, "y", "-50%");
                filter.setAttributeNS(null, "width", "180%");
                filter.setAttributeNS(null, "height", "180%");
                feOffset.setAttributeNS(null, "result", "offOut");
                feOffset.setAttributeNS(null, "in", "SourceAlpha");
                feOffset.setAttributeNS(null, "dx", "0");
                feOffset.setAttributeNS(null, "dy", "0");
                feGaussianBlur.setAttributeNS(null, "result", "blurOut");
                feGaussianBlur.setAttributeNS(null, "in", "offOut");
                feGaussianBlur.setAttributeNS(null, "stdDeviation", "2");
                feBlend.setAttributeNS(null, "in", "SourceGraphic");
                feBlend.setAttributeNS(null, "in2", "blurOut");
                feBlend.setAttributeNS(null, "mode", "normal");
                filter.appendChild(feOffset);
                filter.appendChild(feGaussianBlur);
                filter.appendChild(feBlend);
                this.paper.defs.appendChild(filter);
              };
              RaphaelLineChart2.prototype._getLinesPath = function _getLinesPath(groupPositions, connectNulls) {
                var _this2 = this;
                return groupPositions.map(function(positions) {
                  return _this2._makeLinesPath(positions, null, connectNulls);
                });
              };
              RaphaelLineChart2.prototype._getSplineLinesPath = function _getSplineLinesPath(groupPositions, connectNulls) {
                var _this3 = this;
                return groupPositions.map(function(positions) {
                  return _this3._makeSplineLinesPath(positions, {
                    connectNulls
                  });
                });
              };
              RaphaelLineChart2.prototype._renderLines = function _renderLines(paper, groupPaths, colors, strokeWidth) {
                return groupPaths.map(function(path, groupIndex) {
                  var color = colors[groupIndex] || "transparent";
                  var line = _raphaelRenderUtil2["default"].renderLine(paper, path.join(" "), {
                    color,
                    strokeWidth
                  });
                  line.node.setAttribute("class", "auto-shape-rendering");
                  return line;
                });
              };
              RaphaelLineChart2.prototype.resize = function resize(params) {
                var _this4 = this;
                var dimension = params.dimension, groupPositions = params.groupPositions;
                this.resizeClipRect(dimension.width, dimension.height);
                this.groupPositions = groupPositions;
                this.groupPaths = this.isSpline ? this._getSplineLinesPath(groupPositions) : this._getLinesPath(groupPositions);
                this.paper.setSize(dimension.width, dimension.height);
                this.tooltipLine.attr({
                  top: dimension.height
                });
                this.groupPaths.forEach(function(path, groupIndex) {
                  _this4.groupLines[groupIndex].attr({
                    path: path.join(" ")
                  });
                  _this4.groupDots[groupIndex].forEach(function(item, index) {
                    if (item.endDot) {
                      _this4._moveDot(item.endDot.dot, groupPositions[groupIndex][index]);
                    }
                  });
                });
              };
              RaphaelLineChart2.prototype.selectLegend = function selectLegend(legendIndex) {
                var _this5 = this;
                var noneSelected = (0, _isNull2["default"])(legendIndex);
                if (this.selectedLegendIndex && this.selectedLegendIndex !== -1) {
                  this.resetSeriesOrder(this.selectedLegendIndex);
                }
                this.selectedLegendIndex = legendIndex;
                this.groupLines.forEach(function(line, groupIndex) {
                  var isSelectedLegend = legendIndex === groupIndex;
                  var opacity = noneSelected || isSelectedLegend ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
                  var groupDots = _this5.groupDots[groupIndex];
                  line.attr({
                    "stroke-opacity": opacity
                  });
                  if (isSelectedLegend) {
                    _this5.moveSeriesToFront(line, groupDots);
                  }
                });
                if (noneSelected) {
                  this.groupLines.forEach(function(line, groupIndex) {
                    _this5.moveSeriesToFront(line, _this5.groupDots[groupIndex]);
                  });
                }
              };
              RaphaelLineChart2.prototype.resetSeriesOrder = function resetSeriesOrder(legendIndex) {
                var frontLine = legendIndex + 1 < this.groupLines.length ? this.groupLines[legendIndex + 1] : null;
                if (frontLine) {
                  this.groupLines[legendIndex].insertBefore(frontLine);
                  this.groupDots[legendIndex].forEach(function(item) {
                    if (item && item.endDot) {
                      item.endDot.dot.insertBefore(frontLine);
                    }
                  });
                }
              };
              RaphaelLineChart2.prototype.moveSeriesToFront = function moveSeriesToFront(lineType, dots) {
                lineType.toFront();
                dots.forEach(function(item) {
                  item.endDot.dot.toFront();
                });
              };
              RaphaelLineChart2.prototype.animateForAddingData = function animateForAddingData(data, tickSize, groupPositions, shiftingOption) {
                var _this6 = this;
                var isSpline = data.options.spline;
                var groupPaths = isSpline ? this._getSplineLinesPath(groupPositions) : this._getLinesPath(groupPositions);
                var additionalIndex = 0;
                if (!groupPositions.length) {
                  return;
                }
                if (shiftingOption) {
                  additionalIndex = 1;
                }
                this.groupLines.forEach(function(line, groupIndex) {
                  var dots = _this6.groupDots[groupIndex];
                  var groupPosition = groupPositions[groupIndex];
                  if (shiftingOption) {
                    _this6._removeFirstDot(dots);
                  }
                  dots.forEach(function(item, index) {
                    var position = groupPosition[index + additionalIndex];
                    _this6._animateByPosition(item.endDot.dot, position, tickSize);
                  });
                  _this6._animateByPath(line, groupPaths[groupIndex], tickSize);
                });
              };
              RaphaelLineChart2.prototype.renderSeriesLabel = function renderSeriesLabel(paper, groupPositions, groupLabels, labelTheme) {
                var attributes = {
                  "font-size": labelTheme.fontSize,
                  "font-family": labelTheme.fontFamily,
                  "font-weight": labelTheme.fontWeight,
                  fill: labelTheme.color,
                  "text-anchor": "middle",
                  opacity: 0
                };
                var set = paper.set();
                groupLabels.forEach(function(categoryLabel, categoryIndex) {
                  categoryLabel.forEach(function(label, seriesIndex) {
                    var position = groupPositions[categoryIndex][seriesIndex];
                    var endLabel = _raphaelRenderUtil2["default"].renderText(paper, position.end, label.end, attributes);
                    set.push(endLabel);
                    endLabel.node.style.userSelect = "none";
                    endLabel.node.style.cursor = "default";
                    endLabel.node.setAttribute("filter", "url(#glow)");
                    if (position.start) {
                      var startLabel = _raphaelRenderUtil2["default"].renderText(paper, position.start, label.start, attributes);
                      startLabel.node.style.userSelect = "none";
                      startLabel.node.style.cursor = "default";
                      startLabel.node.setAttribute("filter", "url(#glow)");
                      set.push(startLabel);
                    }
                  });
                });
                return set;
              };
              return RaphaelLineChart2;
            }(_raphaelLineTypeBase2["default"]);
            exports2["default"] = RaphaelLineChart;
          },
          /* 32 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _browser = __webpack_require__(22);
            var _browser2 = _interopRequireDefault(_browser);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _isNumber = __webpack_require__(19);
            var _isNumber2 = _interopRequireDefault(_isNumber);
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _toConsumableArray(arr) {
              if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              } else {
                return Array.from(arr);
              }
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var IS_LTE_IE8 = _browser2["default"].msie && _browser2["default"].version <= 8;
            var DEFAULT_DOT_RADIUS = 6;
            var SELECTION_DOT_RADIUS = 7;
            var DE_EMPHASIS_OPACITY = 0.3;
            var MOVING_ANIMATION_DURATION = 300;
            var CHART_HOVER_STATUS_OVER = "over";
            var CHART_HOVER_STATUS_OUT = "out";
            var RaphaelLineTypeBase = function() {
              function RaphaelLineTypeBase2() {
                _classCallCheck(this, RaphaelLineTypeBase2);
              }
              RaphaelLineTypeBase2.prototype._makeLinesPath = function _makeLinesPath(positions, posTopType, connectNulls) {
                var _ref;
                var path = [];
                var prevMissing = false;
                posTopType = posTopType || "top";
                [].concat(positions).forEach(function(position) {
                  var pathCommand = prevMissing && !connectNulls ? "M" : "L";
                  if (position) {
                    path.push([pathCommand, position.left, position[posTopType]]);
                    if (prevMissing) {
                      prevMissing = false;
                    }
                  } else {
                    prevMissing = true;
                  }
                });
                path = (_ref = []).concat.apply(_ref, _toConsumableArray(path));
                if (path.length > 0) {
                  path[0] = "M";
                }
                return path;
              };
              RaphaelLineTypeBase2.prototype._getAnchor = function _getAnchor(fromPos, pos, nextPos, isReverseDirection) {
                var l1 = (pos.left - fromPos.left) / 2;
                var l2 = (nextPos.left - pos.left) / 2;
                var a = void 0, b = void 0;
                if (isReverseDirection) {
                  a = Math.atan((fromPos.left - pos.left) / Math.abs(fromPos.top - pos.top));
                  b = Math.atan((pos.left - nextPos.left) / Math.abs(nextPos.top - pos.top));
                } else {
                  a = Math.atan((pos.left - fromPos.left) / Math.abs(pos.top - fromPos.top));
                  b = Math.atan((nextPos.left - pos.left) / Math.abs(pos.top - nextPos.top));
                }
                a = fromPos.top < pos.top ? Math.PI - a : a;
                b = nextPos.top < pos.top ? Math.PI - b : b;
                var alpha = Math.PI / 2 - (a + b) % (Math.PI * 2) / 2;
                var dx1 = l1 * Math.sin(alpha + a);
                var dy1 = l1 * Math.cos(alpha + a);
                var dx2 = l2 * Math.sin(alpha + b);
                var dy2 = l2 * Math.cos(alpha + b);
                var result = {
                  x1: pos.left - dx1,
                  y1: pos.top + dy1,
                  x2: pos.left + dx2,
                  y2: pos.top + dy2
                };
                if (isReverseDirection) {
                  result.y1 = pos.top - dy1;
                  result.y2 = pos.top - dy2;
                }
                return result;
              };
              RaphaelLineTypeBase2.prototype._getSplinePositionsGroups = function _getSplinePositionsGroups(positions, connectNulls) {
                var positionsGroups = [];
                var positionsGroup = [];
                positions.forEach(function(position, index) {
                  var isLastIndex = index === positions.length - 1;
                  if (position) {
                    positionsGroup.push(position);
                  }
                  if (!position && positionsGroup.length > 0 && !connectNulls || isLastIndex) {
                    positionsGroups.push(positionsGroup);
                    positionsGroup = [];
                  }
                });
                return positionsGroups;
              };
              RaphaelLineTypeBase2.prototype._getSplinePartialPaths = function _getSplinePartialPaths(positionsGroups, isReverseDirection) {
                var _this = this;
                var paths = [];
                var lastPos = void 0, positionsLen = void 0, fromPos = void 0, middlePositions = void 0, path = void 0;
                positionsGroups.forEach(function(dataPositions) {
                  var _dataPositions = _slicedToArray(dataPositions, 1), prevPos = _dataPositions[0];
                  var firstPos = prevPos;
                  positionsLen = dataPositions.length;
                  fromPos = firstPos;
                  lastPos = dataPositions[positionsLen - 1];
                  middlePositions = dataPositions.slice(1).slice(0, positionsLen - 2);
                  path = middlePositions.map(function(position, index) {
                    var nextPos = dataPositions[index + 2];
                    var anchor = _this._getAnchor(fromPos, position, nextPos, isReverseDirection);
                    fromPos = position;
                    if (Math.abs(anchor.y1 - prevPos.top) > Math.abs(prevPos.top - position.top)) {
                      anchor.y1 = position.top;
                    }
                    if (Math.abs(anchor.y2 - nextPos.top) > Math.abs(nextPos.top - position.top)) {
                      anchor.y2 = position.top;
                    }
                    prevPos = position;
                    return [anchor.x1, anchor.y1, position.left, position.top, anchor.x2, anchor.y2];
                  });
                  path.push([lastPos.left, lastPos.top, lastPos.left, lastPos.top]);
                  path.unshift(["M", firstPos.left, firstPos.top, "C", firstPos.left, firstPos.top]);
                  paths.push(path);
                });
                return paths;
              };
              RaphaelLineTypeBase2.prototype._makeSplineLinesPath = function _makeSplineLinesPath(positions) {
                var makeLineOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var positionsGroups = this._getSplinePositionsGroups(positions, makeLineOptions.connectNulls);
                var partialPaths = this._getSplinePartialPaths(positionsGroups, makeLineOptions.isReverseDirection);
                var path = [];
                partialPaths.forEach(function(partialPath) {
                  path = path.concat(partialPath);
                });
                if (makeLineOptions.isBeConnected) {
                  path[0] = path[0].slice(3);
                }
                return path;
              };
              RaphaelLineTypeBase2.prototype._renderTooltipLine = function _renderTooltipLine(paper, height) {
                var linePath = _raphaelRenderUtil2["default"].makeLinePath({
                  left: 10,
                  top: height
                }, {
                  left: 10,
                  top: 0
                });
                return _raphaelRenderUtil2["default"].renderLine(paper, linePath, {
                  color: "transparent",
                  strokeWidth: 1
                });
              };
              RaphaelLineTypeBase2.prototype.appendShadowFilterToDefs = function appendShadowFilterToDefs() {
                var filter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
                var feOffset = document.createElementNS("http://www.w3.org/2000/svg", "feOffset");
                var feGaussianBlur = document.createElementNS("http://www.w3.org/2000/svg", "feGaussianBlur");
                var feBlend = document.createElementNS("http://www.w3.org/2000/svg", "feBlend");
                filter.setAttributeNS(null, "id", "shadow");
                filter.setAttributeNS(null, "x", "-50%");
                filter.setAttributeNS(null, "y", "-50%");
                filter.setAttributeNS(null, "width", "180%");
                filter.setAttributeNS(null, "height", "180%");
                feOffset.setAttributeNS(null, "result", "offOut");
                feOffset.setAttributeNS(null, "in", "SourceAlpha");
                feOffset.setAttributeNS(null, "dx", "0");
                feOffset.setAttributeNS(null, "dy", "0");
                feGaussianBlur.setAttributeNS(null, "result", "blurOut");
                feGaussianBlur.setAttributeNS(null, "in", "offOut");
                feGaussianBlur.setAttributeNS(null, "stdDeviation", "2");
                feBlend.setAttributeNS(null, "in", "SourceGraphic");
                feBlend.setAttributeNS(null, "in2", "blurOut");
                feBlend.setAttributeNS(null, "mode", "normal");
                filter.appendChild(feOffset);
                filter.appendChild(feGaussianBlur);
                filter.appendChild(feBlend);
                this.paper.defs.appendChild(filter);
              };
              RaphaelLineTypeBase2.prototype.makeBorderStyle = function makeBorderStyle(borderColor, opacity, borderWidth) {
                var borderStyle = {
                  "stroke-width": borderWidth,
                  "stroke-opacity": opacity
                };
                if (borderColor) {
                  borderStyle.stroke = borderColor;
                }
                return borderStyle;
              };
              RaphaelLineTypeBase2.prototype.makeOutDotStyle = function makeOutDotStyle(opacity, borderStyle) {
                var outDotStyle = {
                  "fill-opacity": opacity,
                  "stroke-opacity": opacity,
                  r: DEFAULT_DOT_RADIUS
                };
                if (borderStyle) {
                  Object.assign(outDotStyle, borderStyle);
                }
                return outDotStyle;
              };
              RaphaelLineTypeBase2.prototype.renderDot = function renderDot(paper, position, color, opacity) {
                var dotTheme = this.theme && this.theme.dot || {
                  dot: {}
                };
                var raphaelDot = void 0;
                if (position) {
                  var dot = paper.circle(position.left, position.top, !(0, _isUndefined2["default"])(dotTheme.radius) ? dotTheme.radius : DEFAULT_DOT_RADIUS);
                  var dotStyle = {
                    fill: dotTheme.fillColor || color,
                    "fill-opacity": (0, _isNumber2["default"])(opacity) ? opacity : dotTheme.fillOpacity,
                    stroke: dotTheme.strokeColor || color,
                    "stroke-opacity": (0, _isNumber2["default"])(opacity) ? opacity : dotTheme.strokeOpacity,
                    "stroke-width": dotTheme.strokeWidth
                  };
                  dot.attr(dotStyle);
                  raphaelDot = {
                    dot,
                    color
                  };
                }
                return raphaelDot;
              };
              RaphaelLineTypeBase2.prototype._moveDotsToFront = function _moveDotsToFront(dots) {
                _raphaelRenderUtil2["default"].forEach2dArray(dots, function(dotInfo) {
                  dotInfo.endDot.dot.toFront();
                  if (dotInfo.startDot) {
                    dotInfo.startDot.dot.toFront();
                  }
                });
              };
              RaphaelLineTypeBase2.prototype._renderDots = function _renderDots(paper, groupPositions, colors, opacity, seriesSet) {
                var _this2 = this;
                var dots = groupPositions.map(function(positions, groupIndex) {
                  var color = colors[groupIndex];
                  return Object.values(positions).map(function(position) {
                    var dotMap = {
                      endDot: _this2.renderDot(paper, position, color, opacity)
                    };
                    if (_this2.hasRangeData) {
                      var startPosition = Object.assign({}, position);
                      startPosition.top = startPosition.startTop;
                      dotMap.startDot = _this2.renderDot(paper, startPosition, color, opacity);
                    }
                    if (seriesSet) {
                      seriesSet.push(dotMap.endDot.dot);
                      if (dotMap.startDot) {
                        seriesSet.push(dotMap.startDot.dot);
                      }
                    }
                    return dotMap;
                  });
                });
                return dots;
              };
              RaphaelLineTypeBase2.prototype._getCenter = function _getCenter(fromPos, toPos) {
                return {
                  left: (fromPos.left + toPos.left) / 2,
                  top: (fromPos.top + toPos.top) / 2
                };
              };
              RaphaelLineTypeBase2.prototype._showDot = function _showDot(dotInformation, groupIndex) {
                var hoverTheme = this.theme.dot.hover;
                var attributes = {
                  "fill-opacity": hoverTheme.fillOpacity,
                  stroke: hoverTheme.strokeColor || dotInformation.color,
                  "stroke-opacity": hoverTheme.strokeOpacity,
                  "stroke-width": hoverTheme.strokeWidth,
                  r: hoverTheme.radius,
                  filter: "url(#shadow)"
                };
                this._setPrevDotAttributes(groupIndex, dotInformation.dot);
                if (hoverTheme.fillColor) {
                  attributes.fill = hoverTheme.fillColor;
                }
                dotInformation.dot.attr(attributes);
                if (dotInformation.dot.node) {
                  dotInformation.dot.node.setAttribute("filter", "url(#shadow)");
                }
                dotInformation.dot.toFront();
              };
              RaphaelLineTypeBase2.prototype._setPrevDotAttributes = function _setPrevDotAttributes(groupIndex, dot) {
                if (!this._prevDotAttributes) {
                  this._prevDotAttributes = {};
                }
                this._prevDotAttributes[groupIndex] = dot.attr();
              };
              RaphaelLineTypeBase2.prototype._updateLineStrokeOpacity = function _updateLineStrokeOpacity(changeType, line) {
                var opacity = 1;
                var isSelectedLegend = !(0, _isNull2["default"])(this.selectedLegendIndex);
                if (this.groupLines) {
                  if (changeType === CHART_HOVER_STATUS_OVER || isSelectedLegend) {
                    opacity = this.chartType === "radial" && this.showArea ? 0 : DE_EMPHASIS_OPACITY;
                  }
                  if (changeType === CHART_HOVER_STATUS_OUT && isSelectedLegend) {
                    line = this.getLine(this.selectedLegendIndex);
                  }
                  this.groupLines.forEach(function(otherLine) {
                    otherLine.attr({
                      "stroke-opacity": opacity
                    });
                  });
                  line.attr({
                    "stroke-opacity": 1
                  });
                }
              };
              RaphaelLineTypeBase2.prototype.getLine = function getLine(groupIndex) {
                return this.groupLines ? this.groupLines[groupIndex] : this.groupAreas[groupIndex];
              };
              RaphaelLineTypeBase2.prototype._updateAreaOpacity = function _updateAreaOpacity(changeType) {
                if (this.groupAreas) {
                  this.groupAreas.forEach(function(otherArea) {
                    otherArea.area.attr({
                      "fill-opacity": changeType === CHART_HOVER_STATUS_OVER ? DE_EMPHASIS_OPACITY : 1
                    });
                  });
                }
              };
              RaphaelLineTypeBase2.prototype._updateLineStrokeWidth = function _updateLineStrokeWidth(line, strokeWidth) {
                var changeAttr = {
                  "stroke-width": strokeWidth
                };
                if (line.attrs) {
                  changeAttr.stroke = line.attrs.stroke;
                }
                line.attr(changeAttr);
              };
              RaphaelLineTypeBase2.prototype.showAnimation = function showAnimation(data) {
                var groupIndex = data.index;
                var groupDot = this.groupDots[groupIndex];
                var item = this._findDotItem(groupDot, data.groupIndex);
                var line = this.groupLines ? this.groupLines[groupIndex] : this.groupAreas[groupIndex];
                var strokeWidth = void 0, startLine = void 0;
                if (!item) {
                  return;
                }
                if (this.chartType === "area") {
                  var _line = line;
                  startLine = _line.startLine;
                  line = _line.line;
                  strokeWidth = 5;
                  this._updateAreaOpacity(CHART_HOVER_STATUS_OVER);
                } else {
                  strokeWidth = this.lineWidth;
                }
                this._updateLineStrokeOpacity(CHART_HOVER_STATUS_OVER, line);
                this._updateLineStrokeWidth(line, strokeWidth);
                if (startLine) {
                  this._updateLineStrokeWidth(startLine, strokeWidth);
                }
                this._showDot(item.endDot, groupIndex);
                if (item.startDot) {
                  this._showDot(item.startDot, groupIndex);
                }
              };
              RaphaelLineTypeBase2.prototype._findDotItem = function _findDotItem() {
                var groupDot = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                var index = arguments[1];
                var isRadialChart = _predicate2["default"].isRadialChart(this.chartType);
                if (isRadialChart && groupDot.length === index) {
                  index = 0;
                }
                return groupDot[index];
              };
              RaphaelLineTypeBase2.prototype._getPivotGroupDots = function _getPivotGroupDots() {
                if (!this.pivotGroupDots && this.groupDots) {
                  this.pivotGroupDots = _arrayUtil2["default"].pivot(this.groupDots);
                }
                return this.pivotGroupDots;
              };
              RaphaelLineTypeBase2.prototype._showGroupDots = function _showGroupDots(index) {
                var _this3 = this;
                var groupDots = this._getPivotGroupDots();
                if (!groupDots || !groupDots[index]) {
                  return;
                }
                groupDots[index].forEach(function(item, groupIndex) {
                  if (item.endDot) {
                    _this3._showDot(item.endDot, groupIndex);
                  }
                  if (item.startDot) {
                    _this3._showDot(item.startDot, groupIndex);
                  }
                });
              };
              RaphaelLineTypeBase2.prototype.showGroupTooltipLine = function showGroupTooltipLine(bound, layout) {
                var left = Math.max(bound.position.left, 11);
                var linePath = _raphaelRenderUtil2["default"].makeLinePath({
                  left,
                  top: layout.position.top + bound.dimension.height
                }, {
                  left,
                  top: layout.position.top
                });
                if (this.tooltipLine) {
                  this.tooltipLine.attr({
                    path: linePath,
                    stroke: "#999",
                    "stroke-opacity": 1
                  });
                }
              };
              RaphaelLineTypeBase2.prototype.showGroupAnimation = function showGroupAnimation(index) {
                this._showGroupDots(index);
              };
              RaphaelLineTypeBase2.prototype._hideDot = function _hideDot(dot, groupIndex, opacity) {
                var prev = this._prevDotAttributes[groupIndex];
                var outDotStyle = this.outDotStyle;
                if (prev && !(0, _isUndefined2["default"])(opacity)) {
                  outDotStyle = {
                    r: prev.r,
                    stroke: prev.stroke,
                    fill: prev.fill,
                    "stroke-opacity": prev["stroke-opacity"],
                    "stroke-width": prev["stroke-width"],
                    "fill-opacity": prev["fill-opacity"]
                  };
                }
                dot.attr(outDotStyle);
                if (dot.node) {
                  dot.node.setAttribute("filter", "");
                }
                this.resetSeriesOrder(groupIndex);
              };
              RaphaelLineTypeBase2.prototype.hideAnimation = function hideAnimation(data) {
                var index = data.groupIndex;
                var groupIndex = data.index;
                var groupDot = this.groupDots[groupIndex];
                var item = this._findDotItem(groupDot, index);
                var line = void 0, strokeWidth = void 0, startLine = void 0;
                var opacity = this.dotOpacity;
                if (!item) {
                  return;
                }
                line = this.groupLines ? this.groupLines[groupIndex] : this.groupAreas[groupIndex];
                if (this.chartType === "area") {
                  strokeWidth = this.lineWidth;
                  var _line2 = line;
                  startLine = _line2.startLine;
                  line = _line2.line;
                  this._updateAreaOpacity(CHART_HOVER_STATUS_OUT);
                } else {
                  strokeWidth = this.lineWidth;
                }
                if (opacity && !(0, _isNull2["default"])(this.selectedLegendIndex) && this.selectedLegendIndex !== groupIndex) {
                  opacity = DE_EMPHASIS_OPACITY;
                }
                this._updateLineStrokeOpacity(CHART_HOVER_STATUS_OUT, line);
                this._updateLineStrokeWidth(line, strokeWidth);
                if (startLine) {
                  this._updateLineStrokeWidth(startLine, strokeWidth);
                }
                if (item) {
                  this._hideDot(item.endDot.dot, groupIndex, opacity);
                  if (item.startDot) {
                    this._hideDot(item.startDot.dot, groupIndex, opacity);
                  }
                }
              };
              RaphaelLineTypeBase2.prototype._hideGroupDots = function _hideGroupDots(index) {
                var _this4 = this;
                var hasSelectedIndex = !(0, _isNull2["default"])(this.selectedLegendIndex);
                var baseOpacity = this.dotOpacity;
                var groupDots = this._getPivotGroupDots();
                if (!groupDots || !groupDots[index]) {
                  return;
                }
                groupDots[index].forEach(function(item, groupIndex) {
                  var opacity = baseOpacity;
                  if (opacity && hasSelectedIndex && _this4.selectedLegendIndex !== groupIndex) {
                    opacity = DE_EMPHASIS_OPACITY;
                  }
                  if (item.endDot) {
                    _this4._hideDot(item.endDot.dot, groupIndex, opacity);
                  }
                  if (item.startDot) {
                    _this4._hideDot(item.startDot.dot, groupIndex, opacity);
                  }
                });
              };
              RaphaelLineTypeBase2.prototype.hideGroupTooltipLine = function hideGroupTooltipLine() {
                this.tooltipLine.attr({
                  "stroke-opacity": 0
                });
              };
              RaphaelLineTypeBase2.prototype.hideGroupAnimation = function hideGroupAnimation(index) {
                this._hideGroupDots(index);
              };
              RaphaelLineTypeBase2.prototype._moveDot = function _moveDot(dot, position) {
                var dotAttrs = {
                  cx: position.left,
                  cy: position.top
                };
                if (this.dotOpacity) {
                  dotAttrs = Object.assign({
                    "fill-opacity": this.dotOpacity
                  }, dotAttrs, this.borderStyle);
                }
                dot.attr(dotAttrs);
              };
              RaphaelLineTypeBase2.prototype.animate = function animate(onFinish, seriesSet) {
                var paper = this.paper, dimension = this.dimension, position = this.position, animationDuration = this.animationDuration;
                var clipRectId = this._getClipRectId();
                var remakePosition = this._makeClipRectPosition(position);
                var clipRect = this.clipRect;
                if (!IS_LTE_IE8 && dimension) {
                  if (!clipRect) {
                    clipRect = createClipPathRectWithLayout(paper, remakePosition, dimension, clipRectId, !!animationDuration);
                    this.clipRect = clipRect;
                  } else {
                    this._makeClipRectPosition(position);
                    clipRect.attr({
                      width: animationDuration ? 0 : dimension.width,
                      height: dimension.height,
                      x: remakePosition.left,
                      y: remakePosition.top
                    });
                  }
                  seriesSet.forEach(function(seriesElement) {
                    seriesElement.node.setAttribute("clip-path", "url(#" + clipRectId + ")");
                  });
                  if (animationDuration) {
                    clipRect.animate({
                      width: dimension.width
                    }, animationDuration, ">", onFinish);
                  }
                }
              };
              RaphaelLineTypeBase2.prototype._makeClipRectPosition = function _makeClipRectPosition(position) {
                return {
                  left: position.left - _const2["default"].SERIES_EXPAND_SIZE,
                  top: position.top - _const2["default"].SERIES_EXPAND_SIZE
                };
              };
              RaphaelLineTypeBase2.prototype._makeSelectionDot = function _makeSelectionDot(paper) {
                var selectionDot = paper.circle(0, 0, SELECTION_DOT_RADIUS);
                selectionDot.attr({
                  fill: "#ffffff",
                  "fill-opacity": 0,
                  "stroke-opacity": 0,
                  "stroke-width": 2
                });
                return selectionDot;
              };
              RaphaelLineTypeBase2.prototype.selectSeries = function selectSeries(indexes) {
                var item = this.groupDots[indexes.index][indexes.groupIndex];
                var position = this.groupPositions[indexes.index][indexes.groupIndex];
                this.selectedItem = item;
                this.selectionDot.attr({
                  cx: position.left,
                  cy: position.top,
                  "fill-opacity": 0.5,
                  "stroke-opacity": 1,
                  stroke: this.selectionColor || item.endDot.color
                });
                if (this.selectionStartDot) {
                  this.selectionStartDot.attr({
                    cx: position.left,
                    cy: position.startTop,
                    "fill-opacity": 0.5,
                    "stroke-opacity": 1,
                    stroke: this.selectionColor || item.startDot.color
                  });
                }
              };
              RaphaelLineTypeBase2.prototype.unselectSeries = function unselectSeries(indexes) {
                var item = this.groupDots[indexes.index][indexes.groupIndex];
                if (this.selectedItem === item) {
                  this.selectionDot.attr({
                    "fill-opacity": 0,
                    "stroke-opacity": 0
                  });
                }
                if (this.selectionStartDot) {
                  this.selectionStartDot.attr({
                    "fill-opacity": 0,
                    "stroke-opacity": 0
                  });
                }
              };
              RaphaelLineTypeBase2.prototype.setSize = function setSize(width, height) {
                width = width || this.dimension.width;
                height = height || this.dimension.height;
                this.paper.setSize(width, height);
              };
              RaphaelLineTypeBase2.prototype._animateByPosition = function _animateByPosition(raphaelObj, position, tickSize) {
                var attr = {
                  cx: position.left,
                  cy: position.top
                };
                if ((0, _isExisty2["default"])(tickSize)) {
                  attr.transform = "t-" + tickSize + ",0";
                }
                raphaelObj.animate(attr, MOVING_ANIMATION_DURATION);
              };
              RaphaelLineTypeBase2.prototype._animateByPath = function _animateByPath(raphaelObj, paths, tickSize) {
                var attr = {
                  path: paths.join(" ")
                };
                if ((0, _isExisty2["default"])(tickSize)) {
                  attr.transform = "t-" + tickSize + ",0";
                }
                raphaelObj.animate(attr, MOVING_ANIMATION_DURATION);
              };
              RaphaelLineTypeBase2.prototype._removeFirstDot = function _removeFirstDot(dots) {
                var firstDot = dots.shift();
                firstDot.endDot.dot.remove();
                if (firstDot.startDot) {
                  firstDot.startDot.dot.remove();
                }
              };
              RaphaelLineTypeBase2.prototype.clear = function clear() {
                delete this.paper.dots;
                this.paper.clear();
              };
              RaphaelLineTypeBase2.prototype.resizeClipRect = function resizeClipRect(width, height) {
                var clipRect = this.paper.getById(this._getClipRectId() + "_rect");
                clipRect.attr({
                  width,
                  height
                });
              };
              RaphaelLineTypeBase2.prototype._getClipRectId = function _getClipRectId() {
                if (!this.clipRectId) {
                  this.clipRectId = _renderUtil2["default"].generateClipRectId();
                }
                return this.clipRectId;
              };
              RaphaelLineTypeBase2.prototype.resetSeriesOrder = function resetSeriesOrder() {
              };
              RaphaelLineTypeBase2.prototype.moveSeriesToFront = function moveSeriesToFront() {
              };
              return RaphaelLineTypeBase2;
            }();
            function createClipPathRectWithLayout(paper, position, dimension, id, isAnimated) {
              var clipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
              var rect = paper.rect(position.left, position.top, isAnimated ? 0 : dimension.width, dimension.height);
              rect.id = id + "_rect";
              clipPath.id = id;
              clipPath.appendChild(rect.node);
              paper.defs.appendChild(clipPath);
              return rect;
            }
            exports2["default"] = RaphaelLineTypeBase;
          },
          /* 33 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isBoolean = __webpack_require__(28);
            var _isBoolean2 = _interopRequireDefault(_isBoolean);
            var _isObject = __webpack_require__(7);
            var _isObject2 = _interopRequireDefault(_isObject);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var predicate = {
              /**
               * Whether bar chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @returns {boolean}
               */
              isBarChart: function isBarChart(chartType) {
                return chartType === _const2["default"].CHART_TYPE_BAR;
              },
              /**
               * Whether column chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @returns {boolean}
               */
              isColumnChart: function isColumnChart(chartType) {
                return chartType === _const2["default"].CHART_TYPE_COLUMN;
              },
              /**
               * Whether bar type chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @returns {boolean}
               */
              isBarTypeChart: function isBarTypeChart(chartType) {
                return predicate.isBarChart(chartType) || predicate.isColumnChart(chartType);
              },
              /**
               * Whether column type chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @param {Array.<string>} seriesTypes - type of series
               * @returns {boolean}
               */
              isColumnTypeChart: function isColumnTypeChart(chartType, seriesTypes) {
                return predicate.isHeatmapChart(chartType) || predicate.isColumnChart(chartType) || predicate.isBoxplotChart(chartType) || predicate.isLineColumnComboChart(chartType, seriesTypes);
              },
              /**
               * Whether boxplot chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @returns {boolean}
               */
              isBoxplotChart: function isBoxplotChart(chartType) {
                return chartType === _const2["default"].CHART_TYPE_BOXPLOT;
              },
              /**
               * Whether bullet chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @returns {boolean}
               */
              isBulletChart: function isBulletChart(chartType) {
                return chartType === _const2["default"].CHART_TYPE_BULLET;
              },
              /**
               * Whether radial type chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @returns {boolean}
               */
              isRadialChart: function isRadialChart(chartType) {
                return chartType === _const2["default"].CHART_TYPE_RADIAL;
              },
              /**
               * Whether diverging chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @param {boolean} diverging - whether has diverging or not
               * @returns {*|boolean}
               */
              isDivergingChart: function isDivergingChart(chartType, diverging) {
                return this.isBarTypeChart(chartType) && diverging;
              },
              /**
               * Whether normal stack chart or not.
               * @param {string} chartType - type of chart
               * @param {object} stack - stack options
               * @returns {boolean}
               * @private
               */
              isNormalStackChart: function isNormalStackChart(chartType, stack) {
                var isAllowedStackOption = predicate.isAllowedStackOption(chartType);
                var isNormalStack = predicate.isNormalStack(stack);
                return isAllowedStackOption && isNormalStack;
              },
              /**
               * Whether percent stack chart or not.
               * @param {string} chartType - type of chart
               * @param {object} stack - type of stack
               * @returns {boolean}
               * @private
               */
              isPercentStackChart: function isPercentStackChart(chartType, stack) {
                var isAllowedStackOption = predicate.isAllowedStackOption(chartType);
                var isPercentStack = predicate.isPercentStack(stack);
                return isAllowedStackOption && isPercentStack;
              },
              /**
               * Whether combo chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @returns {boolean}
               */
              isComboChart: function isComboChart(chartType) {
                return chartType === _const2["default"].CHART_TYPE_COMBO;
              },
              /**
               * Whether line and column combo chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @param {Array.<string>} subChartTypes - types of chart
               * @returns {boolean}
               */
              isLineColumnComboChart: function isLineColumnComboChart(chartType, subChartTypes) {
                var isLineOrColumn = _arrayUtil2["default"].all(subChartTypes || [], function(subChartType) {
                  return predicate.isLineChart(subChartType) || predicate.isColumnChart(subChartType);
                });
                return predicate.isComboChart(chartType) && isLineOrColumn;
              },
              /**
               * Whether pie and donut combo chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @param {Array.<string>} subChartTypes - types of chart
               * @returns {boolean}
               */
              isPieDonutComboChart: function isPieDonutComboChart(chartType, subChartTypes) {
                var isAllPieType = _arrayUtil2["default"].all(subChartTypes, function(subChartType) {
                  return predicate.isPieChart(subChartType);
                });
                return predicate.isComboChart(chartType) && isAllPieType;
              },
              /**
               * Whether line chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @returns {boolean}
               */
              isLineChart: function isLineChart(chartType) {
                return chartType === _const2["default"].CHART_TYPE_LINE;
              },
              /**
               * Whether area chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @returns {boolean}
               */
              isAreaChart: function isAreaChart(chartType) {
                return chartType === _const2["default"].CHART_TYPE_AREA;
              },
              /**
               * Whether line and area combo chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @param {Array.<string>} subChartTypes - types of chart
               * @returns {boolean}
               */
              isLineAreaComboChart: function isLineAreaComboChart(chartType, subChartTypes) {
                var isAllLineType = _arrayUtil2["default"].all(subChartTypes || [], function(subChartType) {
                  return predicate.isLineChart(subChartType) || predicate.isAreaChart(subChartType);
                });
                return predicate.isComboChart(chartType) && isAllLineType;
              },
              /**
               * Whether line and area combo chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @param {Array.<string>} subChartTypes - types of chart
               * @returns {boolean}
               */
              hasLineChart: function hasLineChart(chartType, subChartTypes) {
                var hasLineType = _arrayUtil2["default"].any(subChartTypes || [], function(subChartType) {
                  return predicate.isLineChart(subChartType);
                });
                return predicate.isComboChart(chartType) && hasLineType;
              },
              /**
               * Whether line and scatter combo chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @param {Array.<string>} subChartTypes - types of chart
               * @returns {boolean}
               */
              isLineScatterComboChart: function isLineScatterComboChart(chartType, subChartTypes) {
                var isAllLineType = _arrayUtil2["default"].all(subChartTypes || [], function(subChartType) {
                  return predicate.isLineChart(subChartType) || predicate.isScatterChart(subChartType);
                });
                return predicate.isComboChart(chartType) && isAllLineType;
              },
              /**
               * Whether line type chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @param {Array.<string>} [subChartTypes] - types of chart
               * @returns {boolean}
               */
              isLineTypeChart: function isLineTypeChart(chartType, subChartTypes) {
                return predicate.isLineChart(chartType) || predicate.isAreaChart(chartType) || predicate.isLineAreaComboChart(chartType, subChartTypes);
              },
              /**
               * Whether bubble chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @returns {boolean}
               */
              isBubbleChart: function isBubbleChart(chartType) {
                return chartType === _const2["default"].CHART_TYPE_BUBBLE;
              },
              /**
               * Whether scatter chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - chart type
               * @returns {boolean}
               */
              isScatterChart: function isScatterChart(chartType) {
                return chartType === _const2["default"].CHART_TYPE_SCATTER;
              },
              /**
               * Whether heatmap chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - chart type
               * @returns {boolean}
               */
              isHeatmapChart: function isHeatmapChart(chartType) {
                return chartType === _const2["default"].CHART_TYPE_HEATMAP;
              },
              /**
               * Whether treemap chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - chart type
               * @returns {boolean}
               */
              isTreemapChart: function isTreemapChart(chartType) {
                return chartType === _const2["default"].CHART_TYPE_TREEMAP;
              },
              /**
               * Whether box type chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - chart type
               * @returns {boolean}
               */
              isBoxTypeChart: function isBoxTypeChart(chartType) {
                return predicate.isHeatmapChart(chartType) || predicate.isTreemapChart(chartType);
              },
              /**
               * Whether map type chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - chart type
               * @returns {boolean}
               */
              isMapTypeChart: function isMapTypeChart(chartType) {
                return this.isMapChart(chartType) || this.isHeatmapChart(chartType) || this.isTreemapChart(chartType);
              },
              /**
               * Whether pie chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - chart type
               * @returns {boolean}
               */
              isPieChart: function isPieChart(chartType) {
                return chartType && chartType.indexOf(_const2["default"].CHART_TYPE_PIE) !== -1;
              },
              /**
               * Whether map chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @returns {boolean}
               */
              isMapChart: function isMapChart(chartType) {
                return chartType === _const2["default"].CHART_TYPE_MAP;
              },
              /**
               * Whether coordinate type chart or not.
               * @memberOf module:predicate
               * @param {string} chartType - chart type
               * @returns {boolean}
               */
              isCoordinateTypeChart: function isCoordinateTypeChart(chartType) {
                return predicate.isBubbleChart(chartType) || predicate.isScatterChart(chartType);
              },
              /**
               * Whether allow rendering for minus point in area of series.
               * @memberOf module:predicate
               * @param {string} chartType - chart type
               * @returns {boolean}
               */
              allowMinusPointRender: function allowMinusPointRender(chartType) {
                return predicate.isLineTypeChart(chartType) || predicate.isCoordinateTypeChart(chartType) || predicate.isBoxTypeChart(chartType) || predicate.isBulletChart(chartType);
              },
              /**
               * Whether chart to detect mouse events on series or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @returns {boolean}
               */
              isChartToDetectMouseEventOnSeries: function isChartToDetectMouseEventOnSeries(chartType) {
                return predicate.isPieChart(chartType) || predicate.isMapChart(chartType) || predicate.isCoordinateTypeChart(chartType);
              },
              /**
               * Whether align of label is outer or not.
               * @memberOf module:predicate
               * @param {string} align - align of legend
               * @returns {boolean}
               */
              isLabelAlignOuter: function isLabelAlignOuter(align) {
                return align === _const2["default"].LABEL_ALIGN_OUTER;
              },
              /**
               * Whether show label or not.
               * @param {{showLabel: ?boolean, showLegend: ?boolean}} options - options
               * @returns {boolean}
               */
              isShowLabel: function isShowLabel(options) {
                return options.showLabel || options.showLegend;
              },
              /**
               * Whether show outer label or not.
               * @param {{showLabel: ?boolean, showLegend: ?boolean, labelAlign: string}} options - options
               * @returns {*|boolean}
               */
              isShowOuterLabel: function isShowOuterLabel(options) {
                return predicate.isShowLabel(options) && predicate.isLabelAlignOuter(options.labelAlign);
              },
              /**
               * Whether align of legend is left or not.
               * @memberOf module:predicate
               * @param {string} align - align of legend
               * @returns {boolean}
               */
              isLegendAlignLeft: function isLegendAlignLeft(align) {
                return align === _const2["default"].LEGEND_ALIGN_LEFT;
              },
              /**
               * Whether align of legend is top or not.
               * @memberOf module:predicate
               * @param {string} align - align of legend
               * @returns {boolean}
               */
              isLegendAlignTop: function isLegendAlignTop(align) {
                return align === _const2["default"].LEGEND_ALIGN_TOP;
              },
              /**
               * Whether align of legend is bottom or not.
               * @memberOf module:predicate
               * @param {string} align - align of legend
               * @returns {boolean}
               */
              isLegendAlignBottom: function isLegendAlignBottom(align) {
                return align === _const2["default"].LEGEND_ALIGN_BOTTOM;
              },
              /**
               * Whether horizontal legend or not.
               * @memberOf module:predicate
               * @param {string} align - align option for legend
               * @returns {boolean}
               */
              isHorizontalLegend: function isHorizontalLegend(align) {
                return predicate.isLegendAlignTop(align) || predicate.isLegendAlignBottom(align);
              },
              /**
               * Whether vertical legend or not.
               * @memberOf module:predicate
               * @param {string} align - align option for legend
               * @returns {boolean}
               */
              isVerticalLegend: function isVerticalLegend(align) {
                return !predicate.isHorizontalLegend(align);
              },
              /**
               * Whether allowed stackType option or not.
               * @memberOf module:predicate
               * @param {string} chartType - type of chart
               * @returns {boolean}
               */
              isAllowedStackOption: function isAllowedStackOption(chartType) {
                return predicate.isBarChart(chartType) || predicate.isColumnChart(chartType) || predicate.isAreaChart(chartType);
              },
              /**
               * Whether normal stack type or not.
               * @memberOf module:predicate
               * @param {object} stack - stack option
               * @param {string} stack.type - stack type
               * @returns {boolean}
               */
              isNormalStack: function isNormalStack(stack) {
                return !!stack && stack.type === _const2["default"].NORMAL_STACK_TYPE;
              },
              /**
               * Whether percent stack type or not.
               * @memberOf module:predicate
               * @param {object} stack - stack option
               * @param {string} stack.type - stack type
               * @returns {boolean}
               */
              isPercentStack: function isPercentStack(stack) {
                return !!stack && stack.type === _const2["default"].PERCENT_STACK_TYPE;
              },
              /**
               * Whether valid stackType option or not.
               * @memberOf module:predicate
               * @param {object} stack - stack option
               * @param {string} stack.type - stack option
               * @returns {boolean}
               */
              isValidStackOption: function isValidStackOption(stack) {
                return predicate.isNormalStack(stack) || predicate.isPercentStack(stack);
              },
              /**
               * Whether allow range data or not.
               * @memberOf module:predicate
               * @param {string} chartType - chart type
               * @returns {boolean}
               */
              isAllowRangeData: function isAllowRangeData(chartType) {
                return predicate.isBarTypeChart(chartType) || predicate.isAreaChart(chartType);
              },
              /**
               * Whether align of yAxis is center or not.
               * @memberOf module:predicate
               * @param {boolean} hasRightYAxis - whether has right yAxis.
               * @param {string} alignOption - align option of yAxis.
               * @returns {boolean} whether - align center or not.
               */
              isYAxisAlignCenter: function isYAxisAlignCenter(hasRightYAxis, alignOption) {
                return !hasRightYAxis && alignOption === _const2["default"].YAXIS_ALIGN_CENTER;
              },
              /**
               * Whether minus limit or not.
               * @memberOf module:predicate
               * @param {{min: number, max: number}} limit - limit
               * @returns {boolean}
               */
              isMinusLimit: function isMinusLimit(limit) {
                return limit.min <= 0 && limit.max <= 0;
              },
              /**
               * Whether auto tick interval or not.
               * @param {string} [tickInterval] - tick interval option
               * @returns {boolean}
               */
              isAutoTickInterval: function isAutoTickInterval(tickInterval) {
                return tickInterval === _const2["default"].TICK_INTERVAL_AUTO;
              },
              /**
               * Whether valid label interval or not.
               * @param {number} [labelInterval] - label interval option
               * @param {string} [tickInterval] - tick interval option
               * @returns {*|boolean}
               */
              isValidLabelInterval: function isValidLabelInterval(labelInterval, tickInterval) {
                return labelInterval && labelInterval > 1 && !tickInterval;
              },
              /**
               * Whether datetime type or not.
               * @param {string} type - type
               * @returns {boolean}
               */
              isDatetimeType: function isDatetimeType(type) {
                return type === _const2["default"].AXIS_TYPE_DATETIME;
              },
              /**
               * @param {string} chartType - type of chart
               * @returns {boolean} - whether it support ChartBase#showTooltip API
               */
              isSupportPublicShowTooptipAPI: function isSupportPublicShowTooptipAPI(chartType) {
                return this.isBarChart(chartType) || this.isColumnChart(chartType) || this.isLineChart(chartType) || this.isAreaChart(chartType) || this.isBoxplotChart(chartType);
              },
              /**
               * @param {string} chartType - type of chart
               * @returns {boolean} - whether it support ChartBase#hideTooltip API
               */
              isSupportPublicHideTooptipAPI: function isSupportPublicHideTooptipAPI(chartType) {
                return this.isBarChart(chartType) || this.isColumnChart(chartType) || this.isLineChart(chartType) || this.isAreaChart(chartType) || this.isBoxplotChart(chartType);
              },
              /**
               * Whether valid stackType option or not.
               * @memberOf module:predicate
               * @param {object | boolean} [connector] - connector option
               * @returns {boolean}
               */
              isRenderConnector: function isRenderConnector(connector) {
                return (0, _isBoolean2["default"])(connector) && connector || (0, _isObject2["default"])(connector) && (connector.type === "solid" || connector.type === "dotted");
              }
            };
            exports2["default"] = predicate;
          },
          /* 34 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _isNumber = __webpack_require__(19);
            var _isNumber2 = _interopRequireDefault(_isNumber);
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _raphaelLineTypeBase = __webpack_require__(32);
            var _raphaelLineTypeBase2 = _interopRequireDefault(_raphaelLineTypeBase);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _consoleUtil = __webpack_require__(35);
            var _consoleUtil2 = _interopRequireDefault(_consoleUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _toConsumableArray(arr) {
              if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              } else {
                return Array.from(arr);
              }
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var GUIDE_AREACHART_AREAOPACITY_TYPE = _const2["default"].GUIDE_AREACHART_AREAOPACITY_TYPE, CLASS_NAME_SVG_AUTOSHAPE = _const2["default"].CLASS_NAME_SVG_AUTOSHAPE;
            var EMPHASIS_OPACITY = 1;
            var DE_EMPHASIS_OPACITY = 0.3;
            var RaphaelAreaChart = function(_RaphaelLineBase) {
              _inherits(RaphaelAreaChart2, _RaphaelLineBase);
              function RaphaelAreaChart2() {
                _classCallCheck(this, RaphaelAreaChart2);
                var _this = _possibleConstructorReturn(this, _RaphaelLineBase.call(this));
                _this.selectedLegendIndex = null;
                _this.chartType = "area";
                _this.lineWidth = 0;
                return _this;
              }
              RaphaelAreaChart2.prototype.render = function render(paper, data) {
                var dimension = data.dimension, groupPositions = data.groupPositions, _data$theme = data.theme, theme = _data$theme === void 0 ? {} : _data$theme, position = data.position, zeroTop = data.zeroTop, hasRangeData = data.hasRangeData, options = data.options;
                var _theme$dot = theme.dot, dotTheme = _theme$dot === void 0 ? {} : _theme$dot, colors = theme.colors;
                var spline = options.spline, allowSelect = options.allowSelect, connectNulls = options.connectNulls, pointWidth = options.pointWidth, showDot = options.showDot, areaOpacityOptions = options.areaOpacity;
                var areaOpacity = this._isAreaOpacityNumber(areaOpacityOptions) ? areaOpacityOptions : 1;
                var dotOpacity = showDot ? 1 : 0;
                var borderStyle = this.makeBorderStyle(dotTheme.strokeColor, dotOpacity, dotTheme.strokeWidth);
                var outDotStyle = this.makeOutDotStyle(dotOpacity, borderStyle);
                var lineWidth = this.lineWidth = (0, _isNumber2["default"])(pointWidth) ? pointWidth : this.lineWidth;
                this.paper = paper;
                this.theme = theme;
                this.isSpline = spline;
                this.dimension = dimension;
                this.position = position;
                this.zeroTop = zeroTop;
                this.hasRangeData = hasRangeData;
                this.animationDuration = data.options.animationDuration;
                paper.setStart();
                this.groupPaths = this._getAreaChartPath(groupPositions, null, connectNulls);
                this.groupAreas = this._renderAreas(paper, this.groupPaths, colors, lineWidth, areaOpacity);
                this.tooltipLine = this._renderTooltipLine(paper, dimension.height);
                this.groupDots = this._renderDots(paper, groupPositions, colors, dotOpacity);
                if (allowSelect) {
                  this.selectionDot = this._makeSelectionDot(paper);
                  this.selectionColor = theme.selectionColor;
                  if (this.hasRangeData) {
                    this.selectionStartDot = this._makeSelectionDot(paper);
                  }
                }
                this.outDotStyle = outDotStyle;
                this.groupPositions = groupPositions;
                this.dotOpacity = dotOpacity;
                this.pivotGroupDots = null;
                var seriesSet = paper.setFinish();
                this._moveSeriesToFrontAll();
                this.tooltipLine.toFront();
                return seriesSet;
              };
              RaphaelAreaChart2.prototype._moveSeriesToFrontAll = function _moveSeriesToFrontAll() {
                var len = this.groupPaths ? this.groupPaths.length : 0;
                for (var i = 0; i < len; i += 1) {
                  this.moveSeriesToFront(this.groupAreas[i], this.groupDots[i]);
                }
              };
              RaphaelAreaChart2.prototype._getAreaChartPath = function _getAreaChartPath(groupPositions, hasExtraPath, connectNulls) {
                if (this.isSpline) {
                  return this._makeSplineAreaChartPath(groupPositions, hasExtraPath);
                }
                return this._makeAreaChartPath(groupPositions, hasExtraPath, connectNulls);
              };
              RaphaelAreaChart2.prototype._renderAreas = function _renderAreas(paper, groupPaths, colors, strokeWidth, opacity) {
                colors = colors.slice(0, groupPaths.length);
                colors.reverse();
                groupPaths.reverse();
                var groupAreas = groupPaths.map(function(path, groupIndex) {
                  var polygons = {};
                  var areaColor = colors[groupIndex] || "transparent";
                  var color = areaColor;
                  var area = _raphaelRenderUtil2["default"].renderArea(paper, path.area.join(" "), {
                    fill: areaColor,
                    opacity,
                    stroke: areaColor
                  });
                  var line = _raphaelRenderUtil2["default"].renderLine(paper, path.line.join(" "), {
                    color,
                    strokeWidth
                  });
                  area.node.setAttribute("class", CLASS_NAME_SVG_AUTOSHAPE);
                  line.node.setAttribute("class", CLASS_NAME_SVG_AUTOSHAPE);
                  polygons.area = area;
                  polygons.line = line;
                  if (path.startLine) {
                    polygons.startLine = _raphaelRenderUtil2["default"].renderLine(paper, path.startLine.join(" "), {
                      color,
                      strokeWidth: 0
                    });
                  }
                  return polygons;
                });
                return groupAreas.reverse();
              };
              RaphaelAreaChart2.prototype._makeHeight = function _makeHeight(top, startTop) {
                return Math.abs(top - startTop);
              };
              RaphaelAreaChart2.prototype._makeAreasPath = function _makeAreasPath(positions, hasExtraPath) {
                var _ref3;
                var paths = [];
                var positionLength = positions.length;
                var path = [];
                var latterPath = [];
                var formerPath = [];
                var prevNull = false;
                Object.entries(positions).forEach(function(_ref) {
                  var _ref2 = _slicedToArray(_ref, 2), index = _ref2[0], position = _ref2[1];
                  var moveOrLine = void 0;
                  if (position) {
                    if (prevNull) {
                      moveOrLine = "M";
                      prevNull = false;
                    } else {
                      moveOrLine = "L";
                    }
                    formerPath.push([moveOrLine, position.left, position.top]);
                    latterPath.unshift(["L", position.left, position.startTop]);
                  } else {
                    prevNull = true;
                    latterPath.push(["z"]);
                  }
                  if (!position || parseInt(index, 10) === positionLength - 1) {
                    paths.push(formerPath.concat(latterPath));
                    formerPath = [];
                    latterPath = [];
                  }
                });
                paths.forEach(function(partialPath) {
                  path = path.concat(partialPath);
                });
                if (hasExtraPath !== false) {
                  var targetIndex = positions.length - 1;
                  path.splice(targetIndex + 1, 0, path[targetIndex], path[targetIndex + 1]);
                }
                path = (_ref3 = []).concat.apply(_ref3, _toConsumableArray(path));
                path[0] = "M";
                return path;
              };
              RaphaelAreaChart2.prototype._makeAreaChartPath = function _makeAreaChartPath(groupPositions, hasExtraPath, connectNulls) {
                var _this2 = this;
                return groupPositions.map(function(positions) {
                  var paths = {
                    area: _this2._makeAreasPath(positions, hasExtraPath),
                    line: _this2._makeLinesPath(positions, null, connectNulls)
                  };
                  if (_this2.hasRangeData) {
                    paths.startLine = _this2._makeLinesPath(positions, "startTop");
                  }
                  return paths;
                });
              };
              RaphaelAreaChart2.prototype._makeSplineAreaChartPath = function _makeSplineAreaChartPath(groupPositions, hasExtraPath) {
                var _this3 = this;
                return groupPositions.map(function(positions) {
                  var reversePosition = positions.concat().reverse().map(function(position) {
                    return {
                      left: position.left,
                      top: position.startTop
                    };
                  });
                  var linesPath = _this3._makeSplineLinesPath(positions);
                  var reverseLinesPath = _this3._makeSplineLinesPath(reversePosition, {
                    isReverseDirection: true,
                    isBeConnected: true
                  });
                  var areaPath = JSON.parse(JSON.stringify(linesPath));
                  var reverseAreaPath = JSON.parse(JSON.stringify(reverseLinesPath));
                  if (hasExtraPath !== false) {
                    var lastPosition = positions[positions.length - 1];
                    var lastReversePosition = reversePosition[reversePosition.length - 1];
                    areaPath.push(["K", lastPosition.left, lastPosition.top]);
                    areaPath.push(["L", lastPosition.left, lastPosition.startTop]);
                    reverseAreaPath.push(["K", lastReversePosition.left, lastReversePosition.top]);
                    reverseAreaPath.push(["L", lastReversePosition.left, lastReversePosition.top]);
                  }
                  return {
                    area: areaPath.concat(reverseAreaPath),
                    line: linesPath
                  };
                });
              };
              RaphaelAreaChart2.prototype.resize = function resize(_ref4) {
                var _this4 = this;
                var dimension = _ref4.dimension, groupPositions = _ref4.groupPositions, zeroTop = _ref4.zeroTop;
                this.resizeClipRect(dimension.width, dimension.height);
                this.zeroTop = zeroTop;
                this.groupPositions = groupPositions;
                this.groupPaths = this._getAreaChartPath(groupPositions);
                this.paper.setSize(dimension.width, dimension.height);
                this.tooltipLine.attr({
                  top: dimension.height
                });
                this.groupPaths.forEach(function(path, groupIndex) {
                  var area = _this4.groupAreas[groupIndex];
                  area.area.attr({
                    path: path.area.join(" ")
                  });
                  area.line.attr({
                    path: path.line.join(" ")
                  });
                  if (area.startLine) {
                    area.startLine.attr({
                      path: path.startLine.join(" ")
                    });
                  }
                  _this4.groupDots[groupIndex].forEach(function(item, index) {
                    var position = groupPositions[groupIndex][index];
                    if (item.endDot) {
                      _this4._moveDot(item.endDot.dot, position);
                    }
                    if (item.startDot) {
                      var startPositon = Object.assign({}, position);
                      startPositon.top = startPositon.startTop;
                      _this4._moveDot(item.startDot.dot, startPositon);
                    }
                  });
                });
              };
              RaphaelAreaChart2.prototype.selectLegend = function selectLegend(legendIndex) {
                var _this5 = this;
                var noneSelected = (0, _isNull2["default"])(legendIndex);
                if (this.selectedLegendIndex && this.selectedLegendIndex !== -1) {
                  this.resetSeriesOrder(this.selectedLegendIndex);
                }
                this.selectedLegendIndex = legendIndex;
                this.groupAreas.forEach(function(area, groupIndex) {
                  var isSelectedLegend = legendIndex === groupIndex;
                  var opacity = noneSelected || isSelectedLegend ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
                  var groupDots = _this5.groupDots[groupIndex];
                  area.area.attr({
                    "fill-opacity": opacity
                  });
                  area.line.attr({
                    "stroke-opacity": opacity
                  });
                  if (area.startLine) {
                    area.startLine.attr({
                      "stroke-opacity": opacity
                    });
                  }
                  if (isSelectedLegend) {
                    _this5.moveSeriesToFront(area, groupDots);
                  }
                });
              };
              RaphaelAreaChart2.prototype.resetSeriesOrder = function resetSeriesOrder(legendIndex) {
                var frontSeries = legendIndex + 1 < this.groupAreas.length ? this.groupAreas[legendIndex + 1] : null;
                if (frontSeries) {
                  var frontArea = frontSeries.area;
                  this.groupAreas[legendIndex].area.insertBefore(frontArea);
                  this.groupAreas[legendIndex].line.insertBefore(frontArea);
                  this.groupDots[legendIndex].forEach(function(item) {
                    if (item && item.endDot) {
                      item.endDot.dot.insertBefore(frontArea);
                    }
                  });
                }
              };
              RaphaelAreaChart2.prototype.moveSeriesToFront = function moveSeriesToFront(areaSurface, dots) {
                areaSurface.line.toFront();
                areaSurface.area.toFront();
                if (areaSurface.startLine) {
                  areaSurface.startLine.toFront();
                }
                dots.forEach(function(item) {
                  if (item.endDot) {
                    item.endDot.dot.toFront();
                  }
                  if (item.startDot) {
                    item.startDot.dot.toFront();
                  }
                });
              };
              RaphaelAreaChart2.prototype.animateForAddingData = function animateForAddingData(data, tickSize, groupPositions, shiftingOption, zeroTop) {
                var _this6 = this;
                var groupPaths = this._getAreaChartPath(groupPositions, false);
                var additionalIndex = 0;
                if (!groupPositions.length) {
                  return;
                }
                if (shiftingOption) {
                  additionalIndex = 1;
                }
                this.zeroTop = zeroTop;
                this.groupAreas.forEach(function(area, groupIndex) {
                  var dots = _this6.groupDots[groupIndex];
                  var groupPosition = groupPositions[groupIndex];
                  var pathMap = groupPaths[groupIndex];
                  if (shiftingOption) {
                    _this6._removeFirstDot(dots);
                  }
                  dots.forEach(function(item, index) {
                    var position = groupPosition[index + additionalIndex];
                    _this6._animateByPosition(item.endDot.dot, position, tickSize);
                    if (item.startDot) {
                      _this6._animateByPosition(item.startDot.dot, {
                        left: position.left,
                        top: position.startTop
                      }, tickSize);
                    }
                  });
                  _this6._animateByPath(area.area, pathMap.area, tickSize);
                  _this6._animateByPath(area.line, pathMap.line, tickSize);
                  if (area.startLine) {
                    _this6._animateByPath(area.startLine, pathMap.startLine, tickSize);
                  }
                });
              };
              RaphaelAreaChart2.prototype.renderSeriesLabel = function renderSeriesLabel(paper, groupPositions, groupLabels, labelTheme) {
                var attributes = {
                  "font-size": labelTheme.fontSize,
                  "font-family": labelTheme.fontFamily,
                  "font-weight": labelTheme.fontWeight,
                  fill: labelTheme.color,
                  "text-anchor": "middle",
                  opacity: 0
                };
                var set = paper.set();
                groupLabels.forEach(function(categoryLabel, categoryIndex) {
                  categoryLabel.forEach(function(label, seriesIndex) {
                    var position = groupPositions[categoryIndex][seriesIndex];
                    var endLabel = _raphaelRenderUtil2["default"].renderText(paper, position.end, label.end, attributes);
                    set.push(endLabel);
                    endLabel.node.style.userSelect = "none";
                    endLabel.node.style.cursor = "default";
                    endLabel.node.setAttribute("filter", "url(#glow)");
                    if (position.start) {
                      var startLabel = _raphaelRenderUtil2["default"].renderText(paper, position.start, label.start, attributes);
                      startLabel.node.style.userSelect = "none";
                      startLabel.node.style.cursor = "default";
                      startLabel.node.setAttribute("filter", "url(#glow)");
                      set.push(startLabel);
                    }
                  });
                });
                return set;
              };
              RaphaelAreaChart2.prototype._isAreaOpacityNumber = function _isAreaOpacityNumber(areaOpacity) {
                var isAreaOpacityNumber = (0, _isNumber2["default"])(areaOpacity);
                if (isAreaOpacityNumber) {
                  if (areaOpacity < 0 || areaOpacity > 1) {
                    _consoleUtil2["default"].print(GUIDE_AREACHART_AREAOPACITY_TYPE, "warn");
                  }
                } else if (!(0, _isUndefined2["default"])(areaOpacity)) {
                  _consoleUtil2["default"].print(GUIDE_AREACHART_AREAOPACITY_TYPE, "error");
                }
                return isAreaOpacityNumber;
              };
              return RaphaelAreaChart2;
            }(_raphaelLineTypeBase2["default"]);
            exports2["default"] = RaphaelAreaChart;
          },
          /* 35 */
          /***/
          function(module2, exports2) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = {
              /**
               * check if window.console exists
               * @param {string} message - message
               * @param {string} status - print function of window.console
               */
              print: function print(message) {
                var status = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "log";
                if (window.console) {
                  window.console[status](message);
                }
              }
            };
          },
          /* 36 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _raphael = __webpack_require__(4);
            var _raphael2 = _interopRequireDefault(_raphael);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var DEGREE_180 = 180;
            var DEGREE_360 = 360;
            var MIN_DEGREE = 0.01;
            var RAD = Math.PI / DEGREE_180;
            var EMPHASIS_OPACITY = 1;
            var DE_EMPHASIS_OPACITY = 0.3;
            var DEFAULT_LUMINANT_VALUE = 0.2;
            var OVERLAY_ID = "overlay";
            var TOOLTIP_OFFSET_VALUE = 20;
            var RaphaelPieChart = function() {
              function RaphaelPieChart2() {
                _classCallCheck(this, RaphaelPieChart2);
              }
              RaphaelPieChart2.prototype.render = function render(paper, data, callbacks) {
                var pieSeriesSet = paper.set();
                this.animationDuration = data.options.animationDuration;
                this.paper = paper;
                var _data$options$radiusR = _slicedToArray(data.options.radiusRange, 1);
                this.holeRatio = _data$options$radiusR[0];
                this.chartBackground = data.chartBackground;
                this.chartType = data.chartType;
                this.callbacks = callbacks;
                this.selectionColor = data.theme.selectionColor;
                this.circleBound = data.circleBound;
                this.sectorName = "sector_" + this.chartType;
                this._setSectorAttr();
                this.sectorInfos = this._renderPie(data.sectorData, data.theme.colors, data.additionalIndex, pieSeriesSet);
                this.overlay = this._renderOverlay();
                this.labelInfos = {
                  value: [],
                  legend: []
                };
                this.prevPosition = null;
                this.prevHoverSector = null;
                return pieSeriesSet;
              };
              RaphaelPieChart2.prototype.clear = function clear() {
                this.paper.clear();
              };
              RaphaelPieChart2.prototype._makeSectorPath = function _makeSectorPath(cx, cy, r, startAngle, endAngle) {
                var startRadian = startAngle * RAD;
                var endRadian = endAngle * RAD;
                var x1 = cx + r * Math.sin(startRadian);
                var y1 = cy - r * Math.cos(startRadian);
                var x2 = cx + r * Math.sin(endRadian);
                var y2 = cy - r * Math.cos(endRadian);
                var largeArcFlag = endAngle - startAngle > DEGREE_180 ? 1 : 0;
                var path = ["M", cx, cy, "L", x1, y1, "A", r, r, 0, largeArcFlag, 1, x2, y2, "Z"];
                return {
                  path
                };
              };
              RaphaelPieChart2.prototype._makeDonutSectorPath = function _makeDonutSectorPath(cx, cy, r, startAngle, endAngle, holeRadius) {
                var startRadian = startAngle * RAD;
                var endRadian = endAngle * RAD;
                var r2 = holeRadius || r * this.holeRatio;
                var x1 = cx + r * Math.sin(startRadian);
                var y1 = cy - r * Math.cos(startRadian);
                var x2 = cx + r2 * Math.sin(startRadian);
                var y2 = cy - r2 * Math.cos(startRadian);
                var x3 = cx + r * Math.sin(endRadian);
                var y3 = cy - r * Math.cos(endRadian);
                var x4 = cx + r2 * Math.sin(endRadian);
                var y4 = cy - r2 * Math.cos(endRadian);
                var largeArcFlag = endAngle - startAngle > DEGREE_180 ? 1 : 0;
                var path = ["M", x1, y1, "A", r, r, 0, largeArcFlag, 1, x3, y3, "L", x4, y4, "A", r2, r2, 0, largeArcFlag, 0, x2, y2, "Z"];
                return {
                  path
                };
              };
              RaphaelPieChart2.prototype._setSectorAttr = function _setSectorAttr() {
                var makeSectorPath = void 0;
                if (this.paper.customAttributes[this.sectorName]) {
                  return;
                }
                if (this.holeRatio) {
                  makeSectorPath = this._makeDonutSectorPath;
                } else {
                  makeSectorPath = this._makeSectorPath;
                }
                this.paper.customAttributes[this.sectorName] = makeSectorPath.bind(this);
              };
              RaphaelPieChart2.prototype._renderOverlay = function _renderOverlay() {
                var params = {
                  paper: this.paper,
                  circleBound: {
                    cx: 0,
                    cy: 0,
                    r: 0
                  },
                  angles: {
                    startAngle: 0,
                    endAngle: 0
                  },
                  attrs: {
                    fill: "none",
                    opacity: 0,
                    stroke: this.chartBackground.color,
                    "stroke-width": 1
                  }
                };
                var inner = this._renderSector(params);
                inner.node.setAttribute("class", "auto-shape-rendering");
                inner.data("id", OVERLAY_ID);
                inner.data("chartType", this.chartType);
                return inner;
              };
              RaphaelPieChart2.prototype._renderSector = function _renderSector(params) {
                var circleBound = params.circleBound, angles = params.angles, attrs = params.attrs;
                attrs[this.sectorName] = [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle];
                return params.paper.path().attr(attrs);
              };
              RaphaelPieChart2.prototype._renderPie = function _renderPie(sectorData, colors, additionalIndex, pieSeriesSet) {
                var _this = this;
                var circleBound = this.circleBound, chartBackground = this.chartBackground, animationDuration = this.animationDuration;
                var sectorInfos = [];
                sectorData.forEach(function(sectorDatum, index) {
                  var ratio = sectorDatum.ratio, angles = sectorDatum.angles;
                  var color = colors[index];
                  var sector = _this._renderSector({
                    paper: _this.paper,
                    circleBound,
                    angles: animationDuration ? angles.start : angles.end,
                    attrs: {
                      fill: animationDuration ? chartBackground.color : color,
                      stroke: chartBackground.color,
                      "stroke-width": 0
                    }
                  });
                  sector.node.setAttribute("class", "auto-shape-rendering");
                  sector.data("index", index);
                  sector.data("legendIndex", index + additionalIndex);
                  sector.data("chartType", _this.chartType);
                  sectorInfos.push({
                    sector,
                    color,
                    angles: angles.end,
                    ratio
                  });
                  pieSeriesSet.push(sector);
                });
                return sectorInfos;
              };
              RaphaelPieChart2.prototype._showOverlay = function _showOverlay(index, legendIndex) {
                var overlay = this.overlay;
                var sectorInfo = this.sectorInfos[index];
                var sa = sectorInfo.angles.startAngle;
                var ea = sectorInfo.angles.endAngle;
                var cb = this.circleBound;
                var innerAttrs = {
                  fill: "#fff",
                  opacity: 1,
                  "stroke-width": 7,
                  "stroke-color": "#fff",
                  "stroke-miterlimit": 15
                };
                innerAttrs[this.sectorName] = [cb.cx, cb.cy, cb.r, sa, ea, cb.r * this.holeRatio];
                overlay.attr(innerAttrs);
                overlay.data("index", index);
                overlay.data("legendIndex", legendIndex);
                overlay.node.setAttribute("filter", "url(#shadow)");
                this._indexingOverlapElement([overlay, sectorInfo.sector, this.labelInfos.legend[index], this.labelInfos.value[index]]);
              };
              RaphaelPieChart2.prototype._indexingOverlapElement = function _indexingOverlapElement(elements) {
                elements.forEach(function(element) {
                  if (element) {
                    element.toFront();
                  }
                });
              };
              RaphaelPieChart2.prototype._hideOverlay = function _hideOverlay() {
                var overlay = this.overlay;
                var attrs = {
                  fill: "none",
                  opacity: 0
                };
                overlay.attr(attrs);
                this._indexingOverlapElement(this.labelInfos.legend);
                this._indexingOverlapElement(this.labelInfos.value);
              };
              RaphaelPieChart2.prototype.animate = function animate(callback) {
                var sectorName = this.sectorName, circleBound = this.circleBound, animationDuration = this.animationDuration;
                var sectorArgs = [circleBound.cx, circleBound.cy, circleBound.r];
                var delayTime = 0;
                this.sectorInfos.forEach(function(sectorInfo) {
                  var angles = sectorInfo.angles;
                  var attrMap = {
                    fill: sectorInfo.color
                  };
                  if (animationDuration) {
                    var animationTime = animationDuration * sectorInfo.ratio;
                    if (angles.startAngle === 0 && angles.endAngle === DEGREE_360) {
                      angles.endAngle = DEGREE_360 - MIN_DEGREE;
                    }
                    attrMap[sectorName] = sectorArgs.concat([angles.startAngle, angles.endAngle]);
                    var anim = _raphael2["default"].animation(attrMap, animationTime, ">");
                    sectorInfo.sector.animate(anim.delay(delayTime));
                    delayTime += animationTime;
                  }
                });
                if (callback) {
                  setTimeout(callback, delayTime);
                }
              };
              RaphaelPieChart2.prototype.resize = function resize(params) {
                var dimension = params.dimension, circleBound = params.circleBound;
                this.circleBound = circleBound;
                this.paper.setSize(dimension.width, dimension.height);
              };
              RaphaelPieChart2.prototype.findSectorInfo = function findSectorInfo(position) {
                var sector = this.paper && this.paper.getElementByPoint(position.left, position.top);
                var info = null;
                if (sector) {
                  info = {
                    legendIndex: (0, _isExisty2["default"])(sector.data("legendIndex")) ? sector.data("legendIndex") : -1,
                    index: (0, _isExisty2["default"])(sector.data("index")) ? sector.data("index") : -1,
                    chartType: sector.data("chartType")
                  };
                }
                return info;
              };
              RaphaelPieChart2.prototype._isChangedPosition = function _isChangedPosition(prevPosition, position) {
                return !prevPosition || prevPosition.left !== position.left || prevPosition.top !== position.top;
              };
              RaphaelPieChart2.prototype._showTooltip = function _showTooltip(sector, position) {
                var args = [{}, 0, sector.data("index"), {
                  left: position.left - TOOLTIP_OFFSET_VALUE,
                  top: position.top - TOOLTIP_OFFSET_VALUE
                }];
                this.callbacks.showTooltip.apply(null, args);
              };
              RaphaelPieChart2.prototype._isValidSector = function _isValidSector(sector) {
                return sector && sector.data("chartType") === this.chartType;
              };
              RaphaelPieChart2.prototype.moveMouseOnSeries = function moveMouseOnSeries(position) {
                var sector = this.paper && this.paper.getElementByPoint(position.left, position.top);
                if (this._isValidSector(sector)) {
                  if (this.prevHoverSector !== sector) {
                    this._showOverlay(sector.data("index"), sector.data("legendIndex"));
                    this.prevHoverSector = sector;
                  }
                  if (this._isChangedPosition(this.prevPosition, position)) {
                    this._showTooltip(sector, position);
                  }
                } else if (this.prevHoverSector) {
                  this._hideOverlay();
                  this.callbacks.hideTooltip();
                  this.prevHoverSector = null;
                }
                this.prevPosition = position;
              };
              RaphaelPieChart2.prototype.selectSeries = function selectSeries(indexes) {
                var sectorInfo = this.sectorInfos[indexes.index];
                if (!sectorInfo) {
                  return;
                }
                var objColor = _raphael2["default"].color(sectorInfo.color);
                var luminanceColor = _raphaelRenderUtil2["default"].makeChangedLuminanceColor(objColor.hex, DEFAULT_LUMINANT_VALUE);
                var color = this.selectionColor || luminanceColor;
                sectorInfo.sector.attr({
                  fill: color
                });
              };
              RaphaelPieChart2.prototype.unselectSeries = function unselectSeries(indexes) {
                var sectorInfo = this.sectorInfos[indexes.index];
                if (!sectorInfo) {
                  return;
                }
                sectorInfo.sector.attr({
                  fill: sectorInfo.color
                });
              };
              RaphaelPieChart2.prototype.selectLegend = function selectLegend(legendIndex) {
                var isLegendIndexNull = (0, _isNull2["default"])(legendIndex);
                this.sectorInfos.forEach(function(sectorInfo, index) {
                  var opacity = isLegendIndexNull || legendIndex === index ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
                  sectorInfo.sector.attr({
                    "fill-opacity": opacity
                  });
                });
              };
              RaphaelPieChart2.prototype.getRenderedLabelWidth = function getRenderedLabelWidth(text, theme) {
                return _raphaelRenderUtil2["default"].getRenderedTextSize(text, theme.fontSize, theme.fontFamily).width;
              };
              RaphaelPieChart2.prototype.getRenderedLabelHeight = function getRenderedLabelHeight(text, theme) {
                return _raphaelRenderUtil2["default"].getRenderedTextSize(text, theme.fontSize, theme.fontFamily).height;
              };
              RaphaelPieChart2.prototype.renderLabels = function renderLabels(options) {
                var _this2 = this;
                var theme = options.theme, labelFilter = options.labelFilter, dataType = options.dataType, ratioValues = options.ratioValues, seriesNames = options.seriesNames;
                var attributes = {
                  "font-size": theme.fontSize,
                  "font-family": options.fontFamily ? options.fontFamily : options.theme.fontFamily,
                  "font-weight": theme.fontWeight,
                  "text-anchor": "middle",
                  fill: theme.color || "#fff",
                  opacity: 0
                };
                options.positions.forEach(function(position, index) {
                  var ratio = ratioValues[index];
                  var isFiltered = labelFilter && !labelFilter({
                    value: options.labels[index],
                    labelType: dataType,
                    seriesName: seriesNames[index],
                    ratio
                  });
                  var label = void 0;
                  if (isFiltered) {
                    return;
                  }
                  if (options.colors) {
                    attributes.fill = options.colors[index];
                  }
                  if (position) {
                    label = _raphaelRenderUtil2["default"].renderText(options.paper, position, options.labels[index], attributes);
                    label.node.style.userSelect = "none";
                    label.node.style.cursor = "default";
                    label.node.setAttribute("class", "auto-shape-rendering");
                  }
                  _this2.labelInfos[dataType].push(label);
                  options.labelSet.push(label);
                }, this);
                if (!this.labelSet) {
                  this.labelSet = options.labelSet;
                }
              };
              return RaphaelPieChart2;
            }();
            exports2["default"] = RaphaelPieChart;
          },
          /* 37 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _raphaelLineTypeBase = __webpack_require__(32);
            var _raphaelLineTypeBase2 = _interopRequireDefault(_raphaelLineTypeBase);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var EMPHASIS_OPACITY = 1;
            var DE_EMPHASIS_OPACITY = 0.3;
            var DEFAULT_LINE_WIDTH = 6;
            var RaphaelRadialLineSeries = function(_RaphaelLineTypeBase) {
              _inherits(RaphaelRadialLineSeries2, _RaphaelLineTypeBase);
              function RaphaelRadialLineSeries2() {
                _classCallCheck(this, RaphaelRadialLineSeries2);
                var _this = _possibleConstructorReturn(this, _RaphaelLineTypeBase.call(this));
                _this.selectedLegendIndex = null;
                _this.chartType = "radial";
                _this.lineWidth = DEFAULT_LINE_WIDTH;
                return _this;
              }
              RaphaelRadialLineSeries2.prototype.render = function render(paper, data) {
                var dimension = data.dimension, groupPositions = data.groupPositions, theme = data.theme;
                var colors = theme.colors;
                var _data$options = data.options, pointWidth = _data$options.pointWidth, showDot = _data$options.showDot, showArea = _data$options.showArea;
                var dotOpacity = showDot ? 1 : 0;
                var groupPaths = this._getLinesPath(groupPositions);
                var borderStyle = this.makeBorderStyle(theme.strokeColor, dotOpacity, theme.strokeWidth);
                var outDotStyle = this.makeOutDotStyle(dotOpacity, borderStyle);
                var radialSeriesSet = paper.set();
                var lineWidth = this.lineWidth = pointWidth ? pointWidth : this.lineWidth;
                var dotPositions = groupPositions.map(function(positions) {
                  positions.pop();
                  return positions;
                });
                this.paper = paper;
                this.theme = theme;
                this.dimension = dimension;
                this.position = data.position;
                if (showArea) {
                  this.groupAreas = this._renderArea(paper, groupPaths, colors, radialSeriesSet);
                }
                this.groupLines = this._renderLines(paper, groupPaths, colors, lineWidth, radialSeriesSet);
                this.groupDots = this._renderDots(paper, dotPositions, colors, dotOpacity, radialSeriesSet);
                if (data.options.allowSelect) {
                  this.selectionDot = this._makeSelectionDot(paper);
                  this.selectionColor = theme.selectionColor;
                }
                this.colors = colors;
                this.borderStyle = borderStyle;
                this.outDotStyle = outDotStyle;
                this.groupPositions = groupPositions;
                this.groupPaths = groupPaths;
                this.dotOpacity = dotOpacity;
                this.showArea = showArea;
                return radialSeriesSet;
              };
              RaphaelRadialLineSeries2.prototype._getLinesPath = function _getLinesPath(groupPositions) {
                var _this2 = this;
                return groupPositions.map(function(positions) {
                  return _this2._makeLinesPath(positions);
                });
              };
              RaphaelRadialLineSeries2.prototype._renderLines = function _renderLines(paper, groupPaths, colors, strokeWidth, radialSeriesSet) {
                return groupPaths.map(function(path, groupIndex) {
                  var color = colors[groupIndex] || "transparent";
                  var line = _raphaelRenderUtil2["default"].renderLine(paper, path.join(" "), {
                    color,
                    strokeWidth
                  });
                  radialSeriesSet.push(line);
                  return line;
                });
              };
              RaphaelRadialLineSeries2.prototype._renderArea = function _renderArea(paper, groupPaths, colors, radialSeriesSet) {
                var _this3 = this;
                return groupPaths.map(function(path, groupIndex) {
                  var color = colors[groupIndex] || "transparent";
                  var area = _raphaelRenderUtil2["default"].renderArea(paper, path, {
                    fill: color,
                    opacity: 0.4,
                    "stroke-width": _this3.lineWidth,
                    stroke: color
                  });
                  radialSeriesSet.push(area);
                  return area;
                }, this);
              };
              RaphaelRadialLineSeries2.prototype.resize = function resize(params) {
                var _this4 = this;
                var dimension = params.dimension, groupPositions = params.groupPositions;
                this.groupPositions = groupPositions;
                this.groupPaths = this._getLinesPath(groupPositions);
                this.paper.setSize(dimension.width, dimension.height);
                this.groupPaths.forEach(function(path, groupIndex) {
                  _this4.groupLines[groupIndex].attr({
                    path: path.join(" ")
                  });
                  if (_this4.showArea) {
                    _this4.groupAreas[groupIndex].attr({
                      path: path.join(" ")
                    });
                  }
                  _this4.groupDots[groupIndex].forEach(function(item, index) {
                    _this4._moveDot(item.endDot.dot, groupPositions[groupIndex][index]);
                  });
                });
              };
              RaphaelRadialLineSeries2.prototype.selectLegend = function selectLegend(legendIndex) {
                var noneSelected = (0, _isNull2["default"])(legendIndex);
                this.selectedLegendIndex = legendIndex;
                this.groupLines.forEach(function(line, groupIndex) {
                  var opacity = noneSelected || legendIndex === groupIndex ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
                  line.attr({
                    "stroke-opacity": opacity
                  });
                });
              };
              return RaphaelRadialLineSeries2;
            }(_raphaelLineTypeBase2["default"]);
            exports2["default"] = RaphaelRadialLineSeries;
          },
          /* 38 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _raphael = __webpack_require__(4);
            var _raphael2 = _interopRequireDefault(_raphael);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var CIRCLE_OPACITY = 0.8;
            var STROKE_OPACITY = 1;
            var EMPHASIS_OPACITY = 0.8;
            var DE_EMPHASIS_OPACITY = 0.3;
            var DEFAULT_LUMINANC = 0.2;
            var OVERLAY_BORDER_WIDTH = 2;
            var TOOLTIP_OFFSET_VALUE = 20;
            var RaphaelBubbleChart = function() {
              function RaphaelBubbleChart2() {
                _classCallCheck(this, RaphaelBubbleChart2);
              }
              RaphaelBubbleChart2.prototype.render = function render(paper, data, callbacks) {
                var circleSet = paper.set();
                this.paper = paper;
                this.animationDuration = data.options.animationDuration;
                this.theme = data.theme;
                this.seriesDataModel = data.seriesDataModel;
                this.groupBounds = data.groupBounds;
                this.callbacks = callbacks;
                this.overlay = this._renderOverlay();
                this.groupCircleInfos = this._renderCircles(circleSet);
                this.prevCircle = null;
                this.prevOverCircle = null;
                this.animationTimeoutId = null;
                this.selectedLegend = null;
                if (this.paper.raphael.svg) {
                  this.appendShadowFilterToDefs();
                }
                return circleSet;
              };
              RaphaelBubbleChart2.prototype._renderOverlay = function _renderOverlay() {
                var position = {
                  left: 0,
                  top: 0
                };
                var attribute = {
                  fill: "none",
                  stroke: "#fff",
                  "stroke-opacity": STROKE_OPACITY,
                  "stroke-width": 2
                };
                var circle = _raphaelRenderUtil2["default"].renderCircle(this.paper, position, 0, attribute);
                return circle;
              };
              RaphaelBubbleChart2.prototype._renderCircles = function _renderCircles(circleSet) {
                var _this = this;
                var colors = this.theme.colors;
                return this.groupBounds.map(function(bounds, groupIndex) {
                  return bounds.map(function(bound, index) {
                    var circleInfo = null;
                    if (bound) {
                      var color = colors[index];
                      var circle = _raphaelRenderUtil2["default"].renderCircle(_this.paper, bound, _this.animationDuration ? 0 : bound.radius, {
                        fill: color,
                        opacity: _this.animationDuration ? 0 : CIRCLE_OPACITY,
                        stroke: "none"
                      });
                      circleSet.push(circle);
                      circle.data("groupIndex", groupIndex);
                      circle.data("index", index);
                      circleInfo = {
                        circle,
                        color,
                        bound
                      };
                    }
                    return circleInfo;
                  });
                });
              };
              RaphaelBubbleChart2.prototype._animateCircle = function _animateCircle(circle, radius, animationDuration) {
                circle.animate({
                  r: radius,
                  opacity: CIRCLE_OPACITY
                }, animationDuration, ">");
              };
              RaphaelBubbleChart2.prototype.animate = function animate() {
                var _this2 = this;
                _raphaelRenderUtil2["default"].forEach2dArray(this.groupCircleInfos, function(circleInfo) {
                  if (!circleInfo) {
                    return;
                  }
                  if (_this2.animationDuration) {
                    _this2._animateCircle(circleInfo.circle, circleInfo.bound.radius, _this2.animationDuration);
                  }
                });
              };
              RaphaelBubbleChart2.prototype._updatePosition = function _updatePosition(circle, bound) {
                circle.attr({
                  cx: bound.left,
                  cy: bound.top,
                  r: bound.radius
                });
              };
              RaphaelBubbleChart2.prototype.resize = function resize(params) {
                var _this3 = this;
                var dimension = params.dimension, groupBounds = params.groupBounds;
                this.groupBounds = groupBounds;
                this.paper.setSize(dimension.width, dimension.height);
                _raphaelRenderUtil2["default"].forEach2dArray(this.groupCircleInfos, function(circleInfo, groupIndex, index) {
                  var bound = groupBounds[groupIndex][index];
                  if (circleInfo) {
                    circleInfo.bound = bound;
                    _this3._updatePosition(circleInfo.circle, bound);
                  }
                });
              };
              RaphaelBubbleChart2.prototype.findIndexes = function findIndexes(position) {
                var circle = this.paper.getElementByPoint(position.left, position.top);
                var foundIndexes = null;
                if (circle) {
                  foundIndexes = {
                    index: circle.data("index"),
                    groupIndex: circle.data("groupIndex")
                  };
                }
                return foundIndexes;
              };
              RaphaelBubbleChart2.prototype.appendShadowFilterToDefs = function appendShadowFilterToDefs() {
                var filter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
                var feOffset = document.createElementNS("http://www.w3.org/2000/svg", "feOffset");
                var feGaussianBlur = document.createElementNS("http://www.w3.org/2000/svg", "feGaussianBlur");
                var feBlend = document.createElementNS("http://www.w3.org/2000/svg", "feBlend");
                filter.setAttributeNS(null, "id", "shadow");
                filter.setAttributeNS(null, "x", "-50%");
                filter.setAttributeNS(null, "y", "-50%");
                filter.setAttributeNS(null, "width", "180%");
                filter.setAttributeNS(null, "height", "180%");
                feOffset.setAttributeNS(null, "result", "offOut");
                feOffset.setAttributeNS(null, "in", "SourceAlpha");
                feOffset.setAttributeNS(null, "dx", "0");
                feOffset.setAttributeNS(null, "dy", "0");
                feGaussianBlur.setAttributeNS(null, "result", "blurOut");
                feGaussianBlur.setAttributeNS(null, "in", "offOut");
                feGaussianBlur.setAttributeNS(null, "stdDeviation", "2");
                feBlend.setAttributeNS(null, "in", "SourceGraphic");
                feBlend.setAttributeNS(null, "in2", "blurOut");
                feBlend.setAttributeNS(null, "mode", "normal");
                filter.appendChild(feOffset);
                filter.appendChild(feGaussianBlur);
                filter.appendChild(feBlend);
                this.paper.defs.appendChild(filter);
              };
              RaphaelBubbleChart2.prototype._isChangedPosition = function _isChangedPosition(prevPosition, position) {
                return !prevPosition || prevPosition.left !== position.left || prevPosition.top !== position.top;
              };
              RaphaelBubbleChart2.prototype.showAnimation = function showAnimation(indexes) {
                var circleInfo = this.groupCircleInfos[indexes.groupIndex][indexes.index];
                var bound = circleInfo.bound;
                this.circle = circleInfo.circle;
                this.overlay.attr({
                  fill: circleInfo.color,
                  cx: bound.left,
                  cy: bound.top,
                  r: bound.radius + OVERLAY_BORDER_WIDTH,
                  stroke: "#fff",
                  opacity: 1
                });
                this.circle.attr({
                  opacity: 1
                });
                this.overlay.node.setAttribute("filter", "url(#shadow)");
                this.overlay.toFront();
                this.circle.toFront();
              };
              RaphaelBubbleChart2.prototype.hideAnimation = function hideAnimation(indexes) {
                var changeOpacity = DE_EMPHASIS_OPACITY;
                this.overlay.attr({
                  cx: 0,
                  cy: 0,
                  r: 0,
                  opacity: 0
                });
                if ((0, _isNull2["default"])(this.selectedLegend) || indexes.index === this.selectedLegend) {
                  changeOpacity = EMPHASIS_OPACITY;
                }
                this.circle.attr({
                  opacity: changeOpacity
                });
              };
              RaphaelBubbleChart2.prototype._findCircle = function _findCircle(position) {
                var circles = [];
                var paper = this.paper;
                var foundCircle = void 0;
                while ((0, _isUndefined2["default"])(foundCircle)) {
                  var circle = paper.getElementByPoint(position.left, position.top);
                  if (circle) {
                    if (circle.attrs.opacity > DE_EMPHASIS_OPACITY) {
                      foundCircle = circle;
                    } else {
                      circles.push(circle);
                      circle.hide();
                    }
                  } else {
                    foundCircle = null;
                  }
                }
                if (!foundCircle) {
                  foundCircle = circles[0];
                }
                circles.forEach(function(_circle) {
                  _circle.show();
                });
                return foundCircle;
              };
              RaphaelBubbleChart2.prototype.moveMouseOnSeries = function moveMouseOnSeries(position) {
                var circle = this._findCircle(position);
                if (circle && (0, _isExisty2["default"])(circle.data("groupIndex"))) {
                  var groupIndex = circle.data("groupIndex");
                  var index = circle.data("index");
                  var args = [{}, groupIndex, index, {
                    left: position.left - TOOLTIP_OFFSET_VALUE,
                    top: position.top - TOOLTIP_OFFSET_VALUE
                  }];
                  if (this._isChangedPosition(this.prevPosition, position)) {
                    this.callbacks.showTooltip.apply(null, args);
                    this.prevOverCircle = circle;
                  }
                } else if (this.prevOverCircle) {
                  this.callbacks.hideTooltip();
                  this.prevOverCircle = null;
                }
                this.prevPosition = position;
              };
              RaphaelBubbleChart2.prototype.selectSeries = function selectSeries(indexes) {
                var groupIndex = indexes.groupIndex, index = indexes.index;
                var circleInfo = this.groupCircleInfos[groupIndex][index];
                var objColor = _raphael2["default"].color(circleInfo.color);
                var themeColor = this.theme.selectionColor;
                var color = themeColor || _raphaelRenderUtil2["default"].makeChangedLuminanceColor(objColor.hex, DEFAULT_LUMINANC);
                circleInfo.circle.attr({
                  fill: color
                });
              };
              RaphaelBubbleChart2.prototype.unselectSeries = function unselectSeries(indexes) {
                var groupIndex = indexes.groupIndex, index = indexes.index;
                var circleInfo = this.groupCircleInfos[groupIndex][index];
                circleInfo.circle.attr({
                  fill: circleInfo.color
                });
              };
              RaphaelBubbleChart2.prototype.selectLegend = function selectLegend(legendIndex) {
                var noneSelected = (0, _isNull2["default"])(legendIndex);
                this.selectedLegend = legendIndex;
                _raphaelRenderUtil2["default"].forEach2dArray(this.groupCircleInfos, function(circleInfo, groupIndex, index) {
                  if (!circleInfo) {
                    return;
                  }
                  var opacity = noneSelected || legendIndex === index ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
                  circleInfo.circle.attr({
                    opacity
                  });
                });
              };
              return RaphaelBubbleChart2;
            }();
            exports2["default"] = RaphaelBubbleChart;
          },
          /* 39 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var ANIMATION_DURATION = 100;
            var MIN_BORDER_WIDTH = 0;
            var MAX_BORDER_WIDTH = 4;
            var RaphaelBoxTypeChart = function() {
              function RaphaelBoxTypeChart2() {
                _classCallCheck(this, RaphaelBoxTypeChart2);
              }
              RaphaelBoxTypeChart2.prototype.render = function render(paper, seriesData) {
                var seriesSet = paper.set();
                this.paper = paper;
                this.chartType = seriesData.chartType;
                this.theme = seriesData.theme || {};
                this.colorSpectrum = seriesData.colorSpectrum;
                this.chartBackground = seriesData.chartBackground;
                this.zoomable = seriesData.zoomable;
                this.useColorValue = seriesData.options.useColorValue;
                this.borderColor = this.theme.borderColor || "none";
                this.borderWidth = this.theme.borderWidth;
                this.groupBounds = seriesData.groupBounds;
                this.boundMap = seriesData.boundMap;
                this._bindGetBoundFunction();
                this._bindGetColorFunction();
                this.seriesDataModel = seriesData.seriesDataModel;
                this.boxesSet = this._renderBoxes(seriesData.seriesDataModel, seriesData.startDepth, !!seriesData.isPivot, seriesSet);
                this.rectOverlay = this._renderRectOverlay();
                return seriesSet;
              };
              RaphaelBoxTypeChart2.prototype._renderRectOverlay = function _renderRectOverlay() {
                var bound = {
                  width: 1,
                  height: 1,
                  left: 0,
                  top: 0
                };
                var attributes = {
                  "fill-opacity": 0
                };
                var rectOverlay = _raphaelRenderUtil2["default"].renderRect(this.paper, bound, Object.assign({
                  "stroke-width": 0
                }, attributes));
                rectOverlay.node.setAttribute("filter", "url(#shadow)");
                return rectOverlay;
              };
              RaphaelBoxTypeChart2.prototype._bindGetBoundFunction = function _bindGetBoundFunction() {
                if (this.boundMap) {
                  this._getBound = this._getBoundFromBoundMap;
                } else {
                  this._getBound = this._getBoundFromGroupBounds;
                }
              };
              RaphaelBoxTypeChart2.prototype._bindGetColorFunction = function _bindGetColorFunction() {
                if (this.colorSpectrum) {
                  this._getColor = this._getColorFromSpectrum;
                } else {
                  this._getColor = this._getColorFromColors;
                }
              };
              RaphaelBoxTypeChart2.prototype._getBoundFromGroupBounds = function _getBoundFromGroupBounds(seriesItem) {
                return this.groupBounds[seriesItem.groupIndex][seriesItem.index].end;
              };
              RaphaelBoxTypeChart2.prototype._getBoundFromBoundMap = function _getBoundFromBoundMap(seriesItem) {
                return this.boundMap[seriesItem.id];
              };
              RaphaelBoxTypeChart2.prototype._getColorFromSpectrum = function _getColorFromSpectrum(seriesItem, startDepth) {
                var color = void 0;
                if (!seriesItem.hasChild || seriesItem.depth !== startDepth) {
                  color = this.colorSpectrum.getColor(seriesItem.colorRatio || seriesItem.ratio) || this.chartBackground;
                } else {
                  color = "none";
                }
                return color;
              };
              RaphaelBoxTypeChart2.prototype._getColorFromColors = function _getColorFromColors(seriesItem, startDepth) {
                return seriesItem.depth === startDepth ? this.theme.colors[seriesItem.group] : "#000";
              };
              RaphaelBoxTypeChart2.prototype._renderRect = function _renderRect(bound, color, strokeWidth, fillOpacity) {
                return _raphaelRenderUtil2["default"].renderRect(this.paper, bound, {
                  fill: color,
                  stroke: this.borderColor,
                  "stroke-width": strokeWidth,
                  "fill-opacity": fillOpacity
                });
              };
              RaphaelBoxTypeChart2.prototype._getStrokeWidth = function _getStrokeWidth(isFirstDepth) {
                var strokeWidth = void 0;
                if (this.borderWidth) {
                  strokeWidth = this.borderWidth;
                } else if (isFirstDepth) {
                  strokeWidth = MAX_BORDER_WIDTH;
                } else {
                  strokeWidth = MIN_BORDER_WIDTH;
                }
                return strokeWidth;
              };
              RaphaelBoxTypeChart2.prototype._renderBoxes = function _renderBoxes(seriesDataModel, startDepth, isPivot, seriesSet) {
                var _this = this;
                var isTreemap = _predicate2["default"].isTreemapChart(this.chartType);
                return seriesDataModel.map(function(seriesGroup, groupIndex) {
                  if (isTreemap && !_this.colorSpectrum && seriesGroup.getSeriesItemCount()) {
                    var firstItem = seriesGroup.getSeriesItem(0);
                    _this._setTreeFillOpacity({
                      id: firstItem.parent
                    }, startDepth);
                  }
                  return seriesGroup.map(function(seriesItem, index) {
                    var result = null;
                    var depth = seriesItem.depth;
                    var strokeWidth = _this.colorSpectrum ? _this.borderWidth : _this._getStrokeWidth(depth === startDepth);
                    var fillOpacity = _this.colorSpectrum ? 1 : seriesItem.fillOpacity;
                    seriesItem.groupIndex = groupIndex;
                    seriesItem.index = index;
                    var bound = _this._getBound(seriesItem);
                    if (bound) {
                      var color = _this._getColor(seriesItem, startDepth);
                      result = {
                        rect: _this._renderRect(bound, color, strokeWidth, fillOpacity),
                        seriesItem,
                        color
                      };
                      if (seriesSet) {
                        seriesSet.push(result.rect);
                      }
                    }
                    return result;
                  });
                }, isPivot);
              };
              RaphaelBoxTypeChart2.prototype._setTreeFillOpacity = function _setTreeFillOpacity(parentInfo, startDepth) {
                var _this2 = this;
                var children = this.seriesDataModel.findSeriesItemsByParent(parentInfo.id);
                children.forEach(function(datum, index) {
                  var depth = datum.depth;
                  if (depth === startDepth) {
                    datum.fillOpacity = 1;
                  } else if (depth === startDepth + 1) {
                    datum.fillOpacity = 0.05 * index;
                  } else if (depth < startDepth) {
                    datum.fillOpacity = 0;
                  } else {
                    datum.fillOpacity = parentInfo.fillOpacity + 0.05 * index;
                  }
                  if (datum.hasChild) {
                    _this2._setTreeFillOpacity({
                      id: datum.id,
                      fillOpacity: datum.fillOpacity
                    }, startDepth);
                  }
                });
              };
              RaphaelBoxTypeChart2.prototype._animateChangingColor = function _animateChangingColor(rect, color, opacity, strokeColor, strokeWidth) {
                var properties = {
                  "fill-opacity": (0, _isExisty2["default"])(opacity) ? opacity : 1,
                  stroke: strokeColor,
                  "stroke-width": strokeWidth
                };
                if (color) {
                  properties.fill = color;
                }
                rect.animate(properties, ANIMATION_DURATION, ">");
              };
              RaphaelBoxTypeChart2.prototype.showAnimation = function showAnimation(indexes) {
                var box = this.boxesSet[indexes.groupIndex][indexes.index];
                if (!box) {
                  return;
                }
                var rect = box.rect.node;
                var color = box.color;
                if (this.chartType === "treemap" && !this.zoomable && !this.useColorValue) {
                  color = this.theme.colors[indexes.index];
                }
                this.rectOverlay.attr({
                  x: rect.getAttribute("x"),
                  y: rect.getAttribute("y"),
                  width: rect.getAttribute("width"),
                  height: rect.getAttribute("height"),
                  fill: color,
                  "fill-opacity": 1,
                  stroke: "#ffffff",
                  "stroke-width": 4,
                  "stroke-opacity": 1
                });
                this.rectOverlay.toFront();
                if (this.labelSet) {
                  this.labelSet.toFront();
                }
              };
              RaphaelBoxTypeChart2.prototype.hideAnimation = function hideAnimation(indexes) {
                var box = this.boxesSet[indexes.groupIndex][indexes.index];
                if (!box) {
                  return;
                }
                this.rectOverlay.attr({
                  width: 1,
                  height: 1,
                  x: 0,
                  y: 0,
                  "fill-opacity": 0,
                  "stroke-opacity": 0
                });
              };
              RaphaelBoxTypeChart2.prototype.resize = function resize(seriesData) {
                var _this3 = this;
                var dimension = seriesData.dimension;
                this.boundMap = seriesData.boundMap;
                this.groupBounds = seriesData.groupBounds;
                this.paper.setSize(dimension.width, dimension.height);
                _raphaelRenderUtil2["default"].forEach2dArray(this.boxesSet, function(box, groupIndex, index) {
                  if (!box) {
                    return;
                  }
                  var bound = _this3._getBound(box.seriesItem, groupIndex, index);
                  if (bound) {
                    _raphaelRenderUtil2["default"].updateRectBound(box.rect, bound);
                  }
                });
              };
              RaphaelBoxTypeChart2.prototype.renderSeriesLabel = function renderSeriesLabel(paper, positionSet, labels, labelTheme) {
                var labelSet = paper.set();
                var attributes = {
                  "font-size": labelTheme.fontSize,
                  "font-family": labelTheme.fontFamily,
                  "font-weight": labelTheme.fontWeight,
                  fill: "#ffffff",
                  opacity: 0
                };
                labels.forEach(function(categoryLabel, categoryIndex) {
                  categoryLabel.forEach(function(label, seriesIndex) {
                    var seriesLabel = _raphaelRenderUtil2["default"].renderText(paper, positionSet[categoryIndex][seriesIndex].end, label, attributes);
                    seriesLabel.node.style.userSelect = "none";
                    seriesLabel.node.style.cursor = "default";
                    labelSet.push(seriesLabel);
                  });
                });
                this.labelSet = labelSet;
                return labelSet;
              };
              RaphaelBoxTypeChart2.prototype.renderSeriesLabelForTreemap = function renderSeriesLabelForTreemap(paper, positions, labels, labelTheme) {
                var labelSet = paper.set();
                var attributes = {
                  "font-size": labelTheme.fontSize,
                  "font-family": labelTheme.fontFamily,
                  "font-weight": labelTheme.fontWeight,
                  fill: labelTheme.color,
                  opacity: 0
                };
                labels.forEach(function(label, index) {
                  if (positions[index]) {
                    var seriesLabel = _raphaelRenderUtil2["default"].renderText(paper, positions[index], label, attributes);
                    seriesLabel.node.style.userSelect = "none";
                    seriesLabel.node.style.cursor = "default";
                    labelSet.push(seriesLabel);
                  }
                });
                this.labelSet = labelSet;
                return labelSet;
              };
              return RaphaelBoxTypeChart2;
            }();
            exports2["default"] = RaphaelBoxTypeChart;
          },
          /* 40 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _templateObject = _taggedTemplateLiteral(["\n                  s", ",", ",0,0\n                  t", ",", "\n                "], ["\n                  s", ",", ",0,0\n                  t", ",", "\n                "]), _templateObject2 = _taggedTemplateLiteral(["\n                s", ",", ",0,0\n                t", ",", "\n            "], ["\n                s", ",", ",0,0\n                t", ",", "\n            "]);
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _browser = __webpack_require__(22);
            var _browser2 = _interopRequireDefault(_browser);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            var _domHandler = __webpack_require__(24);
            var _domHandler2 = _interopRequireDefault(_domHandler);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _taggedTemplateLiteral(strings, raw) {
              return Object.freeze(Object.defineProperties(strings, {
                raw: {
                  value: Object.freeze(raw)
                }
              }));
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var IS_LTE_IE8 = _browser2["default"].msie && _browser2["default"].version <= 8;
            var STROKE_COLOR = "gray";
            var ANIMATION_DURATION = 100;
            var G_ID = "tui-chart-series-group";
            var FILL_COLOR_OF_NO_DATA = "#eee";
            var RaphaelMapChart = function() {
              function RaphaelMapChart2() {
                _classCallCheck(this, RaphaelMapChart2);
              }
              RaphaelMapChart2.prototype.render = function render(paper, data) {
                var mapDimension = data.mapModel.getMapDimension();
                this.ratio = this._getDimensionRatio(data.layout.dimension, mapDimension);
                this.dimension = data.layout.dimension;
                this.position = data.layout.position;
                this.paper = paper;
                this.sectorSet = paper.set();
                this.sectors = this._renderMap(data, this.ratio);
                if (!IS_LTE_IE8) {
                  this.g = createGElement(paper, this.sectorSet, G_ID);
                }
                this.overColor = data.theme.overColor;
              };
              RaphaelMapChart2.prototype._getDimensionRatio = function _getDimensionRatio(dimension, mapDimension) {
                return Math.min(dimension.height / mapDimension.height, dimension.width / mapDimension.width);
              };
              RaphaelMapChart2.prototype._renderMap = function _renderMap(data, dimensionRatio) {
                var sectorSet = this.sectorSet, paper = this.paper;
                var position = data.layout.position;
                var colorSpectrum = data.colorSpectrum;
                return data.mapModel.getMapData().map(function(datum, index) {
                  var ratio = datum.ratio, path = datum.path;
                  var color = ratio ? colorSpectrum.getColor(ratio) : FILL_COLOR_OF_NO_DATA;
                  var sector = _raphaelRenderUtil2["default"].renderArea(paper, path, {
                    fill: color,
                    opacity: 1,
                    stroke: STROKE_COLOR,
                    "stroke-width": 0.2,
                    "stroke-opacity": 1,
                    transform: _renderUtil2["default"].oneLineTrim(_templateObject, dimensionRatio, dimensionRatio, position.left / dimensionRatio, position.top / dimensionRatio)
                  });
                  sector.data("index", index);
                  sectorSet.push(sector);
                  return {
                    sector,
                    color,
                    ratio
                  };
                });
              };
              RaphaelMapChart2.prototype.findSectorIndex = function findSectorIndex(position) {
                var sector = this.paper.getElementByPoint(position.left, position.top);
                var foundIndex = sector && sector.data("index");
                var data = !(0, _isUndefined2["default"])(foundIndex) && this.sectors[foundIndex];
                return data && !(0, _isUndefined2["default"])(data.ratio) ? foundIndex : null;
              };
              RaphaelMapChart2.prototype.changeColor = function changeColor(index) {
                var sector = this.sectors[index];
                var attributes = {
                  stroke: "#ffffff",
                  "stroke-width": 4
                };
                if (this.overColor) {
                  attributes.fill = this.overColor;
                }
                sector.sector.animate(attributes, ANIMATION_DURATION, ">");
                sector.sector.node.setAttribute("filter", "url(#shadow)");
                sector.sector.toFront();
              };
              RaphaelMapChart2.prototype.restoreColor = function restoreColor(index) {
                var sector = this.sectors[index];
                sector.sector.animate({
                  fill: sector.color,
                  stroke: STROKE_COLOR,
                  "stroke-width": 0.2
                }, ANIMATION_DURATION, ">");
                sector.sector.node.setAttribute("filter", "none");
              };
              RaphaelMapChart2.prototype.scaleMapPaths = function scaleMapPaths(changedRatio, position, mapRatio, limitPosition, mapDimension) {
                var transformList = this.g.transform.baseVal;
                var zoom = this.paper.canvas.createSVGTransform();
                var matrix = this.paper.canvas.createSVGMatrix();
                var raphaelMatrix = this.paper.raphael.matrix();
                var transformMatrix = transformList.numberOfItems ? transformList.getItem(0).matrix : {
                  a: 1,
                  b: 0,
                  c: 0,
                  d: 1,
                  e: 0,
                  f: 0
                };
                var maxRight = mapDimension.width - this.dimension.width;
                var maxTop = mapDimension.height - this.dimension.height;
                var previousTranslateX = transformMatrix.e / transformMatrix.a;
                var previousTranslateY = transformMatrix.f / transformMatrix.d;
                var currentLimitRight = -maxRight / transformMatrix.a;
                var currentLimitTop = -maxTop / transformMatrix.d;
                raphaelMatrix.scale(changedRatio, changedRatio, position.left * mapRatio - previousTranslateX * changedRatio, position.top * mapRatio - previousTranslateY * changedRatio);
                var transformX = raphaelMatrix.e / raphaelMatrix.a + previousTranslateX;
                var transformY = raphaelMatrix.f / raphaelMatrix.d + previousTranslateY;
                if (transformX >= 0) {
                  raphaelMatrix.e = -previousTranslateX * raphaelMatrix.a;
                } else if (transformX < currentLimitRight) {
                  raphaelMatrix.e = currentLimitRight - previousTranslateX;
                }
                if (transformY >= 0) {
                  raphaelMatrix.f = -previousTranslateY * raphaelMatrix.a;
                } else if (transformY < currentLimitTop) {
                  raphaelMatrix.f = currentLimitTop - previousTranslateY;
                }
                matrix.a = raphaelMatrix.a;
                matrix.b = raphaelMatrix.b;
                matrix.c = raphaelMatrix.c;
                matrix.d = raphaelMatrix.d;
                matrix.e = raphaelMatrix.e;
                matrix.f = raphaelMatrix.f;
                zoom.setMatrix(matrix);
                transformList.appendItem(zoom);
                transformList.initialize(transformList.consolidate());
              };
              RaphaelMapChart2.prototype.moveMapPaths = function moveMapPaths(distances, mapDimension) {
                var matrix = this.paper.canvas.createSVGMatrix();
                var raphaelMatrix = this.paper.raphael.matrix();
                var transformList = this.g.transform.baseVal;
                var translate = this.paper.canvas.createSVGTransform();
                var maxRight = mapDimension.width - this.dimension.width;
                var maxTop = mapDimension.height - this.dimension.height;
                var transformMatrix = transformList.numberOfItems ? transformList.getItem(0).matrix : {
                  a: 1,
                  b: 0,
                  c: 0,
                  d: 1,
                  e: 0,
                  f: 0
                };
                raphaelMatrix.translate(distances.x, distances.y);
                this._translateXForRaphaelMatrix({
                  raphaelMatrix,
                  transformMatrix,
                  maxRight
                });
                this._translateYForRaphaelMatrix({
                  raphaelMatrix,
                  transformMatrix,
                  maxTop
                });
                matrix.a = raphaelMatrix.a;
                matrix.b = raphaelMatrix.b;
                matrix.c = raphaelMatrix.c;
                matrix.d = raphaelMatrix.d;
                matrix.e = raphaelMatrix.e;
                matrix.f = raphaelMatrix.f;
                translate.setMatrix(matrix);
                transformList.appendItem(translate);
                transformList.initialize(transformList.consolidate());
              };
              RaphaelMapChart2.prototype._translateXForRaphaelMatrix = function _translateXForRaphaelMatrix(_ref) {
                var raphaelMatrix = _ref.raphaelMatrix, transformMatrix = _ref.transformMatrix, maxRight = _ref.maxRight;
                var currentTranslateX = raphaelMatrix.e / raphaelMatrix.a;
                var translateX = currentTranslateX + transformMatrix.e / transformMatrix.a;
                if (translateX >= 0 && currentTranslateX > 0) {
                  raphaelMatrix.e = 0;
                } else if (translateX < 0 && translateX < -maxRight / transformMatrix.a && currentTranslateX < 0) {
                  raphaelMatrix.e = 0;
                }
              };
              RaphaelMapChart2.prototype._translateYForRaphaelMatrix = function _translateYForRaphaelMatrix(_ref2) {
                var raphaelMatrix = _ref2.raphaelMatrix, transformMatrix = _ref2.transformMatrix, maxTop = _ref2.maxTop;
                var currentTranslateY = raphaelMatrix.f / raphaelMatrix.d;
                var translateY = currentTranslateY + transformMatrix.f / transformMatrix.d;
                if (translateY >= 0 && currentTranslateY > 0) {
                  raphaelMatrix.f = 0;
                } else if (translateY < 0 && translateY < -maxTop / transformMatrix.d && currentTranslateY < 0) {
                  raphaelMatrix.f = 0;
                }
              };
              RaphaelMapChart2.prototype.renderSeriesLabels = function renderSeriesLabels(paper, labelData, labelTheme) {
                var attributes = {
                  "font-size": labelTheme.fontSize,
                  "font-family": labelTheme.fontFamily,
                  "font-weight": labelTheme.fontWeight,
                  fill: labelTheme.color,
                  "text-anchor": "middle",
                  opacity: 0,
                  transform: _renderUtil2["default"].oneLineTrim(_templateObject2, this.ratio, this.ratio, this.position.left / this.ratio, this.position.top / this.ratio)
                };
                var set = paper.set();
                labelData.forEach(function(labelDatum) {
                  var position = labelDatum.position;
                  var label = _raphaelRenderUtil2["default"].renderText(paper, position, labelDatum.name || labelDatum.code, attributes);
                  set.push(label);
                  label.node.style.userSelect = "none";
                  label.node.style.cursor = "default";
                  label.node.setAttribute("filter", "url(#glow)");
                  if (!IS_LTE_IE8) {
                    self.g.appendChild(label.node);
                  }
                });
                return set;
              };
              return RaphaelMapChart2;
            }();
            function createGElement(paper, sectorSet, id) {
              var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
              g.id = id;
              sectorSet.forEach(function(sector) {
                _domHandler2["default"].append(g, sector.node);
              });
              paper.canvas.appendChild(g);
              return g;
            }
            exports2["default"] = RaphaelMapChart;
          },
          /* 41 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _templateObject = _taggedTemplateLiteral(["\n            M", "\n            ,", "\n            l", "\n            ,", "\n            l", "\n            ,-", "\n        "], ["\n            M", "\n            ,", "\n            l", "\n            ,", "\n            l", "\n            ,-", "\n        "]);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _isNumber = __webpack_require__(19);
            var _isNumber2 = _interopRequireDefault(_isNumber);
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _taggedTemplateLiteral(strings, raw) {
              return Object.freeze(Object.defineProperties(strings, {
                raw: {
                  value: Object.freeze(raw)
                }
              }));
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var UNSELECTED_LEGEND_LABEL_OPACITY = 0.5;
            var PAGINATION_POSITION_HEIGHT = 8;
            var PAGINATION_POSITION_WIDTH = 10;
            var PAGINATION_POSITION_HALF_WIDTH = PAGINATION_POSITION_WIDTH / 2;
            var PAGINATION_POSITION_PADDING = 3;
            function getIconWidth() {
              return _const2["default"].LEGEND_ICON_WIDTH + _const2["default"].LEGEND_LABEL_LEFT_PADDING;
            }
            var RaphaelLegendComponent = function() {
              function RaphaelLegendComponent2() {
                _classCallCheck(this, RaphaelLegendComponent2);
                this._checkBoxWidth = 0;
                this._checkBoxHeight = 0;
                this._legendItemHeight = 0;
                this._currentPageCount = 1;
                this._showCheckbox = true;
              }
              RaphaelLegendComponent2.prototype._renderLegendItems = function _renderLegendItems(legendData) {
                var _this = this;
                var labelPaddingLeft = _const2["default"].LEGEND_LABEL_LEFT_PADDING;
                var position = Object.assign({}, this.basePosition);
                legendData.forEach(function(legendDatum, index) {
                  var iconType = legendDatum.iconType, legendIndex = legendDatum.index, isUnselected = legendDatum.isUnselected, labelHeight = legendDatum.labelHeight, checkboxData = legendDatum.checkbox;
                  var legendColor = legendDatum.colorByPoint ? "#aaa" : legendDatum.theme.color;
                  var predicatedLegendWidth = position.left + _this._calculateSingleLegendWidth(legendIndex, iconType);
                  var isNeedBreakLine = predicatedLegendWidth >= _this.paper.width;
                  if (_this.isHorizontal && isNeedBreakLine) {
                    position.top += _this._legendItemHeight + _const2["default"].LABEL_PADDING_TOP;
                    position.left = _this.basePosition.left;
                  }
                  if (_this._showCheckbox) {
                    _this._renderCheckbox(position, {
                      isChecked: checkboxData.checked,
                      legendIndex,
                      legendSet: _this.legendSet
                    });
                    position.left += _this._checkBoxWidth + labelPaddingLeft;
                  }
                  _this._renderIcon(position, {
                    legendColor,
                    iconType,
                    labelHeight,
                    isUnselected,
                    legendIndex,
                    legendSet: _this.legendSet
                  });
                  position.left += _const2["default"].LEGEND_ICON_WIDTH + labelPaddingLeft;
                  _this._renderLabel(position, {
                    labelText: legendDatum.label,
                    labelHeight,
                    isUnselected,
                    legendIndex,
                    legendSet: _this.legendSet
                  });
                  if (_this.isHorizontal) {
                    position.left += _this.labelWidths[index] + _const2["default"].LEGEND_H_LABEL_RIGHT_PADDING;
                  } else {
                    position.left = _this.basePosition.left;
                    position.top += _this._legendItemHeight + _const2["default"].LINE_MARGIN_TOP;
                  }
                });
              };
              RaphaelLegendComponent2.prototype._getLegendData = function _getLegendData(legendData, sliceIndex) {
                var positionTop = this.basePosition.top;
                var totalHeight = this.dimension.height;
                var chartHeight = this.paper.height;
                var resultLegendData = legendData;
                if (!this.isHorizontal && totalHeight + positionTop * 2 > chartHeight) {
                  this._legendItemHeight = Math.max(legendData[0].labelHeight, _const2["default"].LEGEND_CHECKBOX_SIZE);
                  var pageHeight = chartHeight - positionTop * 2;
                  var singleItemHeight = this._legendItemHeight + _const2["default"].LINE_MARGIN_TOP;
                  var visibleItemCount = Math.floor(pageHeight / singleItemHeight);
                  resultLegendData = legendData.slice((sliceIndex - 1) * visibleItemCount, sliceIndex * visibleItemCount);
                }
                return resultLegendData;
              };
              RaphaelLegendComponent2.prototype.render = function render(data) {
                this.eventBus = data.eventBus;
                this.paper = data.paper;
                this.dimension = data.dimension;
                this.legendSet = this.paper.set();
                this.labelWidths = data.labelWidths;
                this.labelTheme = data.labelTheme;
                this.basePosition = data.position;
                this.isHorizontal = data.isHorizontal;
                this.originalLegendData = data.legendData;
                var paginationElem = [];
                if (this.originalLegendData.length) {
                  this._showCheckbox = (0, _isExisty2["default"])(data.legendData[0].checkbox);
                  this._setComponentDimensionsBaseOnLabelHeight(data.legendData[0].labelHeight);
                  var legendData = this._getLegendData(data.legendData, this._currentPageCount);
                  this._renderLegendItems(legendData);
                  if (!this.isHorizontal && legendData && legendData.length < data.legendData.length) {
                    var legendHeight = this.paper.height - this.basePosition.top * 2;
                    this.availablePageCount = Math.ceil(data.dimension.height / legendHeight);
                    paginationElem = this._renderPaginationArea(this.basePosition, {
                      width: data.dimension.width,
                      height: legendHeight
                    });
                  }
                }
                return {
                  legendSet: this.legendSet,
                  paginationElem
                };
              };
              RaphaelLegendComponent2.prototype._paginateLegendAreaTo = function _paginateLegendAreaTo(direction) {
                var pageNumber = this._currentPageCount;
                this._removeLegendItems();
                if (direction === "next") {
                  pageNumber += 1;
                } else {
                  pageNumber -= 1;
                }
                this._renderLegendItems(this._getLegendData(this.originalLegendData, pageNumber));
              };
              RaphaelLegendComponent2.prototype._removeLegendItems = function _removeLegendItems() {
                this.legendSet.forEach(function(legendItem) {
                  var events = legendItem.events || [];
                  events.forEach(function(event) {
                    event.unbind();
                  });
                  legendItem.remove();
                });
              };
              RaphaelLegendComponent2.prototype._renderPaginationArea = function _renderPaginationArea(position, dimension) {
                var _this2 = this;
                var LEGEND_PAGINATION_BUTTON_WIDTH = _const2["default"].LEGEND_PAGINATION_BUTTON_WIDTH, LEGEND_PAGINATION_BUTTON_PADDING_RIGHT = _const2["default"].LEGEND_PAGINATION_BUTTON_PADDING_RIGHT, LEGEND_AREA_V_PADDING = _const2["default"].LEGEND_AREA_V_PADDING, LEGEND_AREA_H_PADDING = _const2["default"].LEGEND_AREA_H_PADDING;
                var controllerPositionTop = position.top + dimension.height - LEGEND_AREA_V_PADDING;
                var controllerPositionLeft = position.left - LEGEND_AREA_H_PADDING;
                var leftButtonPositionLeft = controllerPositionLeft + LEGEND_AREA_H_PADDING;
                var rightButtonPositionLeft = _calculator2["default"].sum([leftButtonPositionLeft, LEGEND_PAGINATION_BUTTON_PADDING_RIGHT, LEGEND_PAGINATION_BUTTON_WIDTH]);
                var lowerArrowPath = ["M", rightButtonPositionLeft + 5, ",", controllerPositionTop + PAGINATION_POSITION_PADDING + 4, "L", rightButtonPositionLeft + PAGINATION_POSITION_HALF_WIDTH + 5, ",", controllerPositionTop + PAGINATION_POSITION_HEIGHT + 4, "L", rightButtonPositionLeft + PAGINATION_POSITION_WIDTH + 5, ",", controllerPositionTop + PAGINATION_POSITION_PADDING + 4].join("");
                var upperArrowPath = ["M", leftButtonPositionLeft + 5, ",", controllerPositionTop + PAGINATION_POSITION_HEIGHT + 4, "L", leftButtonPositionLeft + PAGINATION_POSITION_HALF_WIDTH + 5, ",", controllerPositionTop + PAGINATION_POSITION_PADDING + 4, "L", leftButtonPositionLeft + PAGINATION_POSITION_WIDTH + 5, ",", controllerPositionTop + PAGINATION_POSITION_HEIGHT + 4].join("");
                var prevRect = this._renderPaginationRect({
                  top: controllerPositionTop,
                  left: leftButtonPositionLeft
                });
                var lineStyle = {
                  color: "#555",
                  strokeWidth: 2
                };
                var prevArrow = _raphaelRenderUtil2["default"].renderLine(this.paper, upperArrowPath, lineStyle);
                var nextRect = this._renderPaginationRect({
                  top: controllerPositionTop,
                  left: rightButtonPositionLeft
                });
                var nextArrow = _raphaelRenderUtil2["default"].renderLine(this.paper, lowerArrowPath, lineStyle);
                var prevButtonSet = this.paper.set();
                var nextButtonSet = this.paper.set();
                prevRect.className = "tui-chart-icon";
                prevButtonSet.push(prevRect);
                prevButtonSet.push(prevArrow);
                nextRect.className = "tui-chart-icon";
                nextButtonSet.push(nextRect);
                nextButtonSet.push(nextArrow);
                prevButtonSet.click(function() {
                  if (_this2._currentPageCount > 1) {
                    _this2._paginateLegendAreaTo("previous");
                    _this2._currentPageCount -= 1;
                  }
                });
                nextButtonSet.click(function() {
                  if (_this2._currentPageCount < _this2.availablePageCount) {
                    _this2._paginateLegendAreaTo("next");
                    _this2._currentPageCount += 1;
                  }
                });
                return [prevButtonSet, nextButtonSet];
              };
              RaphaelLegendComponent2.prototype._renderPaginationRect = function _renderPaginationRect(position) {
                var BUTTON_SIZE = _const2["default"].LEGEND_PAGINATION_BUTTON_WIDTH;
                var bound = {
                  left: position.left,
                  top: position.top,
                  width: BUTTON_SIZE,
                  height: BUTTON_SIZE
                };
                var rect = _raphaelRenderUtil2["default"].renderRect(this.paper, bound, {
                  fill: "#f4f4f4",
                  rx: "1px",
                  ry: "1px",
                  stroke: "none"
                });
                return rect;
              };
              RaphaelLegendComponent2.prototype.makeLabelWidths = function makeLabelWidths(legendData, theme, maxWidth) {
                return legendData.map(function(item) {
                  var labelWidth = _raphaelRenderUtil2["default"].getRenderedTextSize(item.label, theme.fontSize, theme.fontFamily).width;
                  if (maxWidth && labelWidth > maxWidth) {
                    labelWidth = maxWidth;
                  }
                  return labelWidth + _const2["default"].LEGEND_LABEL_LEFT_PADDING;
                });
              };
              RaphaelLegendComponent2.prototype.getRenderedLabelHeight = function getRenderedLabelHeight(labelText, theme) {
                return _raphaelRenderUtil2["default"].getRenderedTextSize(labelText, theme.fontSize, theme.fontFamily).height;
              };
              RaphaelLegendComponent2.prototype._renderLabel = function _renderLabel(position, data) {
                var eventBus = this.eventBus, labelTheme = this.labelTheme;
                var pos = {
                  left: position.left,
                  top: position.top + this._legendItemHeight / 2
                };
                var attributes = {
                  fill: labelTheme.color,
                  "font-size": labelTheme.fontSize,
                  "font-family": labelTheme.fontFamily,
                  "font-weight": labelTheme.fontWeight,
                  opacity: data.isUnselected ? UNSELECTED_LEGEND_LABEL_OPACITY : 1,
                  "text-anchor": "start"
                };
                var label = _raphaelRenderUtil2["default"].renderText(this.paper, pos, data.labelText, attributes);
                label.data("index", data.legendIndex);
                label.node.style.userSelect = "none";
                label.node.style.cursor = "pointer";
                data.legendSet.push(label);
                label.click(function() {
                  eventBus.fire("labelClicked", data.legendIndex);
                });
              };
              RaphaelLegendComponent2.prototype._renderCheckbox = function _renderCheckbox(position, data) {
                var _this3 = this;
                var left = position.left;
                var top = position.top + (this._legendItemHeight - this._checkBoxHeight) / 2;
                var checkboxPathSize = this._checkBoxWidth / 3;
                var checkboxPathHalpSize = this._checkBoxWidth / 5.7;
                var vPathString = _renderUtil2["default"].oneLineTrim(_templateObject, this._checkBoxWidth * 0.25 + left, this._checkBoxHeight * 0.5 + top, checkboxPathHalpSize, checkboxPathHalpSize, checkboxPathSize, checkboxPathSize);
                var checkboxSet = this.paper.set();
                var checkboxElement = this.paper.rect(left, top, this._checkBoxWidth, this._checkBoxHeight, 0).attr({
                  fill: "#fff",
                  stroke: "#aaa",
                  "stroke-width": 1
                });
                checkboxElement.node.setAttribute("class", "auto-shape-rendering");
                checkboxSet.push(checkboxElement);
                if (data.isChecked) {
                  var checkElement = this.paper.path(vPathString).attr({
                    stroke: "#555",
                    "stroke-width": 2
                  });
                  checkElement.node.setAttribute("class", "auto-shape-rendering");
                  checkboxSet.push(checkElement);
                }
                checkboxSet.data("index", data.legendIndex);
                checkboxSet.click(function() {
                  _this3.eventBus.fire("checkboxClicked", data.legendIndex);
                });
                checkboxSet.forEach(function(checkbox) {
                  data.legendSet.push(checkbox);
                });
              };
              RaphaelLegendComponent2.prototype._renderIcon = function _renderIcon(position, data) {
                var _this4 = this;
                var icon = void 0;
                this.paper.setStart();
                if ((data.iconType === "line" || data.iconType === "radial") && this.paper.canvas.transform) {
                  icon = this.paper.path(_const2["default"].LEGEND_LINE_ICON_PATH);
                  icon.attr({
                    stroke: data.legendColor,
                    "stroke-width": 2,
                    "stroke-opacity": data.isUnselected ? UNSELECTED_LEGEND_LABEL_OPACITY : 1
                  });
                  icon.translate(position.left, position.top);
                } else {
                  icon = _raphaelRenderUtil2["default"].renderRect(this.paper, {
                    left: position.left,
                    top: position.top + (_const2["default"].LEGEND_CHECKBOX_SIZE - _const2["default"].LEGEND_ICON_HEIGHT) / 2,
                    width: _const2["default"].LEGEND_ICON_WIDTH,
                    height: _const2["default"].LEGEND_ICON_HEIGHT
                  }, {
                    "stroke-width": 0,
                    fill: data.legendColor,
                    opacity: data.isUnselected ? UNSELECTED_LEGEND_LABEL_OPACITY : 1
                  });
                }
                icon.data("icon", data.iconType);
                icon.data("index", data.legendIndex);
                icon.click(function() {
                  _this4.eventBus.fire("labelClicked", data.legendIndex);
                });
                data.legendSet.push(icon);
              };
              RaphaelLegendComponent2.prototype.selectLegend = function selectLegend(index, legendSet) {
                legendSet.forEach(function(element) {
                  var indexData = element.data("index");
                  var attributeName = element.data("icon") === "line" ? "stroke-opacity" : "opacity";
                  if ((0, _isNull2["default"])(indexData) || (0, _isUndefined2["default"])(indexData)) {
                    element.attr(attributeName, 1);
                  } else if (!(0, _isUndefined2["default"])(indexData)) {
                    if ((0, _isNumber2["default"])(index) && indexData !== index) {
                      element.attr(attributeName, UNSELECTED_LEGEND_LABEL_OPACITY);
                    } else {
                      element.attr(attributeName, 1);
                    }
                  }
                });
              };
              RaphaelLegendComponent2.prototype._getCheckboxWidth = function _getCheckboxWidth() {
                return this._showCheckbox ? this._checkBoxWidth + _const2["default"].LEGEND_LABEL_LEFT_PADDING : 0;
              };
              RaphaelLegendComponent2.prototype._getLabelWidth = function _getLabelWidth(index) {
                var labelWidth = void 0;
                if (index) {
                  labelWidth = this.labelWidths[index] || 0;
                } else {
                  labelWidth = _arrayUtil2["default"].max(this.labelWidths);
                }
                return labelWidth;
              };
              RaphaelLegendComponent2.prototype._calculateLegendWidth = function _calculateLegendWidth() {
                return this._calculateSingleLegendWidth();
              };
              RaphaelLegendComponent2.prototype._calculateSingleLegendWidth = function _calculateSingleLegendWidth(legendIndex) {
                return _const2["default"].LEGEND_AREA_H_PADDING + this._getCheckboxWidth() + getIconWidth() + this._getLabelWidth(legendIndex) + _const2["default"].LEGEND_AREA_H_PADDING;
              };
              RaphaelLegendComponent2.prototype._setComponentDimensionsBaseOnLabelHeight = function _setComponentDimensionsBaseOnLabelHeight(labelHeight) {
                this._legendItemHeight = Math.max(labelHeight, _const2["default"].LEGEND_CHECKBOX_SIZE);
                this._checkBoxWidth = this._checkBoxHeight = _const2["default"].LEGEND_CHECKBOX_SIZE;
              };
              return RaphaelLegendComponent2;
            }();
            exports2["default"] = RaphaelLegendComponent;
          },
          /* 42 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _range = __webpack_require__(13);
            var _range2 = _interopRequireDefault(_range);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var PERCENT_DIVISOR = 100;
            var calculator = {
              /**
               * Calculate limit from chart min, max data.
               *  - http://peltiertech.com/how-excel-calculates-automatic-chart-axis-limits/
               * @memberOf module:calculator
               * @param {number} min min minimum value of user data
               * @param {number} max max maximum value of user data
               * @returns {{min: number, max: number}} limit axis limit
               */
              calculateLimit: function calculateLimit(min, max) {
                var limit = {};
                var saveMin = 0;
                if (min < 0) {
                  saveMin = min;
                  max -= min;
                  min = 0;
                }
                var iodValue = (max - min) / 20;
                limit.max = max + iodValue + saveMin;
                if (max / 6 > min) {
                  limit.min = saveMin;
                } else {
                  limit.min = min - iodValue + saveMin;
                }
                return limit;
              },
              /**
               * Make tick positions of pixel type.
               * @memberOf module:calculator
               * @param {number} size area width or height
               * @param {number} count tick count
               * @param {?number} additionalPosition additional position
               * @param {?number} remainLastBlockIntervalPosition remainLastBlockInterval position
               * @returns {Array.<number>} positions
               */
              makeTickPixelPositions: function makeTickPixelPositions(size, count, additionalPosition, remainLastBlockIntervalPosition) {
                var positions = [];
                additionalPosition = additionalPosition || 0;
                if (count > 0) {
                  positions = (0, _range2["default"])(0, count).map(function(index) {
                    var ratio = index === 0 ? 0 : index / (count - 1);
                    return ratio * size + additionalPosition;
                  });
                  positions[positions.length - 1] -= 1;
                }
                if (remainLastBlockIntervalPosition) {
                  positions.push(remainLastBlockIntervalPosition);
                }
                return positions;
              },
              /**
               * Make labels from limit.
               * @memberOf module:calculator
               * @param {{min: number, max: number}} limit axis limit
               * @param {number} step step between max and min
               * @returns {string[]} labels
               * @private
               */
              makeLabelsFromLimit: function makeLabelsFromLimit(limit, step) {
                var multipleNum = calculator.findMultipleNum(step);
                var min = Math.round(limit.min * multipleNum);
                var max = Math.round(limit.max * multipleNum);
                var labels = (0, _range2["default"])(min, max + 1, step * multipleNum);
                return labels.map(function(label) {
                  return label / multipleNum;
                });
              },
              /**
               * Calculate step from limit.
               * @memberOf module:calculator
               * @param {{min: number, max: number}} limit axis limit
               * @param {number} count value count
               * @returns {number} step
               */
              calculateStepFromLimit: function calculateStepFromLimit(limit, count) {
                return calculator.divide(calculator.subtract(limit.max, limit.min), count - 1);
              },
              /**
               * Sum plus values.
               * @param {Array.<number>} values values
               * @returns {number} sum
               */
              sumPlusValues: function sumPlusValues(values) {
                var plusValues = values.filter(function(value) {
                  return value > 0;
                });
                return calculator.sum(plusValues);
              },
              /**
               * Sum minus values.
               * @param {Array.<number>} values values
               * @returns {number} sum
               */
              sumMinusValues: function sumMinusValues(values) {
                var minusValues = values.filter(function(value) {
                  return value < 0;
                });
                return calculator.sum(minusValues);
              },
              /**
               * Make percentage value.
               * @param {number} value - value
               * @param {number} totalValue - total value
               * @returns {number}
               */
              makePercentageValue: function makePercentageValue(value, totalValue) {
                return value / totalValue * PERCENT_DIVISOR;
              },
              /**
               * Calculate ratio for making bound.
               * @param {number} value - value
               * @param {number} divNumber - number for division
               * @param {number} subNumber - number for subtraction
               * @param {number} baseRatio - base ratio
               * @returns {number}
               */
              calculateRatio: function calculateRatio(value, divNumber, subNumber, baseRatio) {
                return divNumber ? (value - subNumber) / divNumber * baseRatio : 0;
              }
            };
            var getDecimalLength = function getDecimalLength2(value) {
              var valueArr = String(value).split(".");
              return valueArr.length === 2 ? valueArr[1].length : 0;
            };
            var findMultipleNum = function findMultipleNum2() {
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              var underPointLens = args.map(function(value) {
                return calculator.getDecimalLength(value);
              });
              var underPointLen = _arrayUtil2["default"].max(underPointLens);
              return Math.pow(10, underPointLen);
            };
            var mod = function mod2(target, modNum) {
              var multipleNum = calculator.findMultipleNum(modNum);
              var result = void 0;
              if (multipleNum === 1) {
                result = target % modNum;
              } else {
                result = target * multipleNum % (modNum * multipleNum) / multipleNum;
              }
              return result;
            };
            var add = function add2(a, b) {
              var multipleNum = calculator.findMultipleNum(a, b);
              return (a * multipleNum + b * multipleNum) / multipleNum;
            };
            var subtract = function subtract2(a, b) {
              var multipleNum = calculator.findMultipleNum(a, b);
              return (a * multipleNum - b * multipleNum) / multipleNum;
            };
            var multiply = function multiply2(a, b) {
              var multipleNum = calculator.findMultipleNum(a, b);
              return a * multipleNum * (b * multipleNum) / (multipleNum * multipleNum);
            };
            var divide = function divide2(a, b) {
              var multipleNum = calculator.findMultipleNum(a, b);
              return a * multipleNum / (b * multipleNum);
            };
            var sum = function sum2(values) {
              var copyArr = values.slice();
              copyArr.unshift(0);
              return copyArr.reduce(function(base, value) {
                return calculator.add(parseFloat(base), parseFloat(value));
              });
            };
            var divisors = function divisors2(value) {
              var result = [];
              for (var a = 2, b; a * a <= value; a += 1) {
                if (value % a === 0) {
                  b = value / a;
                  result.push(a);
                  if (b !== a) {
                    result.push(b);
                  }
                }
              }
              result.sort(function(prev, next) {
                return prev - next;
              });
              return result;
            };
            calculator.getDecimalLength = getDecimalLength;
            calculator.findMultipleNum = findMultipleNum;
            calculator.mod = mod;
            calculator.add = add;
            calculator.subtract = subtract;
            calculator.multiply = multiply;
            calculator.divide = divide;
            calculator.divisors = divisors;
            calculator.sum = sum;
            exports2["default"] = calculator;
          },
          /* 43 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var DEGREE_HORIZONTAL_BAR = 360;
            var DEGREE_VERTICAL_BAR = 270;
            var WEDGE_BASE_HALF = 2.5;
            var RaphaelMapLegend = function() {
              function RaphaelMapLegend2() {
                _classCallCheck(this, RaphaelMapLegend2);
                this.verticalRightBasePath = ["M", -4, 0, "L", -8, 2.5, "L", -8, 12.5, "L", -28, 12.5, "L", -28, -12.5, "L", -8, -12.5, "L", -8, -2.5];
                this.verticalLeftBasePath = ["M", 10, 0, "L", 14, 2.5, "L", 14, 12.5, "L", 34, 12.5, "L", 34, -12.5, "L", 14, -12.5, "L", 14, -2.5];
                this.horizontalTopBasePath = ["M", 0, 10, "L", 2.5, 14, "L", 12.5, 14, "L", 12.5, 34, "L", -12.5, 34, "L", -12.5, 14, "L", -2.5, 14];
                this.horizontalBottomBasePath = ["M", 0, -4, "L", 2.5, -8, "L", 12.5, -8, "L", 12.5, -28, "L", -12.5, -28, "L", -12.5, -8, "L", -2.5, -8];
              }
              RaphaelMapLegend2.prototype.render = function render(param) {
                var layout = param.layout, align = param.align, legendSet = param.legendSet, theme = param.theme, labels = param.labels;
                var isHorizontal = _predicate2["default"].isHorizontalLegend(align);
                var _labels = _slicedToArray(labels, 1), minLabel = _labels[0];
                var maxLabel = labels[labels.length - 1];
                var maxLabelWidth = _renderUtil2["default"].getRenderedLabelsMaxWidth([minLabel, maxLabel]);
                var labelHeight = _renderUtil2["default"].getRenderedLabelHeight(minLabel, theme);
                var isBoxTypeChart = _predicate2["default"].isBoxTypeChart(this.chartType);
                var position = layout.position;
                this.layout = layout;
                this.isHorizontal = isHorizontal;
                this.isLeftLegend = _predicate2["default"].isLegendAlignLeft(align);
                this.isTopLegend = _predicate2["default"].isLegendAlignTop(align);
                this.theme = theme;
                this.paper = param.paper;
                this.legendSet = param.legendSet;
                this.colorSpectrum = param.colorSpectrum;
                if (_predicate2["default"].isLegendAlignTop(align)) {
                  position.top += _const2["default"].MAP_LEGEND_AREA_PADDING_WIDE + labelHeight + _const2["default"].MAP_LEGEND_LABEL_PADDING * 2;
                } else if (_predicate2["default"].isLegendAlignBottom(align)) {
                  position.top += this._calculateHorizontalLegendTooltipHeight(labels, theme) + _const2["default"].MAP_LEGEND_PADDING_BTW_GRAPH_AND_WEDGE;
                  if (isBoxTypeChart) {
                    position.top -= _const2["default"].MAP_LEGEND_TOOLTIP_VERTICAL_PADDING;
                  } else {
                    position.top += _const2["default"].MAP_LEGEND_AREA_PADDING_WIDE;
                  }
                } else if (_predicate2["default"].isLegendAlignLeft(align)) {
                  position.left += maxLabelWidth + _const2["default"].MAP_LEGEND_LABEL_PADDING;
                } else {
                  position.left = layout.position.right - maxLabelWidth - _const2["default"].MAP_LEGEND_LABEL_PADDING - _const2["default"].MAP_LEGEND_GRAPH_SIZE;
                }
                var gradientBar = this._renderGradientBar(this.paper, layout, this.colorSpectrum, isHorizontal);
                legendSet.push(gradientBar);
                this.wedge = this._renderWedge(this.paper, position);
                this.wedgeText = this._renderWedgeText(this.paper, position, theme);
                legendSet.push(this.wedge);
                this.gradientBar = gradientBar;
              };
              RaphaelMapLegend2.prototype.renderTickLabels = function renderTickLabels(paper, baseData, labels, align, legendSet) {
                var _this = this;
                var theme = this.theme;
                var attribute = {
                  "font-size": theme.fontSize,
                  "font-family": theme.fontFamily,
                  "font-weight": theme.fontWeight,
                  fill: "#000"
                };
                var _labels2 = _slicedToArray(labels, 1), minLabel = _labels2[0];
                var maxLabel = labels[labels.length - 1];
                var maxLabelWidth = _renderUtil2["default"].getRenderedLabelsMaxWidth([minLabel, maxLabel]);
                var labelHeight = _renderUtil2["default"].getRenderedLabelHeight(minLabel, theme);
                labels.forEach(function(label, labelIndex) {
                  var offsetValue = baseData.step * labelIndex;
                  var pos = Object.assign({}, baseData.position);
                  if (_predicate2["default"].isHorizontalLegend(align)) {
                    pos.left += offsetValue;
                    if (_this.isTopLegend) {
                      pos.top -= labelHeight / 2;
                    } else {
                      pos.top += labelHeight / 2;
                    }
                  } else {
                    pos.top += offsetValue;
                    if (_this.isLeftLegend) {
                      attribute["text-anchor"] = "end";
                      pos.left = _const2["default"].CHART_PADDING + maxLabelWidth;
                    } else {
                      attribute["text-anchor"] = "start";
                    }
                  }
                  legendSet.push(_raphaelRenderUtil2["default"].renderText(paper, pos, label, attribute));
                }, this);
              };
              RaphaelMapLegend2.prototype._renderGradientBar = function _renderGradientBar(paper, layout, colorSpectrum, isHorizontal) {
                var width = void 0, height = void 0, degree = void 0;
                if (isHorizontal) {
                  width = layout.dimension.width;
                  height = _const2["default"].MAP_LEGEND_GRAPH_SIZE;
                  degree = DEGREE_HORIZONTAL_BAR;
                  this._makeWedghPath = this._makeHorizontalWedgePath;
                } else {
                  width = _const2["default"].MAP_LEGEND_GRAPH_SIZE;
                  height = layout.dimension.height;
                  degree = DEGREE_VERTICAL_BAR;
                  this._makeWedghPath = this._makeVerticalWedgePath;
                }
                var bound = {
                  left: layout.position.left,
                  top: layout.position.top,
                  width,
                  height
                };
                return _raphaelRenderUtil2["default"].renderRect(paper, bound, {
                  fill: degree + "-" + colorSpectrum.start + "-" + colorSpectrum.end,
                  stroke: "none"
                });
              };
              RaphaelMapLegend2.prototype._renderWedgeText = function _renderWedgeText(paper, position, theme) {
                if (this.isLeftLegend) {
                  position.left += _const2["default"].MAP_LEGEND_WEDGE_SIZE + _const2["default"].MAP_LEGEND_TOOLTIP_HORIZONTAL_PADDING;
                }
                return _raphaelRenderUtil2["default"].renderText(paper, position, "", {
                  "font-size": theme.fontSize,
                  "font-family": theme.fontFamily,
                  "font-weight": theme.fontWeight,
                  fill: theme.color
                });
              };
              RaphaelMapLegend2.prototype._renderWedge = function _renderWedge(paper, position) {
                return paper.path(this.verticalBasePath).attr({
                  fill: "gray",
                  stroke: "white",
                  "stroke-opacity": 0.2,
                  opacity: 0,
                  transform: "t" + position.left + "," + position.top
                });
              };
              RaphaelMapLegend2.prototype._makeVerticalWedgePath = function _makeVerticalWedgePath(top, labelDimension) {
                var isLeftLegend = this.isLeftLegend;
                var path = this.verticalBasePath = isLeftLegend ? this.verticalLeftBasePath : this.verticalRightBasePath;
                var PADDING_H = _const2["default"].MAP_LEGEND_TOOLTIP_HORIZONTAL_PADDING, PADDING_V = _const2["default"].MAP_LEGEND_TOOLTIP_VERTICAL_PADDING;
                var labelWidth = labelDimension.width, labelHeight = labelDimension.height;
                path[2] = top;
                path[5] = top + WEDGE_BASE_HALF;
                path[8] = path[11] = top + labelHeight / 2 + PADDING_V;
                path[14] = path[17] = top - labelHeight / 2 - PADDING_V;
                path[20] = top - WEDGE_BASE_HALF;
                if (isLeftLegend) {
                  path[10] = path[13] = path[4] + labelWidth + PADDING_H * 2;
                } else {
                  path[10] = path[13] = path[4] - labelWidth - PADDING_H * 2;
                }
                return path;
              };
              RaphaelMapLegend2.prototype._makeHorizontalWedgePath = function _makeHorizontalWedgePath(left, labelDimension) {
                var path = this.horiziontalBaseBath = this.isTopLegend ? this.horizontalTopBasePath : this.horizontalBottomBasePath;
                var PADDING_H = _const2["default"].MAP_LEGEND_TOOLTIP_HORIZONTAL_PADDING, PADDING_V = _const2["default"].MAP_LEGEND_TOOLTIP_VERTICAL_PADDING;
                var labelWidth = labelDimension.width, labelHeight = labelDimension.height;
                path[1] = left;
                path[4] = left + WEDGE_BASE_HALF;
                path[7] = path[10] = left + labelWidth / 2 + PADDING_H;
                path[13] = path[16] = left - labelWidth / 2 - PADDING_H;
                path[19] = left - WEDGE_BASE_HALF;
                if (this.isTopLegend) {
                  path[11] = path[14] = path[5] + labelHeight + PADDING_V * 2;
                } else {
                  path[11] = path[14] = path[5] - labelHeight - PADDING_V * 2;
                }
                return path;
              };
              RaphaelMapLegend2.prototype.showWedge = function showWedge(ratio, label) {
                var labelTheme = this.theme;
                var labelSize = _raphaelRenderUtil2["default"].getRenderedTextSize(label, labelTheme.fontSize, labelTheme.fontFamily);
                var legendSize = this.isHorizontal ? this.layout.dimension.width : this.layout.dimension.height;
                var path = this._makeWedghPath(legendSize * ratio, labelSize);
                this.wedge.attr({
                  path,
                  opacity: 1,
                  fill: this.colorSpectrum.getColor(ratio)
                });
                var wedgeBBox = this.wedge.getBBox();
                var wedgeTextTop = _calculator2["default"].sum([wedgeBBox.y, _const2["default"].MAP_LEGEND_TOOLTIP_VERTICAL_PADDING, labelSize.height / 2]);
                var wedgeTextLeft = _calculator2["default"].sum([wedgeBBox.x, _const2["default"].MAP_LEGEND_TOOLTIP_HORIZONTAL_PADDING, labelSize.width / 2]);
                if (this.isLeftLegend) {
                  wedgeTextLeft += _const2["default"].MAP_LEGEND_WEDGE_SIZE;
                }
                if (this.isTopLegend) {
                  wedgeTextTop += _const2["default"].MAP_LEGEND_WEDGE_SIZE;
                }
                this.wedgeText.attr({
                  x: wedgeTextLeft,
                  y: wedgeTextTop,
                  text: label,
                  opacity: 1
                });
                this.wedge.toFront();
                this.wedgeText.toFront();
              };
              RaphaelMapLegend2.prototype.hideWedge = function hideWedge() {
                this.wedge.attr({
                  opacity: 0
                });
                this.wedgeText.attr({
                  opacity: 0
                });
              };
              RaphaelMapLegend2.prototype.removeLocationURLFromFillAttribute = function removeLocationURLFromFillAttribute() {
                var gradientBar = this.gradientBar;
                var fillURL = gradientBar.node.getAttribute("fill");
                var locationUrlRegExp = /url\('?([^#]+)#[^#]+'?\)/;
                var _locationUrlRegExp$ex = locationUrlRegExp.exec(fillURL);
                var _locationUrlRegExp$ex2 = _slicedToArray(_locationUrlRegExp$ex, 2);
                this.locationURL = _locationUrlRegExp$ex2[1];
                gradientBar.node.setAttribute("fill", fillURL.replace(this.locationURL, ""));
              };
              RaphaelMapLegend2.prototype.restoreLocationURLToFillAttribute = function restoreLocationURLToFillAttribute() {
                var gradientBar = this.gradientBar;
                var fillURL = gradientBar.node.getAttribute("fill");
                gradientBar.node.setAttribute("fill", fillURL.replace("#", this.locationURL + "#"));
              };
              RaphaelMapLegend2.prototype._calculateHorizontalLegendTooltipHeight = function _calculateHorizontalLegendTooltipHeight(labels, theme) {
                var label = labels.length ? labels[labels.length - 1] : "";
                var labelHeight = _renderUtil2["default"].getRenderedLabelHeight(label, theme);
                return _calculator2["default"].sum([_const2["default"].MAP_LEGEND_TOOLTIP_VERTICAL_PADDING * 2, labelHeight, _const2["default"].MAP_LEGEND_WEDGE_SIZE]);
              };
              RaphaelMapLegend2.prototype._calculateVerticalLegendTooltipWidth = function _calculateVerticalLegendTooltipWidth(labels, theme) {
                var label = labels.length ? labels[labels.length - 1] : "";
                var labelWidth = _renderUtil2["default"].getRenderedLabelWidth(label, theme);
                return _calculator2["default"].sum([_const2["default"].MAP_LEGEND_TOOLTIP_HORIZONTAL_PADDING * 2, labelWidth, _const2["default"].MAP_LEGEND_WEDGE_SIZE]);
              };
              return RaphaelMapLegend2;
            }();
            exports2["default"] = RaphaelMapLegend;
          },
          /* 44 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var RaphaelCircleLegend = function() {
              function RaphaelCircleLegend2() {
                _classCallCheck(this, RaphaelCircleLegend2);
              }
              RaphaelCircleLegend2.prototype.render = function render(paper, layout, maxRadius, radiusRatios, labels) {
                var left = layout.position.left + layout.dimension.width / 2;
                var circleLegendSet = paper.set();
                radiusRatios.forEach(function(ratio, index) {
                  var radius = maxRadius * ratio;
                  var top = layout.position.top + layout.dimension.height - radius;
                  var circle = _raphaelRenderUtil2["default"].renderCircle(paper, {
                    left,
                    top
                  }, radius, {
                    fill: "none",
                    opacity: 1,
                    stroke: "#888",
                    "stroke-width": 1
                  });
                  circleLegendSet.push(circle);
                  circleLegendSet.push(_raphaelRenderUtil2["default"].renderText(paper, {
                    left,
                    top: top - radius - 5
                  }, labels[index]));
                });
                return circleLegendSet;
              };
              return RaphaelCircleLegend2;
            }();
            exports2["default"] = RaphaelCircleLegend;
          },
          /* 45 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var RaphaelTitleComponent = function() {
              function RaphaelTitleComponent2() {
                _classCallCheck(this, RaphaelTitleComponent2);
              }
              RaphaelTitleComponent2.prototype.render = function render(renderInfo) {
                var paper = renderInfo.paper, titleText = renderInfo.titleText, offset = renderInfo.offset, theme = renderInfo.theme, _renderInfo$align = renderInfo.align, align = _renderInfo$align === void 0 ? _const2["default"].TITLE_ALIGN_LEFT : _renderInfo$align, chartTitleAreaWidth = renderInfo.chartTitleAreaWidth;
                var fontSize = theme.fontSize, fontFamily = theme.fontFamily;
                var titleSize = _raphaelRenderUtil2["default"].getRenderedTextSize(titleText, fontSize, fontFamily);
                var titleSet = paper.set();
                var pos = this.getTitlePosition(titleSize, align, chartTitleAreaWidth, offset);
                var textAnchorAlign = {
                  left: "start",
                  right: "end",
                  center: "middle"
                };
                titleSet.push(_raphaelRenderUtil2["default"].renderText(paper, pos, titleText, {
                  "font-family": theme.fontFamily,
                  "font-size": theme.fontSize,
                  "font-weight": theme.fontWeight,
                  fill: theme.color,
                  "text-anchor": textAnchorAlign[align]
                }));
                return titleSet;
              };
              RaphaelTitleComponent2.prototype.getTitlePosition = function getTitlePosition(titleSize, align, chartWidth, offset) {
                var left = void 0;
                if (align === _const2["default"].TITLE_ALIGN_CENTER) {
                  left = chartWidth / 2;
                } else if (align === _const2["default"].TITLE_ALIGN_RIGHT) {
                  left = chartWidth;
                } else {
                  left = _const2["default"].CHART_PADDING;
                }
                var pos = {
                  left,
                  top: _const2["default"].CHART_PADDING + titleSize.height / 2
                  // for renderText's baseline
                };
                if (offset) {
                  if (offset.x) {
                    pos.left += offset.x;
                  } else if (offset.y) {
                    pos.top += offset.y;
                  }
                }
                return pos;
              };
              RaphaelTitleComponent2.prototype.resize = function resize(chartWidth, titleSet) {
                titleSet.attr({
                  left: _const2["default"].CHART_PADDING
                });
              };
              return RaphaelTitleComponent2;
            }();
            exports2["default"] = RaphaelTitleComponent;
          },
          /* 46 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var Y_AXIS_TITLE_PADDING = _const2["default"].Y_AXIS_TITLE_PADDING, AXIS_BACKGROUND_RIGHT_PADDING = _const2["default"].AXIS_BACKGROUND_RIGHT_PADDING;
            var RaphaelAxisComponent = function() {
              function RaphaelAxisComponent2() {
                _classCallCheck(this, RaphaelAxisComponent2);
                this.ticks = [];
              }
              RaphaelAxisComponent2.prototype.renderBackground = function renderBackground(paper, position, dimension, theme) {
                var background = theme && theme.background || {};
                var _background$color = background.color, color = _background$color === void 0 ? "#fff" : _background$color, _background$opacity = background.opacity, opacity = _background$opacity === void 0 ? 1 : _background$opacity;
                return _raphaelRenderUtil2["default"].renderRect(paper, {
                  left: 0,
                  top: position.top,
                  width: dimension.width + position.left - AXIS_BACKGROUND_RIGHT_PADDING,
                  height: dimension.height
                }, {
                  fill: color,
                  opacity,
                  "stroke-width": 0
                });
              };
              RaphaelAxisComponent2.prototype.renderTitle = function renderTitle(paper, data) {
                var theme = data.theme, rotationInfo = data.rotationInfo;
                var fontFamily = theme.fontFamily, fontSize = theme.fontSize, fontWeight = theme.fontWeight, color = theme.color;
                var textAnchor = this.getRenderTitleAnchor(rotationInfo);
                var attributes = {
                  "dominant-baseline": "auto",
                  "font-family": fontFamily,
                  "font-size": fontSize,
                  "font-weight": fontWeight,
                  fill: color,
                  transform: "none",
                  "text-anchor": textAnchor
                };
                var position = this.calculatePosition(paper, data);
                var title = _raphaelRenderUtil2["default"].renderText(paper, position, data.text, attributes);
                title.node.style.userSelect = "none";
                title.node.style.cursor = "default";
                data.set.push(title);
              };
              RaphaelAxisComponent2.prototype.getRenderTitleAnchor = function getRenderTitleAnchor(rotationInfo) {
                var textAnchor = "middle";
                if (rotationInfo.isPositionRight || !rotationInfo.isVertical && !rotationInfo.isXAxisTitleLeft) {
                  textAnchor = "end";
                } else if (rotationInfo.isVertical && !rotationInfo.isCenter || !rotationInfo.isVertical && rotationInfo.isXAxisTitleLeft) {
                  textAnchor = "start";
                }
                return textAnchor;
              };
              RaphaelAxisComponent2.prototype.renderLabel = function renderLabel(data) {
                var positionTopAndLeft = data.positionTopAndLeft, labelText = data.labelText, paper = data.paper, theme = data.theme, isVertical = data.isVertical, isCenter = data.isCenter;
                var attributes = {
                  "dominant-baseline": "central",
                  "font-family": theme.fontFamily,
                  "font-size": theme.fontSize,
                  "font-weight": theme.fontWeight,
                  fill: theme.color
                };
                if (data.isPositionRight) {
                  attributes["text-anchor"] = "end";
                } else if (isVertical && !isCenter) {
                  attributes["text-anchor"] = "start";
                } else {
                  attributes["text-anchor"] = "middle";
                }
                var textObj = _raphaelRenderUtil2["default"].renderText(paper, positionTopAndLeft, labelText, attributes);
                textObj.node.style.userSelect = "none";
                textObj.node.style.cursor = "default";
                data.set.push(textObj);
                this.ticks.push(textObj);
              };
              RaphaelAxisComponent2.prototype.renderRotatedLabel = function renderRotatedLabel(data) {
                var positionTopAndLeft = data.positionTopAndLeft, labelText = data.labelText, paper = data.paper, theme = data.theme;
                var textObj = _raphaelRenderUtil2["default"].renderText(paper, positionTopAndLeft, labelText, {
                  "dominant-baseline": "central",
                  "font-family": theme.fontFamily,
                  "font-size": theme.fontSize,
                  "font-weight": theme.fontWeight,
                  fill: theme.color,
                  "text-anchor": "end",
                  transform: "r" + -data.degree + "," + positionTopAndLeft.left + "," + positionTopAndLeft.top
                });
                textObj.node.style.userSelect = "none";
                textObj.node.style.cursor = "arrow";
                data.set.push(textObj);
                this.ticks.push(textObj);
              };
              RaphaelAxisComponent2.prototype.renderTicks = function renderTicks(data) {
                var _this = this;
                var paper = data.paper, positions = data.positions, additionalSize = data.additionalSize, isVertical = data.isVertical, isCenter = data.isCenter, isDivided = data.isDivided, isPositionRight = data.isPositionRight, tickColor = data.tickColor, layout = data.layout;
                var rightEdgeOfAxis = layout.position.left + layout.dimension.width;
                var baseTop = layout.position.top;
                var baseLeft = layout.position.left;
                var centerAxisWidth = isDivided ? data.otherSideDimension.width : 0;
                var isContainDivensionArea = function isContainDivensionArea2(position) {
                  var compareType = isVertical ? "height" : "width";
                  return position > layout.dimension[compareType] + centerAxisWidth;
                };
                var tick = void 0;
                positions.forEach(function(position) {
                  var pathString = "M";
                  position += additionalSize;
                  if (isContainDivensionArea(position)) {
                    return;
                  }
                  if (isVertical) {
                    if (isCenter) {
                      pathString += baseLeft + "," + (baseTop + position);
                      pathString += "H" + (baseLeft + 5);
                      pathString += "M" + rightEdgeOfAxis + "," + (baseTop + position);
                      pathString += "H" + (rightEdgeOfAxis - 5);
                    } else if (isPositionRight) {
                      pathString += baseLeft + "," + (baseTop + position);
                      pathString += "H" + (baseLeft + 5);
                    } else {
                      pathString += rightEdgeOfAxis + "," + (baseTop + position);
                      pathString += "H" + (rightEdgeOfAxis - 5);
                    }
                  } else {
                    pathString += baseLeft + position + "," + baseTop;
                    pathString += "V" + (baseTop + 5);
                  }
                  if (!isNaN(position)) {
                    tick = paper.path(pathString).attr({
                      stroke: tickColor,
                      opacity: 0.5
                    });
                    data.set.push(tick);
                    _this.ticks.push(tick);
                  }
                });
              };
              RaphaelAxisComponent2.prototype.renderStandardLine = function renderStandardLine(data) {
                var lineSize = data.areaSize, _data$layout = data.layout, position = _data$layout.position, dimension = _data$layout.dimension, paper = data.paper, isVertical = data.isVertical;
                var baseLeft = position.left;
                var minAbs = Math.abs(data.axisLimit.min);
                var maxAbs = Math.abs(data.axisLimit.max);
                var standardRatio = 1 - maxAbs / (minAbs + maxAbs);
                var pathString = "M";
                var baseTop = position.top;
                var rightEdgeOfAxis = baseLeft + dimension.width;
                if (isVertical) {
                  var lineStartYCoord = baseTop;
                  rightEdgeOfAxis += data.seriesDimension.width * standardRatio;
                  pathString += rightEdgeOfAxis + "," + lineStartYCoord;
                  var lineEndYCoord = baseTop + lineSize;
                  pathString += "V" + lineEndYCoord;
                } else {
                  pathString += baseLeft;
                  baseTop -= data.seriesDimension.height * standardRatio;
                  pathString += "," + baseTop + "H";
                  var lineEndXCoord = baseLeft + lineSize;
                  pathString += lineEndXCoord;
                }
                data.set.push(paper.path(pathString).attr({
                  "stroke-width": 1,
                  opacity: 0.5
                }));
              };
              RaphaelAxisComponent2.prototype.renderTickLine = function renderTickLine(data) {
                var areaSize = data.areaSize, paper = data.paper, _data$layout2 = data.layout, _data$layout2$positio = _data$layout2.position, baseTop = _data$layout2$positio.top, baseLeft = _data$layout2$positio.left, dimension = _data$layout2.dimension, isNegativeStandard = data.isNegativeStandard, isNotDividedXAxis = data.isNotDividedXAxis, additionalSize = data.additionalSize, isPositionRight = data.isPositionRight, isCenter = data.isCenter, isVertical = data.isVertical, tickColor = data.tickColor, seriesDimension = data.seriesDimension;
                var lineSize = areaSize;
                var verticalTickLineEndYCoord = dimension.height + baseTop;
                var rightEdgeOfAxis = baseLeft + dimension.width;
                var pathString = "M";
                var lineStartYCoord = void 0, lineEndYCoord = void 0;
                if (isPositionRight) {
                  pathString += baseLeft + "," + baseTop;
                  pathString += "V" + verticalTickLineEndYCoord;
                } else if (isVertical) {
                  lineStartYCoord = baseTop;
                  if (isNegativeStandard) {
                    rightEdgeOfAxis += seriesDimension.width / 2;
                  }
                  pathString += rightEdgeOfAxis + "," + lineStartYCoord;
                  if (isCenter) {
                    pathString += "V" + verticalTickLineEndYCoord;
                    pathString += "M" + baseLeft + "," + lineStartYCoord;
                    pathString += "V" + verticalTickLineEndYCoord;
                  } else {
                    lineEndYCoord = baseTop + lineSize;
                    pathString += "V" + lineEndYCoord;
                  }
                } else {
                  pathString = this._makeNormalTickPath(pathString, {
                    isNotDividedXAxis,
                    baseTop,
                    baseLeft,
                    additionalSize,
                    isNegativeStandard,
                    seriesDimension,
                    lineSize
                  });
                }
                data.set.push(paper.path(pathString).attr({
                  "stroke-width": 1,
                  stroke: tickColor,
                  opacity: 0.5
                }));
              };
              RaphaelAxisComponent2.prototype._makeNormalTickPath = function _makeNormalTickPath(pathString, pathInfo) {
                if (pathInfo.isNotDividedXAxis) {
                  pathString += pathInfo.baseLeft;
                } else {
                  pathString += pathInfo.baseLeft + pathInfo.additionalSize;
                }
                if (pathInfo.isNegativeStandard) {
                  pathInfo.baseTop -= pathInfo.seriesDimension.height / 2;
                }
                pathString += "," + pathInfo.baseTop + "H";
                var lineEndXCoord = pathInfo.baseLeft + pathInfo.lineSize;
                if (!pathInfo.isNotDividedXAxis) {
                  lineEndXCoord += pathInfo.additionalSize;
                }
                pathString += lineEndXCoord;
                return pathString;
              };
              RaphaelAxisComponent2.prototype.animateForAddingData = function animateForAddingData(tickSize) {
                this.ticks.forEach(function(tick) {
                  tick.animate({
                    transform: "t-" + tickSize + ",0"
                  }, 300);
                });
              };
              RaphaelAxisComponent2.prototype.calculatePosition = function calculatePosition(paper, data) {
                var rotationInfo = data.rotationInfo, text = data.text, theme = data.theme, additionalWidth = data.additionalWidth, otherSideDimension = data.otherSideDimension, areaSize = data.areaSize, layout = data.layout;
                var textHeight = getTextHeight(text, theme);
                var textWidth = getTextWidth(text, theme);
                var axisHeight = layout.dimension.height;
                var axisWidth = layout.dimension.width;
                var _layout$position = layout.position, top = _layout$position.top, left = _layout$position.left;
                var leftPosition = left + additionalWidth;
                var adjustLeftPosition = textWidth - otherSideDimension.width;
                var position = {
                  top: top + axisHeight - textHeight / 2,
                  left: leftPosition + (adjustLeftPosition < 0 ? 0 : adjustLeftPosition)
                };
                if (rotationInfo.isVertical) {
                  if (rotationInfo.isCenter) {
                    position.top += textHeight / 2;
                    position.left = left + axisWidth / 2;
                  } else if (!rotationInfo.isDiverging) {
                    position.top = top - textHeight / 2 - Y_AXIS_TITLE_PADDING;
                  }
                } else if (!rotationInfo.isVertical) {
                  if (rotationInfo.isDiverging && rotationInfo.isYAxisCenter) {
                    position.left = left + areaSize / 2;
                  } else if (rotationInfo.isDiverging && !rotationInfo.isYAxisCenter) {
                    position.left = left + axisWidth / 2;
                  } else if (rotationInfo.isXAxisTitleLeft) {
                    position.left = layout.position.left;
                  } else {
                    position.left = layout.position.left + axisWidth;
                  }
                }
                if (rotationInfo.isPositionRight) {
                  position.left += axisWidth;
                }
                if (!rotationInfo.isCenter) {
                  addOffset(position, data.offset);
                }
                return position;
              };
              return RaphaelAxisComponent2;
            }();
            function getTextHeight(text, theme) {
              var titleSize = _raphaelRenderUtil2["default"].getRenderedTextSize(text, theme.fontSize, theme.fontFamily);
              return titleSize.height;
            }
            function getTextWidth(text, theme) {
              var titleSize = _raphaelRenderUtil2["default"].getRenderedTextSize(text, theme.fontSize, theme.fontFamily);
              return titleSize.width;
            }
            function addOffset(position, offset) {
              if (!offset) {
                return;
              }
              if (offset.x) {
                position.left += offset.x;
              }
              if (offset.y) {
                position.top += offset.y;
              }
            }
            exports2["default"] = RaphaelAxisComponent;
          },
          /* 47 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var STEP_TOP_ADJUSTMENT = 8;
            var STEP_LEFT_ADJUSTMENT = 3;
            var RaphaelRadialPlot = function() {
              function RaphaelRadialPlot2() {
                _classCallCheck(this, RaphaelRadialPlot2);
              }
              RaphaelRadialPlot2.prototype.render = function render(params) {
                var plotSet = params.paper.set();
                this.paper = params.paper;
                this.layout = params.layout;
                this.plotPositions = params.plotPositions;
                this.theme = params.theme;
                this.options = params.options;
                this.labelData = params.labelData;
                this._renderPlot(plotSet);
                this._renderLabels(plotSet);
                plotSet.toBack();
                this.paper.pushDownBackgroundToBottom();
                return plotSet;
              };
              RaphaelRadialPlot2.prototype._renderPlot = function _renderPlot(plotSet) {
                if (this.options.type === "circle") {
                  this._renderCirclePlot(plotSet);
                } else {
                  this._renderSpiderwebPlot(plotSet);
                }
                this._renderCategoryDots(plotSet);
              };
              RaphaelRadialPlot2.prototype._renderSpiderwebPlot = function _renderSpiderwebPlot(plotSet) {
                var groupPaths = this._getLinesPath(this.plotPositions);
                this._renderLines(groupPaths, this.theme.lineColor, plotSet);
              };
              RaphaelRadialPlot2.prototype._renderCirclePlot = function _renderCirclePlot(plotSet) {
                var plotPositions = this.plotPositions;
                var _plotPositions = _slicedToArray(plotPositions, 1), _plotPositions$ = _slicedToArray(_plotPositions[0], 1), centerPoint = _plotPositions$[0];
                var strokeColor = this.theme.lineColor;
                for (var i = 1; i < plotPositions.length; i += 1) {
                  var _plotPositions$i = _slicedToArray(plotPositions[i], 1), pos = _plotPositions$i[0];
                  var radius = centerPoint.top - pos.top;
                  plotSet.push(_raphaelRenderUtil2["default"].renderCircle(this.paper, centerPoint, radius, {
                    stroke: strokeColor,
                    "stroke-opacity": 0.05
                  }));
                }
              };
              RaphaelRadialPlot2.prototype._renderCategoryDots = function _renderCategoryDots(plotSet) {
                var _this = this;
                var bounds = this._makePlotDotBounds(_arrayUtil2["default"].pivot(this.plotPositions));
                bounds.forEach(function(bound) {
                  var squareDot = _raphaelRenderUtil2["default"].renderRect(_this.paper, bound, {
                    fill: "#000000",
                    "fill-opacity": 0.5,
                    "stroke-width": 0
                  });
                  plotSet.push(squareDot);
                }, this);
              };
              RaphaelRadialPlot2.prototype._makePlotDotBounds = function _makePlotDotBounds(plotPositions) {
                var bounds = plotPositions.map(function(positions) {
                  var outMostPlot = positions[positions.length - 1];
                  var bound = {
                    top: outMostPlot.top - 2,
                    left: outMostPlot.left - 2,
                    width: 4,
                    height: 4
                  };
                  return bound;
                });
                bounds.pop();
                return bounds;
              };
              RaphaelRadialPlot2.prototype._renderLabels = function _renderLabels(plotSet) {
                var paper = this.paper, theme = this.theme, labelData = this.labelData;
                var attributes = {
                  fill: theme.lineColor,
                  "font-size": theme.label.fontSize,
                  "font-family": theme.label.fontFamily,
                  "text-anchor": "end",
                  "font-weight": "100",
                  "dominant-baseline": "middle"
                };
                labelData.category.forEach(function(item) {
                  var categoryAttributes = Object.assign({}, attributes, {
                    "text-anchor": item.position.anchor,
                    fill: "#333333"
                  });
                  var label = _raphaelRenderUtil2["default"].renderText(paper, item.position, item.text, categoryAttributes);
                  label.node.style.userSelect = "none";
                  label.node.style.cursor = "default";
                  plotSet.push(label);
                });
                labelData.step.forEach(function(item) {
                  var stepLabel = _raphaelRenderUtil2["default"].renderText(paper, item.position, item.text, attributes);
                  item.position.top -= STEP_TOP_ADJUSTMENT;
                  item.position.left -= STEP_LEFT_ADJUSTMENT;
                  stepLabel.node.style.userSelect = "none";
                  stepLabel.node.style.cursor = "default";
                  plotSet.push(stepLabel);
                });
              };
              RaphaelRadialPlot2.prototype._renderLines = function _renderLines(groupPaths, lineColor, plotSet) {
                var paper = this.paper;
                return groupPaths.map(function(path) {
                  var line = _raphaelRenderUtil2["default"].renderLine(paper, path.join(" "), {
                    color: lineColor,
                    strokeWidth: 1
                  });
                  line.node.setAttribute("stroke-opacity", 0.05);
                  plotSet.push(line);
                  return line;
                });
              };
              RaphaelRadialPlot2.prototype._getLinesPath = function _getLinesPath(groupPositions) {
                var _this2 = this;
                return groupPositions.map(function(positions) {
                  return _this2._makeLinesPath(positions);
                });
              };
              RaphaelRadialPlot2.prototype._makeLinesPath = function _makeLinesPath(positions, posTopType, connectNulls) {
                var path = [];
                var prevMissing = false;
                posTopType = posTopType || "top";
                positions.forEach(function(position) {
                  var pathCommand = prevMissing && !connectNulls ? "M" : "L";
                  if (position) {
                    path.push([pathCommand, position.left, position[posTopType]]);
                    if (prevMissing) {
                      prevMissing = false;
                    }
                  } else {
                    prevMissing = true;
                  }
                });
                path = Array.prototype.concat.apply([], path);
                path[0] = "M";
                return path;
              };
              return RaphaelRadialPlot2;
            }();
            exports2["default"] = RaphaelRadialPlot;
          },
          /* 48 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _isString = __webpack_require__(25);
            var _isString2 = _interopRequireDefault(_isString);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _chartFactory = __webpack_require__(49);
            var _chartFactory2 = _interopRequireDefault(_chartFactory);
            var _pluginFactory = __webpack_require__(51);
            var _pluginFactory2 = _interopRequireDefault(_pluginFactory);
            var _themeManager = __webpack_require__(52);
            var _themeManager2 = _interopRequireDefault(_themeManager);
            var _mapManager = __webpack_require__(54);
            var _mapManager2 = _interopRequireDefault(_mapManager);
            var _objectUtil = __webpack_require__(55);
            var _objectUtil2 = _interopRequireDefault(_objectUtil);
            var _seriesDataImporter = __webpack_require__(57);
            var _seriesDataImporter2 = _interopRequireDefault(_seriesDataImporter);
            var _drawingToolPicker = __webpack_require__(60);
            var _drawingToolPicker2 = _interopRequireDefault(_drawingToolPicker);
            __webpack_require__(61);
            __webpack_require__(62);
            __webpack_require__(175);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _createChart(container) {
              var rawData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              var options = arguments[2];
              var chartType = arguments[3];
              if (rawData.table) {
                rawData = _seriesDataImporter2["default"].makeDataWithTable(rawData.table);
              }
              if (!rawData.series) {
                rawData.series = [];
              }
              rawData = _objectUtil2["default"].deepCopy(rawData);
              if (chartType !== "combo") {
                var temp = rawData.series;
                rawData.series = {};
                rawData.series[chartType] = temp;
              }
              options = options ? _objectUtil2["default"].deepCopy(options) : {};
              options.chartType = chartType;
              options.theme = options.theme || _const2["default"].DEFAULT_THEME_NAME;
              if (options.series && options.series.stackType) {
                options.series.stack = {
                  type: options.series.stackType
                };
                delete options.series.stackType;
              }
              if (options.series && (0, _isString2["default"])(options.series.stack)) {
                options.series.stack = {
                  type: options.series.stack
                };
              }
              var isColorByPoint = options.series && options.series.colorByPoint;
              var theme = _themeManager2["default"].get(options.theme, chartType, rawData.series, isColorByPoint);
              var chart = _chartFactory2["default"].get(options.chartType, rawData, theme, options);
              chart.render(container);
              chart.animateChart();
              return chart;
            }
            function barChart(container, rawData, options) {
              return _createChart(container, rawData, options, _const2["default"].CHART_TYPE_BAR);
            }
            function columnChart(container, rawData, options) {
              return _createChart(container, rawData, options, _const2["default"].CHART_TYPE_COLUMN);
            }
            function lineChart(container, rawData, options) {
              return _createChart(container, rawData, options, _const2["default"].CHART_TYPE_LINE);
            }
            function areaChart(container, rawData, options) {
              return _createChart(container, rawData, options, _const2["default"].CHART_TYPE_AREA);
            }
            function bubbleChart(container, rawData, options) {
              return _createChart(container, rawData, options, _const2["default"].CHART_TYPE_BUBBLE);
            }
            function scatterChart(container, rawData, options) {
              return _createChart(container, rawData, options, _const2["default"].CHART_TYPE_SCATTER);
            }
            function heatmapChart(container, rawData, options) {
              return _createChart(container, rawData, options, _const2["default"].CHART_TYPE_HEATMAP);
            }
            function treemapChart(container, rawData, options) {
              return _createChart(container, rawData, options, _const2["default"].CHART_TYPE_TREEMAP);
            }
            function comboChart(container, rawData, options) {
              return _createChart(container, rawData, options, _const2["default"].CHART_TYPE_COMBO);
            }
            function pieChart(container, rawData, options) {
              return _createChart(container, rawData, options, _const2["default"].CHART_TYPE_PIE);
            }
            function mapChart(container, rawData, options) {
              return _createChart(container, rawData, options, _const2["default"].CHART_TYPE_MAP);
            }
            function radialChart(container, rawData, options) {
              return _createChart(container, rawData, options, _const2["default"].CHART_TYPE_RADIAL);
            }
            function boxplotChart(container, rawData, options) {
              return _createChart(container, rawData, options, _const2["default"].CHART_TYPE_BOXPLOT);
            }
            function bulletChart(container, rawData, options) {
              return _createChart(container, rawData, options, _const2["default"].CHART_TYPE_BULLET);
            }
            function registerTheme(themeName, theme) {
              _themeManager2["default"].register(themeName, theme);
            }
            function registerMap(mapName, data) {
              _mapManager2["default"].register(mapName, data);
            }
            function registerPlugin(libType, plugin, getPaperCallback) {
              _pluginFactory2["default"].register(libType, plugin);
              _drawingToolPicker2["default"].addRendererType(libType, getPaperCallback);
            }
            module2.exports = {
              barChart,
              columnChart,
              lineChart,
              areaChart,
              bubbleChart,
              scatterChart,
              heatmapChart,
              treemapChart,
              comboChart,
              pieChart,
              mapChart,
              radialChart,
              boxplotChart,
              bulletChart,
              registerTheme,
              registerMap,
              registerPlugin
            };
          },
          /* 49 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _rawDataHandler = __webpack_require__(50);
            var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var charts = {};
            exports2["default"] = {
              /**
               * Find key for getting chart.
               * @param {string} chartType - type of chart
               * @param {{seriesAlias: ?object, series: object.<string, Array>}} rawData - raw data
               * @returns {string}
               * @private
               */
              _findKey: function _findKey(chartType, rawData) {
                var key = null;
                if (_predicate2["default"].isComboChart(chartType)) {
                  var chartTypeMap = _rawDataHandler2["default"].getChartTypeMap(rawData);
                  if (chartTypeMap[_const2["default"].CHART_TYPE_COLUMN] && chartTypeMap[_const2["default"].CHART_TYPE_LINE]) {
                    key = _const2["default"].CHART_TYPE_COLUMN_LINE_COMBO;
                  } else if (chartTypeMap[_const2["default"].CHART_TYPE_LINE] && chartTypeMap[_const2["default"].CHART_TYPE_SCATTER]) {
                    key = _const2["default"].CHART_TYPE_LINE_SCATTER_COMBO;
                  } else if (chartTypeMap[_const2["default"].CHART_TYPE_AREA] && chartTypeMap[_const2["default"].CHART_TYPE_LINE]) {
                    key = _const2["default"].CHART_TYPE_LINE_AREA_COMBO;
                  } else if (chartTypeMap[_const2["default"].CHART_TYPE_PIE]) {
                    key = _const2["default"].CHART_TYPE_PIE_DONUT_COMBO;
                  }
                } else {
                  key = chartType;
                }
                return key;
              },
              /**
               * Get chart instance.
               * @param {string} chartType chart type
               * @param {object} rawData chart data
               * @param {object} theme chart options
               * @param {object} options chart options
               * @returns {object} chart instance;
               */
              get: function get(chartType, rawData, theme, options) {
                var key = this._findKey(chartType, rawData);
                var Chart = charts[key];
                if (!Chart) {
                  throw new Error("Not exist " + chartType + " chart.");
                }
                return new Chart(rawData, theme, options);
              },
              /**
               * Register chart.
               * @param {string} chartType char type
               * @param {class} ChartClass chart class
               */
              register: function register(chartType, ChartClass) {
                charts[chartType] = ChartClass;
              }
            };
          },
          /* 50 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _isObject = __webpack_require__(7);
            var _isObject2 = _interopRequireDefault(_isObject);
            var _forEach = __webpack_require__(8);
            var _forEach2 = _interopRequireDefault(_forEach);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            exports2["default"] = {
              /**
               * Pick stacks.
               * @param {Array.<{stack: string}>} seriesData - raw series data
               * @param {boolean} [divergingOption] - diverging option
               * @returns {Array.<string>} stacks
               */
              pickStacks: function pickStacks(seriesData, divergingOption) {
                var stacks = seriesData.map(function(seriesDatum) {
                  return seriesDatum.stack;
                });
                var uniqStacks = _arrayUtil2["default"].unique(stacks);
                if (divergingOption) {
                  uniqStacks = uniqStacks.slice(0, 2);
                }
                var filteredStack = uniqStacks.filter(function(stack) {
                  return !!stack;
                });
                if (filteredStack.length < uniqStacks.length) {
                  filteredStack.push(_const2["default"].DEFAULT_STACK);
                }
                return filteredStack;
              },
              /**
               * Sort series data from stacks.
               * @param {Array.<{stack: ?string}>} seriesData series data
               * @param {Array.<string>} stacks stacks
               * @returns {Array}
               * @private
               */
              _sortSeriesData: function _sortSeriesData(seriesData, stacks) {
                var newSeriesData = [];
                if (!stacks) {
                  stacks = this.pickStacks(seriesData);
                }
                stacks.forEach(function(stack) {
                  var filtered = seriesData.filter(function(datum) {
                    return (datum.stack || _const2["default"].DEFAULT_STACK) === stack;
                  });
                  newSeriesData = newSeriesData.concat(filtered);
                });
                return newSeriesData;
              },
              /**
               * Remove stack of series data.
               * @param {Array.<{stack: ?string}>} seriesData series data
               */
              removeSeriesStack: function removeSeriesStack(seriesData) {
                Object.values(seriesData).forEach(function(datum) {
                  delete datum.stack;
                });
              },
              /**
               * Find char type from chart name.
               * @param {object.<string, string>} seriesAlias - alias map
               * @param {string} seriesType - series name
               * @returns {*}
               */
              findChartType: function findChartType(seriesAlias, seriesType) {
                var chartType = void 0;
                if (seriesAlias) {
                  chartType = seriesAlias[seriesType];
                }
                return chartType || seriesType;
              },
              /**
               * Get chart type map.
               * @param {{series: (Array | object)}} rawData - raw data
               * @returns {object.<string, string>}
               */
              getChartTypeMap: function getChartTypeMap(rawData) {
                var _this = this;
                var chartTypeMap = {};
                if ((0, _isObject2["default"])(rawData.series)) {
                  (0, _forEach2["default"])(rawData.series, function(data, seriesType) {
                    chartTypeMap[_this.findChartType(rawData.seriesAlias, seriesType)] = true;
                  });
                }
                return chartTypeMap;
              },
              /**
               * Create minus values.
               * @param {Array.<number>} data number data
               * @returns {Array} minus values
               * @private
               */
              _createMinusValues: function _createMinusValues(data) {
                return data.map(function(value) {
                  return value < 0 ? 0 : -value;
                });
              },
              /**
               * Create plus values.
               * @param {Array.<number>} data number data
               * @returns {Array} plus values
               * @private
               */
              _createPlusValues: function _createPlusValues(data) {
                return data.map(function(value) {
                  return value < 0 ? 0 : value;
                });
              },
              /**
               * Make normal diverging raw series data.
               * @param {{data: Array.<number>}} rawSeriesData raw series data
               * @returns {{data: Array.<number>}} changed raw series data
               * @private
               */
              _makeNormalDivergingRawSeriesData: function _makeNormalDivergingRawSeriesData(rawSeriesData) {
                rawSeriesData.length = Math.min(rawSeriesData.length, 2);
                rawSeriesData[0].data = this._createMinusValues(rawSeriesData[0].data);
                if (rawSeriesData[1]) {
                  rawSeriesData[1].data = this._createPlusValues(rawSeriesData[1].data);
                }
                return rawSeriesData;
              },
              /**
               * Make raw series data for stacked diverging option.
               * @param {{data: Array.<number>, stack: string}} rawSeriesData raw series data
               * @returns {{data: Array.<number>}} changed raw series data
               * @private
               */
              _makeRawSeriesDataForStackedDiverging: function _makeRawSeriesDataForStackedDiverging(rawSeriesData) {
                var _this2 = this;
                var stacks = this.pickStacks(rawSeriesData, true);
                var result = [];
                var _stacks = _slicedToArray(stacks, 2), leftStack = _stacks[0], rightStack = _stacks[1];
                rawSeriesData = this._sortSeriesData(rawSeriesData, stacks);
                rawSeriesData.forEach(function(seriesDatum) {
                  var stack = seriesDatum.stack || _const2["default"].DEFAULT_STACK;
                  if (stack === leftStack) {
                    seriesDatum.data = _this2._createMinusValues(seriesDatum.data);
                    result.push(seriesDatum);
                  } else if (stack === rightStack) {
                    seriesDatum.data = _this2._createPlusValues(seriesDatum.data);
                    result.push(seriesDatum);
                  }
                });
                return result;
              },
              /**
               * Make raw series data for diverging.
               * @param {{data: Array.<number>, stack: string}} rawSeriesData raw series data
               * @param {?string} stackTypeOption stackType option
               * @returns {{data: Array.<number>}} changed raw series data
               * @private
               */
              _makeRawSeriesDataForDiverging: function _makeRawSeriesDataForDiverging(rawSeriesData, stackTypeOption) {
                if (_predicate2["default"].isValidStackOption(stackTypeOption)) {
                  rawSeriesData = this._makeRawSeriesDataForStackedDiverging(rawSeriesData);
                } else {
                  rawSeriesData = this._makeNormalDivergingRawSeriesData(rawSeriesData);
                }
                return rawSeriesData;
              },
              /**
               * Update raw series data by options.
               * @param {object} rawData - raw data
               * @param {{stackType: ?object, diverging: ?boolean}} seriesOptions - series options
               */
              updateRawSeriesDataByOptions: function updateRawSeriesDataByOptions(rawData) {
                var _this3 = this;
                var seriesOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                if (_predicate2["default"].isValidStackOption(seriesOptions.stack)) {
                  Object.keys(rawData.series).forEach(function(seriesType) {
                    rawData.series[seriesType] = _this3._sortSeriesData(rawData.series[seriesType]);
                  });
                }
                if (seriesOptions.diverging) {
                  Object.entries(rawData.series).forEach(function(_ref) {
                    var _ref2 = _slicedToArray(_ref, 2), seriesType = _ref2[0], seriesDatum = _ref2[1];
                    rawData.series[seriesType] = _this3._makeRawSeriesDataForDiverging(seriesDatum, seriesOptions.stack);
                  });
                }
              },
              /**
               * Append outlier value to boxplot series data end
               * @param {object} rawData - raw data
               */
              appendOutliersToSeriesData: function appendOutliersToSeriesData(rawData) {
                var boxplot = rawData.series.boxplot;
                boxplot.forEach(function(seriesItem) {
                  var outliers = seriesItem.outliers;
                  if (outliers && outliers.length) {
                    outliers.forEach(function(outlier) {
                      seriesItem.data[outlier[0]].push(outlier[1]);
                    });
                  }
                });
              },
              /**
               * Filter raw data belong to checked legend.
               * @param {object} rawData raw data
               * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
               * @returns {object} rawData
               */
              filterCheckedRawData: function filterCheckedRawData(rawData, checkedLegends) {
                var cloneData = JSON.parse(JSON.stringify(rawData));
                if (checkedLegends) {
                  Object.entries(cloneData.series).forEach(function(_ref3) {
                    var _ref4 = _slicedToArray(_ref3, 2), chartType = _ref4[0], serieses = _ref4[1];
                    if (!checkedLegends[chartType]) {
                      cloneData.series[chartType] = [];
                    } else if (checkedLegends[chartType].length) {
                      cloneData.series[chartType] = serieses.filter(function(series, index) {
                        return checkedLegends[chartType][index];
                      });
                    }
                  });
                }
                if (cloneData.series.bullet) {
                  var filteredCategories = [];
                  checkedLegends.bullet.forEach(function(isChecked, index) {
                    if (isChecked) {
                      filteredCategories.push(rawData.categories[index]);
                    }
                  });
                  cloneData.categories = filteredCategories;
                }
                return cloneData;
              },
              /**
               * Modify rawData to fit chart format
               * @param {object} rawData - raw data
               * @private
               */
              _makeRawSeriesDataForBulletChart: function _makeRawSeriesDataForBulletChart(rawData) {
                var _rawData$series$bulle = rawData.series.bullet, bullet = _rawData$series$bulle === void 0 ? [] : _rawData$series$bulle;
                rawData.categories = rawData.categories || [];
                rawData.categories = bullet.map(function(seriesData) {
                  return seriesData.name || "";
                });
              }
            };
          },
          /* 51 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var plugins = {};
            exports2["default"] = {
              /**
               * Get graph renderer.
               * @param {string} libType type of graph library
               * @param {string} chartType chart type
               * @returns {object} renderer instance
               */
              get: function get(libType, chartType) {
                var plugin = plugins[libType || _const2["default"].DEFAULT_PLUGIN];
                if (!plugin) {
                  throw new Error("Not exist " + libType + " plugin.");
                }
                var Renderer = plugin[chartType];
                if (!Renderer) {
                  throw new Error("Not exist " + chartType + " chart renderer.");
                }
                var renderer = new Renderer();
                return renderer;
              },
              /**
               * Plugin register.
               * @param {string} libType type of graph library
               * @param {object} plugin plugin to control library
               */
              register: function register(libType, plugin) {
                plugins[libType] = plugin;
              }
            };
          },
          /* 52 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _isArray = __webpack_require__(9);
            var _isArray2 = _interopRequireDefault(_isArray);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isObject = __webpack_require__(7);
            var _isObject2 = _interopRequireDefault(_isObject);
            var _forEach = __webpack_require__(8);
            var _forEach2 = _interopRequireDefault(_forEach);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _defaultTheme = __webpack_require__(53);
            var _defaultTheme2 = _interopRequireDefault(_defaultTheme);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var themes = {};
            exports2["default"] = {
              /**
               * Theme register.
               * @param {string} themeName theme name
               * @param {object} theme theme
               */
              register: function register(themeName, theme) {
                theme = JSON.parse(JSON.stringify(theme));
                themes[themeName] = theme;
              },
              /**
               * Pick series types from raw series data.
               * @param {string} chartType - chart type
               * @param {object} rawSeriesData - raw series data
               * @returns {Array}
               * @private
               */
              _pickSeriesNames: function _pickSeriesNames(chartType, rawSeriesData) {
                var seriesTypes = [];
                if (_predicate2["default"].isComboChart(chartType)) {
                  Object.keys(rawSeriesData).forEach(function(seriesType) {
                    seriesTypes.push(seriesType);
                  });
                } else {
                  seriesTypes.push(chartType);
                }
                return seriesTypes;
              },
              /**
               * Overwrite theme
               * @param {object} fromTheme - from theme
               * @param {object} toTheme - to theme
               * @private
               */
              _overwriteTheme: function _overwriteTheme(fromTheme, toTheme) {
                var _this = this;
                Object.entries(toTheme).forEach(function(_ref) {
                  var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], item = _ref2[1];
                  var fromItem = fromTheme[key];
                  if (!fromItem && fromItem !== 0) {
                    return;
                  }
                  if ((0, _isArray2["default"])(fromItem)) {
                    toTheme[key] = fromItem.slice();
                  } else if ((0, _isObject2["default"])(fromItem)) {
                    _this._overwriteTheme(fromItem, item);
                  } else {
                    toTheme[key] = fromItem;
                  }
                });
              },
              /**
               * Pick valid theme properties.
               * @param {object} theme - theme
               * @param {string} componentType - component type (series or yAxis)
               * @returns {object}
               * @private
               */
              _pickValidTheme: function _pickValidTheme(theme, componentType) {
                var validTheme = {};
                _const2["default"].THEME_PROPS_MAP[componentType].forEach(function(propName) {
                  if ((0, _isExisty2["default"])(theme[propName])) {
                    validTheme[propName] = theme[propName];
                  }
                });
                return validTheme;
              },
              /**
               * Create component theme with series name
               * @param {Array.<string>} seriesTypes - series types
               * @param {object} fromTheme - from theme
               * @param {object} toTheme - to theme
               * @param {string} componentType - component type
               * @returns {object}
               * @private
               */
              _createComponentThemeWithSeriesName: function _createComponentThemeWithSeriesName(seriesTypes, fromTheme, toTheme, componentType) {
                var _this2 = this;
                var newTheme = {};
                fromTheme = fromTheme || {};
                seriesTypes.forEach(function(seriesType) {
                  var theme = fromTheme[seriesType] || _this2._pickValidTheme(fromTheme, componentType);
                  if (Object.keys(theme).length) {
                    newTheme[seriesType] = JSON.parse(JSON.stringify(_defaultTheme2["default"][componentType]));
                    _this2._overwriteTheme(theme, newTheme[seriesType]);
                  } else {
                    newTheme[seriesType] = JSON.parse(JSON.stringify(toTheme));
                  }
                });
                return newTheme;
              },
              /**
               * Make each series's color
               * @param {Array.<string>} themeColors Theme colors to use
               * @param {number} seriesCount Series count
               * @param {number} startColorIndex Start color index
               * @returns {Array.<string>} colors
               */
              _makeEachSeriesColors: function _makeEachSeriesColors(themeColors, seriesCount, startColorIndex) {
                var colors = [];
                var themeColorsLen = themeColors.length;
                var colorIndex = startColorIndex || 0;
                for (var i = 0; i < seriesCount; i += 1) {
                  colors.push(themeColors[colorIndex]);
                  colorIndex += 1;
                  if (colorIndex >= themeColorsLen) {
                    colorIndex = 0;
                  }
                }
                return colors;
              },
              /**
               * Set series colors theme.
               * @param {Array.<string>} seriesTypes - series type
               * @param {object} seriesThemes - series theme map
               * @param {object} rawSeriesThemes - raw series theme map
               * @param {object} rawSeriesData - raw series data
               * @param {boolean} isColorByPoint - check colorByPoint option
               * @private
               */
              _setSeriesColors: function _setSeriesColors(seriesTypes, seriesThemes, rawSeriesThemes, rawSeriesData, isColorByPoint) {
                var _this3 = this;
                var seriesColors = void 0, seriesCount = void 0, hasOwnColors = void 0;
                var colorIndex = 0;
                rawSeriesThemes = rawSeriesThemes || {};
                seriesTypes.forEach(function(seriesType) {
                  if (rawSeriesThemes[seriesType]) {
                    seriesColors = rawSeriesThemes[seriesType].colors;
                    hasOwnColors = true;
                  } else {
                    seriesColors = rawSeriesThemes.colors || _defaultTheme2["default"].series.colors;
                    hasOwnColors = false;
                  }
                  seriesCount = _this3._getSeriesThemeColorCount(rawSeriesData[seriesType], isColorByPoint);
                  seriesThemes[seriesType].colors = _this3._makeEachSeriesColors(seriesColors, seriesCount, !hasOwnColors && colorIndex);
                  if (!hasOwnColors) {
                    colorIndex = (seriesCount + colorIndex) % seriesColors.length;
                  }
                });
              },
              /**
               * Get number of series theme color from seriesData
               * @param {object} rawSeriesDatum - raw series data contains series information
               * @param {boolean} isColorByPoint - check colorByPoint option
               * @returns {number} number of series theme color
               * @private
               */
              _getSeriesThemeColorCount: function _getSeriesThemeColorCount(rawSeriesDatum, isColorByPoint) {
                var seriesCount = 0;
                if (rawSeriesDatum && rawSeriesDatum.length) {
                  var existFirstSeriesDataLength = rawSeriesDatum[0] && rawSeriesDatum[0].data && rawSeriesDatum[0].data.length;
                  if (isColorByPoint && existFirstSeriesDataLength) {
                    seriesCount = Math.max(rawSeriesDatum.length, rawSeriesDatum[0].data.length);
                  } else {
                    seriesCount = rawSeriesDatum.length;
                  }
                }
                return seriesCount;
              },
              _initTheme: function _initTheme(themeName, rawTheme, seriesTypes, rawSeriesData, isColorByPoint) {
                var theme = void 0;
                if (themeName !== _const2["default"].DEFAULT_THEME_NAME) {
                  theme = JSON.parse(JSON.stringify(_defaultTheme2["default"]));
                  this._overwriteTheme(rawTheme, theme);
                } else {
                  theme = JSON.parse(JSON.stringify(rawTheme));
                }
                theme.yAxis = this._createComponentThemeWithSeriesName(seriesTypes, rawTheme.yAxis, theme.yAxis, "yAxis");
                theme.series = this._createComponentThemeWithSeriesName(seriesTypes, rawTheme.series, theme.series, "series");
                this._setSeriesColors(seriesTypes, theme.series, rawTheme.series, rawSeriesData, isColorByPoint);
                return theme;
              },
              /**
               * Create target themes for font inherit.
               * @param {object} theme - theme
               * @returns {Array.<object>}
               * @private
               */
              _createTargetThemesForFontInherit: function _createTargetThemesForFontInherit(theme) {
                var items = [theme.title, theme.xAxis.title, theme.xAxis.label, theme.legend.label, theme.plot.label];
                (0, _forEach2["default"])(theme.yAxis, function(_theme) {
                  items.push(_theme.title, _theme.label);
                });
                (0, _forEach2["default"])(theme.series, function(_theme) {
                  items.push(_theme.label);
                });
                return items;
              },
              /**
               * Inherit theme font.
               * @param {object} theme theme
               * @private
               */
              _inheritThemeFont: function _inheritThemeFont(theme) {
                var targetThemes = this._createTargetThemesForFontInherit(theme);
                var baseFont = theme.chart.fontFamily;
                targetThemes.forEach(function(item) {
                  if (!item.fontFamily) {
                    item.fontFamily = baseFont;
                  }
                });
              },
              /**
               * Copy color theme to otherTheme from seriesTheme.
               * @param {object} seriesTheme - series theme
               * @param {object} otherTheme - other theme
               * @param {object} seriesType - series name
               * @private
               */
              _copySeriesColorTheme: function _copySeriesColorTheme(seriesTheme, otherTheme, seriesType) {
                otherTheme[seriesType] = {
                  colors: seriesTheme.colors,
                  borderColor: seriesTheme.borderColor,
                  selectionColor: seriesTheme.selectionColor
                };
              },
              /**
               * Copy series color theme to other components.
               * @param {object} theme theme
               * @private
               * @ignore
               */
              _copySeriesColorThemeToOther: function _copySeriesColorThemeToOther(theme) {
                var _this4 = this;
                (0, _forEach2["default"])(theme.series, function(seriesTheme, seriesType) {
                  _this4._copySeriesColorTheme(seriesTheme, theme.legend, seriesType);
                  _this4._copySeriesColorTheme(seriesTheme, theme.tooltip, seriesType);
                });
              },
              /**
               * Get theme.
               * @param {string} themeName - theme name
               * @param {string} chartType - chart type
               * @param {object} rawSeriesData - raw series data
               * @param {boolean} isColorByPoint - check colorByPoint option
               * @returns {object}
               */
              get: function get(themeName, chartType, rawSeriesData, isColorByPoint) {
                var rawTheme = themes[themeName];
                if (!rawTheme) {
                  throw new Error("Not exist " + themeName + " theme.");
                }
                var seriesTypes = this._pickSeriesNames(chartType, rawSeriesData);
                var theme = this._initTheme(themeName, rawTheme, seriesTypes, rawSeriesData, isColorByPoint);
                this._inheritThemeFont(theme, seriesTypes);
                this._copySeriesColorThemeToOther(theme);
                return theme;
              }
            };
          },
          /* 53 */
          /***/
          function(module2, exports2) {
            "use strict";
            exports2.__esModule = true;
            var DEFAULT_COLOR = "#000000";
            var DEFAULT_BACKGROUND = "#ffffff";
            var DEFAULT_FONTWEIGHT = "lighter";
            var DEFAULT_FONTFAMILY = "Arial";
            var DEFAULT_LEGEND_LABEL_FONTCOLOR = exports2.DEFAULT_LEGEND_LABEL_FONTCOLOR = "#333";
            var EMPTY = "";
            var DEFAULT_AXIS = {
              tickColor: DEFAULT_COLOR,
              title: {
                fontSize: 11,
                fontFamily: DEFAULT_FONTFAMILY,
                color: "#bbbbbb",
                fontWeight: "bold"
              },
              label: {
                fontSize: 11,
                fontFamily: DEFAULT_FONTFAMILY,
                color: "#333",
                fontWeight: "normal"
              }
            };
            exports2["default"] = {
              chart: {
                background: {
                  color: DEFAULT_BACKGROUND,
                  opacity: 1
                },
                fontFamily: DEFAULT_FONTFAMILY
              },
              title: {
                fontSize: 18,
                fontFamily: DEFAULT_FONTFAMILY,
                color: DEFAULT_COLOR,
                fontWeight: DEFAULT_FONTWEIGHT
              },
              yAxis: DEFAULT_AXIS,
              xAxis: DEFAULT_AXIS,
              plot: {
                lineColor: "#000000",
                background: "#ffffff",
                label: {
                  fontSize: 11,
                  fontFamily: DEFAULT_FONTFAMILY,
                  color: "#888"
                }
              },
              series: {
                label: {
                  fontSize: 11,
                  fontFamily: DEFAULT_FONTFAMILY,
                  color: DEFAULT_COLOR,
                  fontWeight: DEFAULT_FONTWEIGHT
                },
                colors: ["#00a9ff", "#ffb840", "#ff5a46", "#00bd9f", "#785fff", "#f28b8c", "#989486", "#516f7d", "#29dbe3", "#dddddd"],
                borderColor: EMPTY,
                borderWidth: EMPTY,
                selectionColor: EMPTY,
                startColor: "#FFE98A",
                endColor: "#D74177",
                overColor: EMPTY,
                dot: {
                  fillColor: EMPTY,
                  fillOpacity: 1,
                  strokeColor: EMPTY,
                  strokeOpacity: EMPTY,
                  strokeWidth: 0,
                  radius: 6,
                  hover: {
                    fillColor: EMPTY,
                    fillOpacity: 1,
                    strokeColor: "#fff",
                    strokeOpacity: 1,
                    strokeWidth: 4,
                    radius: 6
                  }
                },
                ranges: []
              },
              legend: {
                label: {
                  fontSize: 11,
                  fontFamily: DEFAULT_FONTFAMILY,
                  color: DEFAULT_LEGEND_LABEL_FONTCOLOR,
                  fontWeight: DEFAULT_FONTWEIGHT
                }
              },
              tooltip: {},
              chartExportMenu: {
                backgroundColor: "#fff",
                borderRadius: 0,
                borderWidth: 1,
                color: "#000"
              }
            };
          },
          /* 54 */
          /***/
          function(module2, exports2) {
            "use strict";
            exports2.__esModule = true;
            var maps = {};
            exports2["default"] = {
              /**
               * Get map data.
               * @param {string} mapName map name
               * @returns {Array} map data
               */
              get: function get(mapName) {
                var data = maps[mapName];
                if (!data) {
                  throw new Error("Not exist " + mapName + " map.");
                }
                return data;
              },
              /**
               * Register Map.
               * @param {string} mapName map name
               * @param {Array} data map data
               */
              register: function register(mapName, data) {
                maps[mapName] = data;
              }
            };
          },
          /* 55 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _isArray = __webpack_require__(9);
            var _isArray2 = _interopRequireDefault(_isArray);
            var _isDate = __webpack_require__(18);
            var _isDate2 = _interopRequireDefault(_isDate);
            var _isFunction = __webpack_require__(56);
            var _isFunction2 = _interopRequireDefault(_isFunction);
            var _isObject = __webpack_require__(7);
            var _isObject2 = _interopRequireDefault(_isObject);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var deepCopy = function deepCopy2(origin) {
              var clone = void 0;
              if ((0, _isArray2["default"])(origin)) {
                clone = [];
                origin.forEach(function(value, index) {
                  clone[index] = deepCopy2(value);
                });
              } else if ((0, _isFunction2["default"])(origin) || (0, _isDate2["default"])(origin)) {
                clone = origin;
              } else if ((0, _isObject2["default"])(origin)) {
                clone = {};
                Object.entries(origin).forEach(function(_ref) {
                  var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
                  clone[key] = deepCopy2(value);
                });
              } else {
                clone = origin;
              }
              return clone;
            };
            exports2["default"] = {
              deepCopy
            };
          },
          /* 56 */
          /***/
          function(module2, exports2) {
            "use strict";
            function isFunction(obj) {
              return obj instanceof Function;
            }
            module2.exports = isFunction;
          },
          /* 57 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _forEach = __webpack_require__(8);
            var _forEach2 = _interopRequireDefault(_forEach);
            var _pluck = __webpack_require__(58);
            var _pluck2 = _interopRequireDefault(_pluck);
            var _toArray = __webpack_require__(59);
            var _toArray2 = _interopRequireDefault(_toArray);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function getChartDataFrom2DArray(table2DArray) {
              var chartData = void 0;
              if (table2DArray.length > 0) {
                chartData = {};
                chartData.categories = [];
                chartData.series = [];
                chartData.categories = table2DArray.shift().slice(1);
                table2DArray.forEach(function(tr) {
                  var seriesDatum = {
                    name: tr[0],
                    data: tr.slice(1)
                  };
                  chartData.series.push(seriesDatum);
                });
              }
              return chartData;
            }
            function get2DArray(tableElement) {
              var resultArray = [];
              if (tableElement) {
                var secondDimensionArray = [];
                var trs = (0, _toArray2["default"])(tableElement.getElementsByTagName("TR"));
                (0, _forEach2["default"])(trs, function(tr, index) {
                  var tagName = index === 0 ? "TH" : "TD";
                  var cells = (0, _toArray2["default"])(tr.getElementsByTagName(tagName));
                  var rows = (0, _pluck2["default"])(cells, "innerText");
                  secondDimensionArray.push(rows);
                });
                if (secondDimensionArray[0].length < secondDimensionArray[1].length) {
                  secondDimensionArray[0].unshift("");
                }
                resultArray = _arrayUtil2["default"].pivot(secondDimensionArray);
              }
              return resultArray;
            }
            function makeDataWithTable(table) {
              var element = void 0;
              if (table.element && table.element.tagName === "TABLE") {
                element = table.element;
              } else if (table.elementId) {
                element = document.getElementById(table.elementId);
              }
              var chartData = getChartDataFrom2DArray(get2DArray(element));
              return chartData;
            }
            exports2["default"] = {
              makeDataWithTable
            };
          },
          /* 58 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var forEach = __webpack_require__(8);
            function pluck(arr, property) {
              var resultArray = [];
              forEach(arr, function(item) {
                resultArray.push(item[property]);
              });
              return resultArray;
            }
            module2.exports = pluck;
          },
          /* 59 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var forEachArray = __webpack_require__(10);
            function toArray(arrayLike) {
              var arr;
              try {
                arr = Array.prototype.slice.call(arrayLike);
              } catch (e) {
                arr = [];
                forEachArray(arrayLike, function(value) {
                  arr.push(value);
                });
              }
              return arr;
            }
            module2.exports = toArray;
          },
          /* 60 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _domHandler = __webpack_require__(24);
            var _domHandler2 = _interopRequireDefault(_domHandler);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var renderers = {
              DOM: function DOM(container) {
                var paper = _domHandler2["default"].create("DIV");
                _domHandler2["default"].append(container, paper);
                return paper;
              }
            };
            var DrawingToolPicker = function() {
              function DrawingToolPicker2() {
                _classCallCheck(this, DrawingToolPicker2);
              }
              DrawingToolPicker2.prototype.initDimension = function initDimension(dimension) {
                this.dimension = dimension;
              };
              DrawingToolPicker2.prototype.getPaper = function getPaper(container, rendererType) {
                var paper = this[rendererType + "Paper"];
                var isNeedCreateNewPaper = (0, _isExisty2["default"])(container) && paper && _domHandler2["default"].findParentByClass(paper.canvas, "tui-chart") !== container;
                if (!paper || isNeedCreateNewPaper) {
                  paper = renderers[rendererType].call(this, container, this.dimension);
                  if (rendererType !== "DOM") {
                    this[rendererType + "Paper"] = paper;
                  }
                }
                return paper;
              };
              DrawingToolPicker2.addRendererType = function addRendererType(componentType, callback) {
                renderers[componentType] = callback;
              };
              return DrawingToolPicker2;
            }();
            exports2["default"] = DrawingToolPicker;
          },
          /* 61 */
          /***/
          function(module2, exports2) {
            "use strict";
            (function() {
              var lastTime = 0;
              var vendors = ["ms", "moz", "webkit", "o"];
              for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
                window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
                window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
              }
              if (!window.requestAnimationFrame) {
                window.requestAnimationFrame = function(callback) {
                  var currTime = (/* @__PURE__ */ new Date()).getTime();
                  var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                  var id = window.setTimeout(function() {
                    callback(currTime + timeToCall);
                  }, timeToCall);
                  lastTime = currTime + timeToCall;
                  return id;
                };
              }
              if (!window.cancelAnimationFrame) {
                window.cancelAnimationFrame = function(id) {
                  clearTimeout(id);
                };
              }
            })();
          },
          /* 62 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _chartFactory = __webpack_require__(49);
            var _chartFactory2 = _interopRequireDefault(_chartFactory);
            var _barChart = __webpack_require__(63);
            var _barChart2 = _interopRequireDefault(_barChart);
            var _columnChart = __webpack_require__(153);
            var _columnChart2 = _interopRequireDefault(_columnChart);
            var _lineChart = __webpack_require__(154);
            var _lineChart2 = _interopRequireDefault(_lineChart);
            var _areaChart = __webpack_require__(156);
            var _areaChart2 = _interopRequireDefault(_areaChart);
            var _columnLineComboChart = __webpack_require__(157);
            var _columnLineComboChart2 = _interopRequireDefault(_columnLineComboChart);
            var _lineScatterComboChart = __webpack_require__(159);
            var _lineScatterComboChart2 = _interopRequireDefault(_lineScatterComboChart);
            var _lineAreaComboChart = __webpack_require__(160);
            var _lineAreaComboChart2 = _interopRequireDefault(_lineAreaComboChart);
            var _pieDonutComboChart = __webpack_require__(161);
            var _pieDonutComboChart2 = _interopRequireDefault(_pieDonutComboChart);
            var _pieChart = __webpack_require__(162);
            var _pieChart2 = _interopRequireDefault(_pieChart);
            var _bubbleChart = __webpack_require__(163);
            var _bubbleChart2 = _interopRequireDefault(_bubbleChart);
            var _scatterChart = __webpack_require__(164);
            var _scatterChart2 = _interopRequireDefault(_scatterChart);
            var _heatmapChart = __webpack_require__(165);
            var _heatmapChart2 = _interopRequireDefault(_heatmapChart);
            var _treemapChart = __webpack_require__(168);
            var _treemapChart2 = _interopRequireDefault(_treemapChart);
            var _mapChart = __webpack_require__(169);
            var _mapChart2 = _interopRequireDefault(_mapChart);
            var _radialChart = __webpack_require__(172);
            var _radialChart2 = _interopRequireDefault(_radialChart);
            var _boxplotChart = __webpack_require__(173);
            var _boxplotChart2 = _interopRequireDefault(_boxplotChart);
            var _bulletChart = __webpack_require__(174);
            var _bulletChart2 = _interopRequireDefault(_bulletChart);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            _chartFactory2["default"].register(_const2["default"].CHART_TYPE_BAR, _barChart2["default"]);
            _chartFactory2["default"].register(_const2["default"].CHART_TYPE_COLUMN, _columnChart2["default"]);
            _chartFactory2["default"].register(_const2["default"].CHART_TYPE_LINE, _lineChart2["default"]);
            _chartFactory2["default"].register(_const2["default"].CHART_TYPE_AREA, _areaChart2["default"]);
            _chartFactory2["default"].register(_const2["default"].CHART_TYPE_COLUMN_LINE_COMBO, _columnLineComboChart2["default"]);
            _chartFactory2["default"].register(_const2["default"].CHART_TYPE_LINE_SCATTER_COMBO, _lineScatterComboChart2["default"]);
            _chartFactory2["default"].register(_const2["default"].CHART_TYPE_LINE_AREA_COMBO, _lineAreaComboChart2["default"]);
            _chartFactory2["default"].register(_const2["default"].CHART_TYPE_PIE_DONUT_COMBO, _pieDonutComboChart2["default"]);
            _chartFactory2["default"].register(_const2["default"].CHART_TYPE_PIE, _pieChart2["default"]);
            _chartFactory2["default"].register(_const2["default"].CHART_TYPE_BUBBLE, _bubbleChart2["default"]);
            _chartFactory2["default"].register(_const2["default"].CHART_TYPE_SCATTER, _scatterChart2["default"]);
            _chartFactory2["default"].register(_const2["default"].CHART_TYPE_HEATMAP, _heatmapChart2["default"]);
            _chartFactory2["default"].register(_const2["default"].CHART_TYPE_TREEMAP, _treemapChart2["default"]);
            _chartFactory2["default"].register(_const2["default"].CHART_TYPE_MAP, _mapChart2["default"]);
            _chartFactory2["default"].register(_const2["default"].CHART_TYPE_RADIAL, _radialChart2["default"]);
            _chartFactory2["default"].register(_const2["default"].CHART_TYPE_BOXPLOT, _boxplotChart2["default"]);
            _chartFactory2["default"].register(_const2["default"].CHART_TYPE_BULLET, _bulletChart2["default"]);
          },
          /* 63 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _chartBase = __webpack_require__(64);
            var _chartBase2 = _interopRequireDefault(_chartBase);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _rawDataHandler = __webpack_require__(50);
            var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var BarChart = function(_ChartBase) {
              _inherits(BarChart2, _ChartBase);
              function BarChart2(rawData, theme, options) {
                _classCallCheck(this, BarChart2);
                _rawDataHandler2["default"].updateRawSeriesDataByOptions(rawData, options.series);
                var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
                  rawData,
                  theme,
                  options,
                  hasAxes: true
                }));
                _this.className = "tui-bar-chart";
                _this._updateOptionsRelatedDiverging();
                return _this;
              }
              BarChart2.prototype._updateOptionsRelatedDiverging = function _updateOptionsRelatedDiverging() {
                var options = this.options;
                options.series = options.series || {};
                if (options.series.diverging) {
                  options.yAxis = options.yAxis || {};
                  options.xAxis = options.xAxis || {};
                  options.plot = options.plot || {};
                  options.series.stack = options.series.stack || {
                    type: _const2["default"].NORMAL_STACK_TYPE
                  };
                  var isCenter = _predicate2["default"].isYAxisAlignCenter(this.hasRightYAxis, options.yAxis.align);
                  options.yAxis.isCenter = isCenter;
                  options.xAxis.divided = isCenter;
                  options.series.divided = isCenter;
                  options.plot.divided = isCenter;
                }
              };
              BarChart2.prototype.addComponents = function addComponents() {
                this.componentManager.register("title", "title");
                this.componentManager.register("plot", "plot");
                this.componentManager.register("legend", "legend");
                this.componentManager.register("barSeries", "barSeries");
                this.componentManager.register("yAxis", "axis");
                this.componentManager.register("xAxis", "axis");
                if (this.hasRightYAxis) {
                  this.componentManager.register("rightYAxis", "axis");
                }
                this.componentManager.register("chartExportMenu", "chartExportMenu");
                this.componentManager.register("tooltip", "tooltip");
                this.componentManager.register("mouseEventDetector", "mouseEventDetector");
              };
              BarChart2.prototype.getScaleOption = function getScaleOption() {
                return {
                  xAxis: true
                };
              };
              BarChart2.prototype.onChangeCheckedLegends = function onChangeCheckedLegends(checkedLegends) {
                var boundParams = void 0;
                if (this.hasRightYAxis) {
                  boundParams = {
                    optionChartTypes: ["bar", "bar"]
                  };
                }
                _chartBase2["default"].prototype.onChangeCheckedLegends.call(this, checkedLegends, null, boundParams);
              };
              BarChart2.prototype.addDataRatios = function addDataRatios(limitMap) {
                var _options$series = this.options.series, seriesOption = _options$series === void 0 ? {} : _options$series, chartType = this.chartType;
                var _ref = seriesOption[chartType] || seriesOption, stack = _ref.stack;
                this.dataProcessor.addDataRatios(limitMap[chartType], stack, chartType);
              };
              return BarChart2;
            }(_chartBase2["default"]);
            exports2["default"] = BarChart;
          },
          /* 64 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isArray = __webpack_require__(9);
            var _isArray2 = _interopRequireDefault(_isArray);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isString = __webpack_require__(25);
            var _isString2 = _interopRequireDefault(_isString);
            var _forEach = __webpack_require__(8);
            var _forEach2 = _interopRequireDefault(_forEach);
            var _sendHostname = __webpack_require__(65);
            var _sendHostname2 = _interopRequireDefault(_sendHostname);
            var _customEvents = __webpack_require__(67);
            var _customEvents2 = _interopRequireDefault(_customEvents);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _componentManager = __webpack_require__(69);
            var _componentManager2 = _interopRequireDefault(_componentManager);
            var _dataProcessor = __webpack_require__(129);
            var _dataProcessor2 = _interopRequireDefault(_dataProcessor);
            var _rawDataHandler = __webpack_require__(50);
            var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
            var _domHandler = __webpack_require__(24);
            var _domHandler2 = _interopRequireDefault(_domHandler);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _objectUtil = __webpack_require__(55);
            var _objectUtil2 = _interopRequireDefault(_objectUtil);
            var _boundsAndScaleBuilder = __webpack_require__(141);
            var _boundsAndScaleBuilder2 = _interopRequireDefault(_boundsAndScaleBuilder);
            var _themeManager = __webpack_require__(52);
            var _themeManager2 = _interopRequireDefault(_themeManager);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var GA_TRACKING_ID = "UA-129983528-1";
            var ChartBase = function() {
              function ChartBase2(params) {
                _classCallCheck(this, ChartBase2);
                this.theme = params.theme;
                if (params.seriesTypes) {
                  this.seriesTypes = params.seriesTypes;
                }
                if (params.chartTypes) {
                  this.chartTypes = params.chartTypes;
                }
                this.originalOptions = _objectUtil2["default"].deepCopy(params.options);
                this._initializeOptions(params.options);
                this.chartType = this.options.chartType;
                this.hasAxes = params.hasAxes;
                this.isVertical = !!params.isVertical;
                this.dataProcessor = this._createDataProcessor(params);
                this.eventBus = new _customEvents2["default"]();
                this.prevXAxisData = null;
                this.componentManager = this._createComponentManager();
                this.hasRightYAxis = (0, _isArray2["default"])(this.options.yAxis) && this.options.yAxis.length > 1;
                this.addComponents();
                this._attachToEventBus();
                this.componentManager.presetAnimationConfig(this.options.series.animation);
                if (this.options.usageStatistics) {
                  (0, _sendHostname2["default"])("chart", GA_TRACKING_ID);
                }
              }
              ChartBase2.prototype.destroy = function destroy() {
                var _this = this;
                this.eventBus.off();
                this.chartContainer.outerHTML = "";
                (0, _forEach2["default"])(this, function(value, key) {
                  _this[key] = null;
                });
              };
              ChartBase2.prototype.selectSeries = function selectSeries(_ref) {
                var index = _ref.legendIndex, groupIndex = _ref.index;
                var shouldSelect = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                this.componentManager.get("mouseEventDetector").selectSeries({
                  chartType: this.chartType,
                  indexes: {
                    groupIndex,
                    index
                  }
                }, shouldSelect);
              };
              ChartBase2.prototype.unselectSeries = function unselectSeries() {
                this.componentManager.get("mouseEventDetector").unselectSeries();
              };
              ChartBase2.prototype._attachToEventBus = function _attachToEventBus() {
                this.eventBus.on("changeCheckedLegends", this.onChangeCheckedLegends, this);
                if (this.onZoom) {
                  this.eventBus.on({
                    zoom: this.onZoom,
                    resetZoom: this.onResetZoom
                  }, this);
                }
              };
              ChartBase2.prototype._setOffsetProperty = function _setOffsetProperty(options, fromProperty, toProperty) {
                if (!(0, _isExisty2["default"])(options[fromProperty])) {
                  return;
                }
                options.offset = options.offset || {};
                options.offset[toProperty] = options[fromProperty];
                delete options[fromProperty];
              };
              ChartBase2.prototype._initializeOffset = function _initializeOffset(options) {
                if (!options) {
                  return;
                }
                this._setOffsetProperty(options, "offsetX", "x");
                this._setOffsetProperty(options, "offsetY", "y");
              };
              ChartBase2.prototype._initializeTitleOptions = function _initializeTitleOptions(targetOptions) {
                var _this2 = this;
                if (!targetOptions) {
                  return;
                }
                var optionsSet = (0, _isArray2["default"])(targetOptions) ? targetOptions : [targetOptions];
                optionsSet.forEach(function(options) {
                  var title = options.title;
                  if ((0, _isString2["default"])(title)) {
                    options.title = {
                      text: title
                    };
                  }
                  _this2._initializeOffset(options.title);
                });
              };
              ChartBase2.prototype._initializeTooltipOptions = function _initializeTooltipOptions(options) {
                options.grouped = !!options.grouped;
                this._initializeOffset(options);
                delete options.position;
              };
              ChartBase2.prototype._initializeOptions = function _initializeOptions(options) {
                var originalOptions = _objectUtil2["default"].deepCopy(options);
                var defaultOption = {
                  chartTypes: this.chartTypes,
                  xAxis: {},
                  series: {},
                  tooltip: {},
                  usageStatistics: true,
                  chartExportMenu: Object.assign({
                    visible: true
                  }, originalOptions.chartExportMenu),
                  legend: Object.assign({
                    visible: true
                  }, originalOptions.legend)
                };
                delete originalOptions.chartExportMenu;
                delete originalOptions.legend;
                Object.assign(options, defaultOption, originalOptions);
                this._initializeTitleOptions(options.chart);
                this._initializeTitleOptions(options.xAxis);
                this._initializeTitleOptions(options.yAxis);
                this._initializeTooltipOptions(options.tooltip);
                this.options = options;
              };
              ChartBase2.prototype._createDataProcessor = function _createDataProcessor(params) {
                var DataProcessor = params.DataProcessor || _dataProcessor2["default"];
                var dataProcessor = new DataProcessor(params.rawData, this.chartType, params.options, this.seriesTypes);
                return dataProcessor;
              };
              ChartBase2.prototype._createComponentManager = function _createComponentManager() {
                return new _componentManager2["default"]({
                  options: this.options,
                  theme: this.theme,
                  dataProcessor: this.dataProcessor,
                  hasAxes: this.hasAxes,
                  eventBus: this.eventBus,
                  isVertical: this.isVertical,
                  seriesTypes: this.seriesTypes || [this.chartType]
                });
              };
              ChartBase2.prototype.addComponents = function addComponents() {
              };
              ChartBase2.prototype.getScaleOption = function getScaleOption() {
              };
              ChartBase2.prototype._buildBoundsAndScaleData = function _buildBoundsAndScaleData(prevXAxisData, addingDataMode) {
                return _boundsAndScaleBuilder2["default"].build(this.dataProcessor, this.componentManager, {
                  chartType: this.chartType,
                  seriesTypes: this.seriesTypes,
                  options: this.options,
                  theme: this.theme,
                  hasAxes: this.hasAxes,
                  scaleOption: this.getScaleOption(),
                  isVertical: this.isVertical,
                  hasRightYAxis: this.hasRightYAxis,
                  addedDataCount: this._dynamicDataHelper ? this._dynamicDataHelper.addedDataCount : null,
                  prevXAxisData,
                  addingDataMode
                });
              };
              ChartBase2.prototype.addDataRatios = function addDataRatios() {
              };
              ChartBase2.prototype.readyForRender = function readyForRender(addingDataMode) {
                var boundsAndScale = this._buildBoundsAndScaleData(this.prevXAxisData, addingDataMode);
                if (boundsAndScale.axisDataMap.xAxis) {
                  this.prevXAxisData = boundsAndScale.axisDataMap.xAxis;
                }
                this.addDataRatios(boundsAndScale.limitMap);
                return boundsAndScale;
              };
              ChartBase2.prototype.render = function render(wrapper) {
                var container = _domHandler2["default"].create("DIV", "tui-chart " + this.className);
                var componentManager = this.componentManager, dataProcessor = this.dataProcessor;
                var seriesVisibilityMap = dataProcessor.getLegendVisibility();
                var rawData = _rawDataHandler2["default"].filterCheckedRawData(dataProcessor.rawData, seriesVisibilityMap);
                var raphaelPaper = componentManager.drawingToolPicker.getPaper(container, _const2["default"].COMPONENT_TYPE_RAPHAEL);
                this.dataProcessor.initData(rawData);
                raphaelPaper.changeChartBackgroundColor(this.theme.chart.background.color);
                raphaelPaper.changeChartBackgroundOpacity(this.theme.chart.background.opacity);
                _renderUtil2["default"].renderFontFamily(container, this.theme.chart.fontFamily);
                _domHandler2["default"].append(wrapper, container);
                var boundsAndScale = this.readyForRender();
                _renderUtil2["default"].renderDimension(container, boundsAndScale.dimensionMap.chart);
                componentManager.render("render", boundsAndScale, {
                  checkedLegends: seriesVisibilityMap
                }, container);
                this.chartContainer = container;
                this.paper = raphaelPaper;
              };
              ChartBase2.prototype.protectedRerender = function protectedRerender(checkedLegends, rawData) {
                var dataProcessor = this.dataProcessor;
                if (!rawData) {
                  rawData = _rawDataHandler2["default"].filterCheckedRawData(dataProcessor.getCurrentData(), checkedLegends);
                }
                this.dataProcessor.initData(rawData);
                var boundsAndScale = this.readyForRender();
                this.componentManager.render("rerender", boundsAndScale, {
                  checkedLegends
                }, this.chartContainer);
              };
              ChartBase2.prototype.rerender = function rerender(checkedLegends, rawData) {
                checkedLegends = checkedLegends || this.getCheckedLegend();
                rawData = rawData || this.dataProcessor.getOriginalRawData();
                var seriesData = rawData.series;
                rawData.series = Object.keys(seriesData).reduce(function(result, item) {
                  var series = seriesData[item];
                  var checkedInfo = checkedLegends[item];
                  result[item] = series.map(function(seriesItem, index) {
                    seriesItem.visible = checkedInfo[index];
                    return seriesItem;
                  });
                  return result;
                }, {});
                this.setData(rawData);
              };
              ChartBase2.prototype.setData = function setData() {
                var rawData = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                var animation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                var data = this._initializeRawData(rawData);
                var dataProcessor = this.dataProcessor;
                var _options = this.options, chartType = _options.chartType, themeOptions = _options.theme;
                dataProcessor.initData(data, true);
                var theme = _themeManager2["default"].get(themeOptions, chartType, data.series);
                this.theme = theme;
                this.componentManager.presetBeforeRerender();
                this.componentManager.presetForChangeData(theme);
                this.componentManager.presetAnimationConfig(animation);
                this.protectedRerender(dataProcessor.getLegendVisibility());
              };
              ChartBase2.prototype.getCheckedLegend = function getCheckedLegend() {
                var componentManager = this.componentManager, dataProcessor = this.dataProcessor;
                var hasLegendComponent = componentManager.has("legend");
                return hasLegendComponent ? componentManager.get("legend").getCheckedIndexes() : dataProcessor.getLegendVisibility();
              };
              ChartBase2.prototype._initializeRawData = function _initializeRawData(rawData) {
                this.prevXAxisData = null;
                var data = _objectUtil2["default"].deepCopy(rawData);
                var _originalOptions = this.originalOptions, chartType = _originalOptions.chartType, seriesOption = _originalOptions.series;
                if (chartType !== "combo" && (0, _isArray2["default"])(data.series)) {
                  var clonedSeries = data.series;
                  data.series = {};
                  data.series[chartType] = clonedSeries;
                }
                _rawDataHandler2["default"].updateRawSeriesDataByOptions(data, seriesOption);
                if (chartType === "boxplot") {
                  _rawDataHandler2["default"].appendOutliersToSeriesData(data);
                }
                return data;
              };
              ChartBase2.prototype.onChangeCheckedLegends = function onChangeCheckedLegends(checkedLegends, rawData, boundsParams) {
                this.protectedRerender(checkedLegends, rawData, boundsParams);
              };
              ChartBase2.prototype.animateChart = function animateChart() {
                this.componentManager.execute("animateComponent");
              };
              ChartBase2.prototype.on = function on(eventName, func) {
                if (_const2["default"].PUBLIC_EVENT_MAP[eventName]) {
                  this.eventBus.on(_const2["default"].PUBLIC_EVENT_PREFIX + eventName, func);
                }
              };
              ChartBase2.prototype.off = function off(eventName, func) {
                if (_const2["default"].PUBLIC_EVENT_MAP[eventName]) {
                  this.eventBus.off(_const2["default"].PUBLIC_EVENT_PREFIX + eventName, func);
                }
              };
              ChartBase2.prototype._updateChartDimension = function _updateChartDimension(dimension) {
                var updated = false;
                var options = this.options;
                options.chart = options.chart || {};
                if (dimension.width && dimension.width > 0 && options.chart.width !== dimension.width) {
                  options.chart.width = dimension.width;
                  updated = true;
                }
                if (dimension.height && dimension.height > 0 && options.chart.height !== dimension.height) {
                  options.chart.height = dimension.height;
                  updated = true;
                }
                return updated;
              };
              ChartBase2.prototype.resize = function resize(dimension) {
                var dataProcessor = this.dataProcessor;
                var seriesVisibilityMap = dataProcessor.getLegendVisibility();
                if (!dimension) {
                  return;
                }
                var updated = this._updateChartDimension(dimension);
                if (!updated) {
                  return;
                }
                var boundsAndScale = this.readyForRender();
                var chartDimension = boundsAndScale.dimensionMap.chart;
                _renderUtil2["default"].renderDimension(this.chartContainer, chartDimension);
                this.paper.resizeBackground(chartDimension.width, chartDimension.height);
                this.paper.setSize(chartDimension.width, chartDimension.height);
                this.componentManager.render("resize", boundsAndScale, {
                  checkedLegends: seriesVisibilityMap
                });
              };
              ChartBase2.prototype.setTooltipAlign = function setTooltipAlign(align) {
                this.componentManager.get("tooltip").setAlign(align);
              };
              ChartBase2.prototype.setTooltipOffset = function setTooltipOffset(offset) {
                this.componentManager.get("tooltip").setOffset(offset);
              };
              ChartBase2.prototype.setTooltipPosition = function setTooltipPosition(position) {
                this.componentManager.get("tooltip").setPosition(position);
              };
              ChartBase2.prototype.resetTooltipAlign = function resetTooltipAlign() {
                this.componentManager.get("tooltip").resetAlign();
              };
              ChartBase2.prototype.resetTooltipOffset = function resetTooltipOffset() {
                this.componentManager.get("tooltip").resetOffset();
              };
              ChartBase2.prototype.resetTooltipPosition = function resetTooltipPosition() {
                this.resetTooltipOffset();
              };
              ChartBase2.prototype.showSeriesLabel = function showSeriesLabel() {
                var seriesSet = this.componentManager.where({
                  componentType: "series"
                });
                seriesSet.forEach(function(series) {
                  series.showLabel();
                });
              };
              ChartBase2.prototype.hideSeriesLabel = function hideSeriesLabel() {
                var seriesSet = this.componentManager.where({
                  componentType: "series"
                });
                seriesSet.forEach(function(series) {
                  series.hideLabel();
                });
              };
              ChartBase2.prototype.addData = function addData() {
              };
              ChartBase2.prototype.addPlotLine = function addPlotLine() {
              };
              ChartBase2.prototype.addPlotBand = function addPlotBand() {
              };
              ChartBase2.prototype.removePlotLine = function removePlotLine() {
              };
              ChartBase2.prototype.removePlotBand = function removePlotBand() {
              };
              ChartBase2.prototype._getSeriesData = function _getSeriesData(index, seriesIndex, outlierIndex) {
                var indexes = {
                  index,
                  seriesIndex,
                  outlierIndex
                };
                if (seriesIndex < 0) {
                  return null;
                }
                return this.componentManager.get("mouseEventDetector").findDataByIndexes(indexes);
              };
              ChartBase2.prototype._findSeriesIndexByLabel = function _findSeriesIndexByLabel(chartType, legendLabel) {
                var labels = this.dataProcessor.getLegendLabels(chartType);
                var len = labels ? labels.length : 0;
                var seriesIndex = -1;
                for (var i = 0; i < len; i += 1) {
                  if (labels[i] === legendLabel) {
                    seriesIndex = i;
                    break;
                  }
                }
                return seriesIndex;
              };
              ChartBase2.prototype._findDataByIndexes = function _findDataByIndexes(index, seriesIndex) {
                return this.componentManager.get("mouseEventDetector").findDataByIndexes(index, seriesIndex);
              };
              ChartBase2.prototype.showTooltip = function showTooltip(params) {
                var foundSeriesIndex = void 0, foundData = void 0;
                if (!_predicate2["default"].isSupportPublicShowTooptipAPI(this.chartType)) {
                  return;
                }
                var isGroupTooltip = this.options.tooltip && this.options.tooltip.grouped;
                var mouseEventDetector = this.componentManager.get("mouseEventDetector");
                if (isGroupTooltip) {
                  foundData = {
                    indexes: {
                      groupIndex: params.index
                    }
                  };
                } else {
                  foundSeriesIndex = this._findSeriesIndexByLabel(params.chartType, params.legend);
                  foundData = this._getSeriesData(params.index, foundSeriesIndex, params.outlierIndex);
                }
                if (foundData) {
                  foundData.silent = true;
                  mouseEventDetector._showTooltip(foundData);
                } else {
                  this.hideTooltip();
                }
              };
              ChartBase2.prototype.hideTooltip = function hideTooltip() {
                if (!_predicate2["default"].isSupportPublicShowTooptipAPI(this.chartType)) {
                  return;
                }
                var isGroupTooltip = this.options.tooltip && this.options.tooltip.grouped;
                var mouseEventDetector = this.componentManager.get("mouseEventDetector");
                if (isGroupTooltip && mouseEventDetector.prevIndex >= 0 || !isGroupTooltip && mouseEventDetector.prevFoundData) {
                  mouseEventDetector._hideTooltip({
                    silent: true
                  });
                }
              };
              return ChartBase2;
            }();
            exports2["default"] = ChartBase;
          },
          /* 65 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var isUndefined = __webpack_require__(14);
            var imagePing = __webpack_require__(66);
            var ms7days = 7 * 24 * 60 * 60 * 1e3;
            function isExpired(date) {
              var now = (/* @__PURE__ */ new Date()).getTime();
              return now - date > ms7days;
            }
            function sendHostname(appName, trackingId) {
              var url = "https://www.google-analytics.com/collect";
              var hostname = location.hostname;
              var hitType = "event";
              var eventCategory = "use";
              var applicationKeyForStorage = "TOAST UI " + appName + " for " + hostname + ": Statistics";
              var date = window.localStorage.getItem(applicationKeyForStorage);
              if (!isUndefined(window.tui) && window.tui.usageStatistics === false) {
                return;
              }
              if (date && !isExpired(date)) {
                return;
              }
              window.localStorage.setItem(applicationKeyForStorage, (/* @__PURE__ */ new Date()).getTime());
              setTimeout(function() {
                if (document.readyState === "interactive" || document.readyState === "complete") {
                  imagePing(url, {
                    v: 1,
                    t: hitType,
                    tid: trackingId,
                    cid: hostname,
                    dp: hostname,
                    dh: appName,
                    el: appName,
                    ec: eventCategory
                  });
                }
              }, 1e3);
            }
            module2.exports = sendHostname;
          },
          /* 66 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var forEachOwnProperties = __webpack_require__(11);
            function imagePing(url, trackingInfo) {
              var trackingElement = document.createElement("img");
              var queryString = "";
              forEachOwnProperties(trackingInfo, function(value, key) {
                queryString += "&" + key + "=" + value;
              });
              queryString = queryString.substring(1);
              trackingElement.src = url + "?" + queryString;
              trackingElement.style.display = "none";
              document.body.appendChild(trackingElement);
              document.body.removeChild(trackingElement);
              return trackingElement;
            }
            module2.exports = imagePing;
          },
          /* 67 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var extend = __webpack_require__(68);
            var isExisty = __webpack_require__(15);
            var isString = __webpack_require__(25);
            var isObject = __webpack_require__(7);
            var isArray = __webpack_require__(9);
            var isFunction = __webpack_require__(56);
            var forEach = __webpack_require__(8);
            var R_EVENTNAME_SPLIT = /\s+/g;
            function CustomEvents() {
              this.events = null;
              this.contexts = null;
            }
            CustomEvents.mixin = function(func) {
              extend(func.prototype, CustomEvents.prototype);
            };
            CustomEvents.prototype._getHandlerItem = function(handler, context) {
              var item = {
                handler
              };
              if (context) {
                item.context = context;
              }
              return item;
            };
            CustomEvents.prototype._safeEvent = function(eventName) {
              var events = this.events;
              var byName;
              if (!events) {
                events = this.events = {};
              }
              if (eventName) {
                byName = events[eventName];
                if (!byName) {
                  byName = [];
                  events[eventName] = byName;
                }
                events = byName;
              }
              return events;
            };
            CustomEvents.prototype._safeContext = function() {
              var context = this.contexts;
              if (!context) {
                context = this.contexts = [];
              }
              return context;
            };
            CustomEvents.prototype._indexOfContext = function(ctx) {
              var context = this._safeContext();
              var index = 0;
              while (context[index]) {
                if (ctx === context[index][0]) {
                  return index;
                }
                index += 1;
              }
              return -1;
            };
            CustomEvents.prototype._memorizeContext = function(ctx) {
              var context, index;
              if (!isExisty(ctx)) {
                return;
              }
              context = this._safeContext();
              index = this._indexOfContext(ctx);
              if (index > -1) {
                context[index][1] += 1;
              } else {
                context.push([ctx, 1]);
              }
            };
            CustomEvents.prototype._forgetContext = function(ctx) {
              var context, contextIndex;
              if (!isExisty(ctx)) {
                return;
              }
              context = this._safeContext();
              contextIndex = this._indexOfContext(ctx);
              if (contextIndex > -1) {
                context[contextIndex][1] -= 1;
                if (context[contextIndex][1] <= 0) {
                  context.splice(contextIndex, 1);
                }
              }
            };
            CustomEvents.prototype._bindEvent = function(eventName, handler, context) {
              var events = this._safeEvent(eventName);
              this._memorizeContext(context);
              events.push(this._getHandlerItem(handler, context));
            };
            CustomEvents.prototype.on = function(eventName, handler, context) {
              var self2 = this;
              if (isString(eventName)) {
                eventName = eventName.split(R_EVENTNAME_SPLIT);
                forEach(eventName, function(name) {
                  self2._bindEvent(name, handler, context);
                });
              } else if (isObject(eventName)) {
                context = handler;
                forEach(eventName, function(func, name) {
                  self2.on(name, func, context);
                });
              }
            };
            CustomEvents.prototype.once = function(eventName, handler, context) {
              var self2 = this;
              if (isObject(eventName)) {
                context = handler;
                forEach(eventName, function(func, name) {
                  self2.once(name, func, context);
                });
                return;
              }
              function onceHandler() {
                handler.apply(context, arguments);
                self2.off(eventName, onceHandler, context);
              }
              this.on(eventName, onceHandler, context);
            };
            CustomEvents.prototype._spliceMatches = function(arr, predicate) {
              var i = 0;
              var len;
              if (!isArray(arr)) {
                return;
              }
              for (len = arr.length; i < len; i += 1) {
                if (predicate(arr[i]) === true) {
                  arr.splice(i, 1);
                  len -= 1;
                  i -= 1;
                }
              }
            };
            CustomEvents.prototype._matchHandler = function(handler) {
              var self2 = this;
              return function(item) {
                var needRemove = handler === item.handler;
                if (needRemove) {
                  self2._forgetContext(item.context);
                }
                return needRemove;
              };
            };
            CustomEvents.prototype._matchContext = function(context) {
              var self2 = this;
              return function(item) {
                var needRemove = context === item.context;
                if (needRemove) {
                  self2._forgetContext(item.context);
                }
                return needRemove;
              };
            };
            CustomEvents.prototype._matchHandlerAndContext = function(handler, context) {
              var self2 = this;
              return function(item) {
                var matchHandler = handler === item.handler;
                var matchContext = context === item.context;
                var needRemove = matchHandler && matchContext;
                if (needRemove) {
                  self2._forgetContext(item.context);
                }
                return needRemove;
              };
            };
            CustomEvents.prototype._offByEventName = function(eventName, handler) {
              var self2 = this;
              var andByHandler = isFunction(handler);
              var matchHandler = self2._matchHandler(handler);
              eventName = eventName.split(R_EVENTNAME_SPLIT);
              forEach(eventName, function(name) {
                var handlerItems = self2._safeEvent(name);
                if (andByHandler) {
                  self2._spliceMatches(handlerItems, matchHandler);
                } else {
                  forEach(handlerItems, function(item) {
                    self2._forgetContext(item.context);
                  });
                  self2.events[name] = [];
                }
              });
            };
            CustomEvents.prototype._offByHandler = function(handler) {
              var self2 = this;
              var matchHandler = this._matchHandler(handler);
              forEach(this._safeEvent(), function(handlerItems) {
                self2._spliceMatches(handlerItems, matchHandler);
              });
            };
            CustomEvents.prototype._offByObject = function(obj, handler) {
              var self2 = this;
              var matchFunc;
              if (this._indexOfContext(obj) < 0) {
                forEach(obj, function(func, name) {
                  self2.off(name, func);
                });
              } else if (isString(handler)) {
                matchFunc = this._matchContext(obj);
                self2._spliceMatches(this._safeEvent(handler), matchFunc);
              } else if (isFunction(handler)) {
                matchFunc = this._matchHandlerAndContext(handler, obj);
                forEach(this._safeEvent(), function(handlerItems) {
                  self2._spliceMatches(handlerItems, matchFunc);
                });
              } else {
                matchFunc = this._matchContext(obj);
                forEach(this._safeEvent(), function(handlerItems) {
                  self2._spliceMatches(handlerItems, matchFunc);
                });
              }
            };
            CustomEvents.prototype.off = function(eventName, handler) {
              if (isString(eventName)) {
                this._offByEventName(eventName, handler);
              } else if (!arguments.length) {
                this.events = {};
                this.contexts = [];
              } else if (isFunction(eventName)) {
                this._offByHandler(eventName);
              } else if (isObject(eventName)) {
                this._offByObject(eventName, handler);
              }
            };
            CustomEvents.prototype.fire = function(eventName) {
              this.invoke.apply(this, arguments);
            };
            CustomEvents.prototype.invoke = function(eventName) {
              var events, args, index, item;
              if (!this.hasListener(eventName)) {
                return true;
              }
              events = this._safeEvent(eventName);
              args = Array.prototype.slice.call(arguments, 1);
              index = 0;
              while (events[index]) {
                item = events[index];
                if (item.handler.apply(item.context, args) === false) {
                  return false;
                }
                index += 1;
              }
              return true;
            };
            CustomEvents.prototype.hasListener = function(eventName) {
              return this.getListenerLength(eventName) > 0;
            };
            CustomEvents.prototype.getListenerLength = function(eventName) {
              var events = this._safeEvent(eventName);
              return events.length;
            };
            module2.exports = CustomEvents;
          },
          /* 68 */
          /***/
          function(module2, exports2) {
            "use strict";
            function extend(target, objects) {
              var hasOwnProp = Object.prototype.hasOwnProperty;
              var source, prop, i, len;
              for (i = 1, len = arguments.length; i < len; i += 1) {
                source = arguments[i];
                for (prop in source) {
                  if (hasOwnProp.call(source, prop)) {
                    target[prop] = source[prop];
                  }
                }
              }
              return target;
            }
            module2.exports = extend;
          },
          /* 69 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _isArray = __webpack_require__(9);
            var _isArray2 = _interopRequireDefault(_isArray);
            var _isBoolean = __webpack_require__(28);
            var _isBoolean2 = _interopRequireDefault(_isBoolean);
            var _isNumber = __webpack_require__(19);
            var _isNumber2 = _interopRequireDefault(_isNumber);
            var _isObject = __webpack_require__(7);
            var _isObject2 = _interopRequireDefault(_isObject);
            var _pick = __webpack_require__(21);
            var _pick2 = _interopRequireDefault(_pick);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _domHandler = __webpack_require__(24);
            var _domHandler2 = _interopRequireDefault(_domHandler);
            var _axis = __webpack_require__(70);
            var _axis2 = _interopRequireDefault(_axis);
            var _plot = __webpack_require__(71);
            var _plot2 = _interopRequireDefault(_plot);
            var _title = __webpack_require__(72);
            var _title2 = _interopRequireDefault(_title);
            var _radialPlot = __webpack_require__(73);
            var _radialPlot2 = _interopRequireDefault(_radialPlot);
            var _chartExportMenu = __webpack_require__(75);
            var _chartExportMenu2 = _interopRequireDefault(_chartExportMenu);
            var _drawingToolPicker = __webpack_require__(60);
            var _drawingToolPicker2 = _interopRequireDefault(_drawingToolPicker);
            var _legend = __webpack_require__(81);
            var _legend2 = _interopRequireDefault(_legend);
            var _spectrumLegend = __webpack_require__(86);
            var _spectrumLegend2 = _interopRequireDefault(_spectrumLegend);
            var _circleLegend = __webpack_require__(87);
            var _circleLegend2 = _interopRequireDefault(_circleLegend);
            var _tooltip = __webpack_require__(88);
            var _tooltip2 = _interopRequireDefault(_tooltip);
            var _groupTooltip = __webpack_require__(94);
            var _groupTooltip2 = _interopRequireDefault(_groupTooltip);
            var _mapChartTooltip = __webpack_require__(96);
            var _mapChartTooltip2 = _interopRequireDefault(_mapChartTooltip);
            var _mapChartEventDetector = __webpack_require__(97);
            var _mapChartEventDetector2 = _interopRequireDefault(_mapChartEventDetector);
            var _mouseEventDetector = __webpack_require__(101);
            var _mouseEventDetector2 = _interopRequireDefault(_mouseEventDetector);
            var _barChartSeries = __webpack_require__(108);
            var _barChartSeries2 = _interopRequireDefault(_barChartSeries);
            var _columnChartSeries = __webpack_require__(112);
            var _columnChartSeries2 = _interopRequireDefault(_columnChartSeries);
            var _lineChartSeries = __webpack_require__(113);
            var _lineChartSeries2 = _interopRequireDefault(_lineChartSeries);
            var _radialSeries = __webpack_require__(115);
            var _radialSeries2 = _interopRequireDefault(_radialSeries);
            var _areaChartSeries = __webpack_require__(116);
            var _areaChartSeries2 = _interopRequireDefault(_areaChartSeries);
            var _bubbleChartSeries = __webpack_require__(117);
            var _bubbleChartSeries2 = _interopRequireDefault(_bubbleChartSeries);
            var _scatterChartSeries = __webpack_require__(119);
            var _scatterChartSeries2 = _interopRequireDefault(_scatterChartSeries);
            var _mapChartSeries = __webpack_require__(120);
            var _mapChartSeries2 = _interopRequireDefault(_mapChartSeries);
            var _pieChartSeries = __webpack_require__(121);
            var _pieChartSeries2 = _interopRequireDefault(_pieChartSeries);
            var _heatmapChartSeries = __webpack_require__(122);
            var _heatmapChartSeries2 = _interopRequireDefault(_heatmapChartSeries);
            var _treemapChartSeries = __webpack_require__(123);
            var _treemapChartSeries2 = _interopRequireDefault(_treemapChartSeries);
            var _boxPlotChartSeries = __webpack_require__(125);
            var _boxPlotChartSeries2 = _interopRequireDefault(_boxPlotChartSeries);
            var _bulletChartSeries = __webpack_require__(126);
            var _bulletChartSeries2 = _interopRequireDefault(_bulletChartSeries);
            var _zoom = __webpack_require__(127);
            var _zoom2 = _interopRequireDefault(_zoom);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var COMPONENT_FACTORY_MAP = {
              axis: _axis2["default"],
              plot: _plot2["default"],
              radialPlot: _radialPlot2["default"],
              legend: _legend2["default"],
              spectrumLegend: _spectrumLegend2["default"],
              circleLegend: _circleLegend2["default"],
              tooltip: _tooltip2["default"],
              groupTooltip: _groupTooltip2["default"],
              mapChartTooltip: _mapChartTooltip2["default"],
              mapChartEventDetector: _mapChartEventDetector2["default"],
              mouseEventDetector: _mouseEventDetector2["default"],
              barSeries: _barChartSeries2["default"],
              columnSeries: _columnChartSeries2["default"],
              lineSeries: _lineChartSeries2["default"],
              radialSeries: _radialSeries2["default"],
              areaSeries: _areaChartSeries2["default"],
              bubbleSeries: _bubbleChartSeries2["default"],
              scatterSeries: _scatterChartSeries2["default"],
              mapSeries: _mapChartSeries2["default"],
              pieSeries: _pieChartSeries2["default"],
              heatmapSeries: _heatmapChartSeries2["default"],
              treemapSeries: _treemapChartSeries2["default"],
              boxplotSeries: _boxPlotChartSeries2["default"],
              bulletSeries: _bulletChartSeries2["default"],
              zoom: _zoom2["default"],
              chartExportMenu: _chartExportMenu2["default"],
              title: _title2["default"]
            };
            var ComponentManager = function() {
              function ComponentManager2(params) {
                _classCallCheck(this, ComponentManager2);
                var chartOption = params.options.chart;
                var width = (0, _pick2["default"])(chartOption, "width") || _const2["default"].CHART_DEFAULT_WIDTH;
                var height = (0, _pick2["default"])(chartOption, "height") || _const2["default"].CHART_DEFAULT_HEIGHT;
                this.components = [];
                this.componentMap = {};
                this.theme = params.theme || {};
                this.options = params.options || {};
                this.dataProcessor = params.dataProcessor;
                this.hasAxes = params.hasAxes;
                this.isVertical = params.isVertical;
                this.eventBus = params.eventBus;
                this.drawingToolPicker = new _drawingToolPicker2["default"]();
                this.drawingToolPicker.initDimension({
                  width,
                  height
                });
                this.seriesTypes = params.seriesTypes;
              }
              ComponentManager2.prototype._makeComponentOptions = function _makeComponentOptions(options, optionKey, componentName, index) {
                options = options || this.options[optionKey];
                options = (0, _isArray2["default"])(options) ? options[index] : options || {};
                return options;
              };
              ComponentManager2.prototype.register = function register(name, classType) {
                var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                var index = params.index || 0;
                var componentFactory = COMPONENT_FACTORY_MAP[classType];
                var componentType = componentFactory.componentType;
                params.name = name;
                params.chartTheme = this.theme;
                params.chartOptions = this.options;
                params.seriesTypes = this.seriesTypes;
                var optionKey = this._getOptionKey(componentType, name);
                params.theme = this._makeTheme(optionKey, name);
                params.options = this._makeOptions(optionKey, name, index);
                params.dataProcessor = this.dataProcessor;
                params.hasAxes = this.hasAxes;
                params.isVertical = this.isVertical;
                params.eventBus = this.eventBus;
                params.alternativeModel = this.alternativeModel;
                var component = componentFactory(params);
                if (component) {
                  component.componentName = name;
                  component.componentType = componentType;
                  this.components.push(component);
                  this.componentMap[name] = component;
                }
              };
              ComponentManager2.prototype.presetBeforeRerender = function presetBeforeRerender() {
                if (this.componentMap.mouseEventDetector.zoomable) {
                  this.componentMap.mouseEventDetector.presetBeforeRerender();
                }
              };
              ComponentManager2.prototype.presetForChangeData = function presetForChangeData(theme) {
                var _this = this;
                this.theme = theme;
                this.components.forEach(function(component) {
                  if (component.presetForChangeData) {
                    var componentType = component.componentType, componentName = component.componentName;
                    var optionKey = _this._getOptionKey(componentType, componentName);
                    component.presetForChangeData(_this._makeTheme(optionKey, componentName));
                  }
                });
              };
              ComponentManager2.prototype.presetAnimationConfig = function presetAnimationConfig(animation) {
                var _this2 = this;
                this.seriesTypes.forEach(function(seriesType) {
                  if ((0, _isObject2["default"])(_this2.options.series[seriesType])) {
                    _this2.options.series[seriesType].animationDuration = _this2._getAnimationDuration(animation);
                  } else {
                    _this2.options.series.animationDuration = _this2._getAnimationDuration(animation);
                  }
                });
              };
              ComponentManager2.prototype._getAnimationDuration = function _getAnimationDuration(animation) {
                if ((0, _isBoolean2["default"])(animation) && !animation) {
                  return 0;
                }
                if ((0, _isObject2["default"])(animation) && (0, _isNumber2["default"])(animation.duration)) {
                  return animation.duration;
                }
                return _raphaelRenderUtil2["default"].getDefaultAnimationDuration(this.options.chartType);
              };
              ComponentManager2.prototype._makeOptions = function _makeOptions(optionKey, name, index) {
                var options = this.options[optionKey];
                if (!options && optionKey === "rightYAxis") {
                  options = this.options.yAxis;
                }
                if (optionKey === "series") {
                  this.seriesTypes.forEach(function(seriesType) {
                    if (name.indexOf(seriesType) === 0) {
                      options = options[seriesType] || options;
                      if ((0, _isArray2["default"])(options)) {
                        options = options[index] || {};
                      }
                      return false;
                    }
                    return true;
                  });
                }
                return options;
              };
              ComponentManager2.prototype._getOptionKey = function _getOptionKey(type, name) {
                return type === "axis" ? name : type;
              };
              ComponentManager2.prototype._makeTheme = function _makeTheme(optionKey, name) {
                var theme = this.theme[optionKey];
                if (!theme && optionKey === "rightYAxis") {
                  theme = this.theme.yAxis;
                }
                if (optionKey === "series") {
                  this.seriesTypes.forEach(function(seriesType) {
                    if (name.indexOf(seriesType) === 0) {
                      theme = theme[seriesType];
                      return false;
                    }
                    return true;
                  });
                }
                return theme;
              };
              ComponentManager2.prototype._makeDataForRendering = function _makeDataForRendering(name, type, paper, boundsAndScale, additionalData) {
                var data = Object.assign({
                  paper
                }, additionalData);
                if (boundsAndScale) {
                  Object.assign(data, boundsAndScale);
                  data.layout = {
                    dimension: data.dimensionMap[name] || data.dimensionMap[type],
                    position: data.positionMap[name] || data.positionMap[type]
                  };
                }
                return data;
              };
              ComponentManager2.prototype.render = function render(funcName, boundsAndScale, additionalData, container) {
                var _this3 = this;
                var elements = this.components.map(function(component) {
                  var element = null;
                  if (component[funcName]) {
                    var name = component.componentName;
                    var type = component.componentType;
                    var paper = _this3.drawingToolPicker.getPaper(container, component.drawingType);
                    var data = _this3._makeDataForRendering(name, type, paper, boundsAndScale, additionalData);
                    var result = component[funcName](data);
                    if (result && !result.paper) {
                      element = result;
                    }
                  }
                  return element;
                });
                if (container) {
                  _domHandler2["default"].append(container, elements);
                }
              };
              ComponentManager2.prototype.where = function where(conditionMap) {
                return this.components.filter(function(component) {
                  var contained = true;
                  Object.entries(conditionMap).forEach(function(_ref) {
                    var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
                    if (component[key] !== value) {
                      contained = false;
                    }
                    return contained;
                  });
                  return contained;
                });
              };
              ComponentManager2.prototype.execute = function execute(funcName) {
                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                this.components.forEach(function(component) {
                  if (component[funcName]) {
                    component[funcName].apply(component, args);
                  }
                });
              };
              ComponentManager2.prototype.get = function get(name) {
                return this.componentMap[name];
              };
              ComponentManager2.prototype.has = function has(name) {
                return !!this.get(name);
              };
              return ComponentManager2;
            }();
            exports2["default"] = ComponentManager;
          },
          /* 70 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = axisFactory;
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            var _pluginFactory = __webpack_require__(51);
            var _pluginFactory2 = _interopRequireDefault(_pluginFactory);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var AXIS_EDGE_RATIO = _const2["default"].AXIS_EDGE_RATIO, X_AXIS_LABEL_PADDING = _const2["default"].X_AXIS_LABEL_PADDING, COMPONENT_TYPE_RAPHAEL = _const2["default"].COMPONENT_TYPE_RAPHAEL;
            var Axis = function() {
              function Axis2(params) {
                _classCallCheck(this, Axis2);
                var dataProcessor = params.dataProcessor, options = params.options, chartTheme = params.chartTheme, theme = params.theme, name = params.name, isYAxis = params.isYAxis, shifting = params.shifting;
                this.className = "tui-chart-axis-area";
                this.dataProcessor = dataProcessor;
                this.options = options || {};
                this.theme = Object.assign({}, theme, {
                  background: chartTheme.chart.background
                });
                this.isLabelAxis = false;
                this.isYAxis = isYAxis;
                this.shifting = shifting;
                this.data = {};
                this.layout = null;
                this.dimensionMap = null;
                this.axisDataMap = null;
                this.graphRenderer = _pluginFactory2["default"].get(COMPONENT_TYPE_RAPHAEL, "axis");
                this.drawingType = COMPONENT_TYPE_RAPHAEL;
                this.paperAdditionalWidth = 0;
                this.paperAdditionalHeight = 0;
                this._elBg = null;
                this.isRightYAxis = name === "rightYAxis";
              }
              Axis2.prototype._renderBackground = function _renderBackground() {
                var dimension = Object.assign({}, this.layout.dimension);
                var position = Object.assign({}, this.layout.position);
                if (this._elBg) {
                  this._elBg.remove();
                }
                this._elBg = this.graphRenderer.renderBackground(this.paper, position, dimension, this.theme.background);
              };
              Axis2.prototype._renderChildContainers = function _renderChildContainers(size, tickCount, categories) {
                var additionalWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
                var isYAxisLineType = this.isYAxis && this.data.aligned;
                var axisLimit = this.limitMap[this.dataProcessor.chartType];
                var isNegativeLimitChart = !this.data.limit && axisLimit && axisLimit.min < 0;
                var isBarChart = _predicate2["default"].isBarTypeChart(this.dataProcessor.chartType);
                var seriesOption = this.dataProcessor.getOption("series") || {};
                var isDivergingOption = seriesOption.diverging;
                if (this.isYAxis && !this.data.isPositionRight && !this.options.isCenter && this.shifting) {
                  this._renderBackground();
                }
                this._renderTitleArea(size, additionalWidth);
                if (this.options.showLabel !== false) {
                  this._renderLabelArea(size, tickCount, categories, additionalWidth);
                }
                if (!isYAxisLineType) {
                  this._renderTickArea(size, tickCount, additionalWidth);
                }
                if (isNegativeLimitChart && isBarChart && !isDivergingOption) {
                  this._renderNegativeStandardsLine(size, additionalWidth, this.dimensionMap.series, axisLimit);
                }
              };
              Axis2.prototype._renderDividedAxis = function _renderDividedAxis(_ref) {
                var width = _ref.width;
                var _data = this.data, tickCount = _data.tickCount, categories = _data.labels;
                var lSideWidth = Math.round(width / 2);
                var rSideWidth = width - lSideWidth - 1;
                var halfTickCount = parseInt(tickCount / 2, 10) + 1;
                var lCategories = categories.slice(0, halfTickCount);
                var rCategories = categories.slice(halfTickCount - 1, tickCount);
                var tickInterval = lSideWidth / halfTickCount;
                var secondXAxisAdditionalPosition = lSideWidth + this.dimensionMap.yAxis.width - 1;
                this.paperAdditionalWidth = tickInterval;
                this._renderChildContainers(lSideWidth, halfTickCount, lCategories, 0);
                this._renderChildContainers(rSideWidth + 1, halfTickCount, rCategories, secondXAxisAdditionalPosition);
              };
              Axis2.prototype._renderNotDividedAxis = function _renderNotDividedAxis(_ref2) {
                var width = _ref2.width, height = _ref2.height;
                var _data2 = this.data, positionRatio = _data2.positionRatio, tickCount = _data2.tickCount, labels = _data2.labels;
                var isYAxis = this.isYAxis;
                var size = isYAxis ? height : width;
                var additionalSize = 0;
                if (positionRatio) {
                  additionalSize = size * positionRatio;
                }
                this._renderChildContainers(size, tickCount, labels, additionalSize);
              };
              Axis2.prototype._renderAxisArea = function _renderAxisArea() {
                var dimension = this.layout.dimension;
                var isLabelAxis = this.data.isLabelAxis;
                var _options = this.options, divided = _options.divided, isCenter = _options.isCenter;
                var width = dimension.width;
                this.isLabelAxis = isLabelAxis;
                if (divided) {
                  this.containerWidth = width + this.dimensionMap.yAxis.width;
                  this._renderDividedAxis(dimension);
                  width = this.containerWidth;
                } else {
                  width += isCenter ? 1 : 0;
                  this._renderNotDividedAxis(dimension);
                }
              };
              Axis2.prototype._setDataForRendering = function _setDataForRendering(_ref3) {
                var layout = _ref3.layout, dimensionMap = _ref3.dimensionMap, limitMap = _ref3.limitMap, axisDataMap = _ref3.axisDataMap;
                this.layout = layout;
                this.dimensionMap = dimensionMap;
                this.limitMap = limitMap;
                this.data = axisDataMap[this.componentName];
                this.options = this.data.options;
              };
              Axis2.prototype.render = function render(data) {
                var paper = data.paper;
                this.paper = paper;
                this.axisSet = paper.set();
                this._setDataForRendering(data);
                this._renderAxisArea();
              };
              Axis2.prototype.rerender = function rerender(data) {
                this.axisSet.remove();
                this.render(data);
              };
              Axis2.prototype.resize = function resize(data) {
                this.rerender(data);
              };
              Axis2.prototype.zoom = function zoom(data) {
                this.rerender(data);
              };
              Axis2.prototype._getOtherSideDimension = function _getOtherSideDimension() {
                return this.dimensionMap[this.isYAxis ? "xAxis" : "yAxis"];
              };
              Axis2.prototype._renderTitleArea = function _renderTitleArea(size, additionalWidth) {
                var _options$title = this.options.title, title = _options$title === void 0 ? {} : _options$title;
                var xAxisOption = this.dataProcessor.getOption("xAxis");
                var yAxisOption = this.dataProcessor.getOption("yAxis");
                var seriesOption = this.dataProcessor.getOption("series") || {};
                if (title.text) {
                  this.graphRenderer.renderTitle(this.paper, {
                    text: title.text,
                    offset: title.offset,
                    theme: this.theme.title,
                    rotationInfo: {
                      isVertical: this.isYAxis,
                      isPositionRight: this.data.isPositionRight,
                      isCenter: this.options.isCenter,
                      isColumnType: _predicate2["default"].isColumnTypeChart(this.dataProcessor.chartType, this.dataProcessor.seriesTypes),
                      isDiverging: seriesOption.diverging,
                      isYAxisCenter: yAxisOption && yAxisOption.align === "center",
                      isXAxisTitleLeft: xAxisOption && xAxisOption.title && xAxisOption.title.align === "left"
                    },
                    layout: this.layout,
                    areaSize: size,
                    additionalWidth,
                    otherSideDimension: this._getOtherSideDimension(),
                    tickCount: this.data.tickCount,
                    set: this.axisSet
                  });
                }
              };
              Axis2.prototype._renderTickLine = function _renderTickLine(areaSize, isNotDividedXAxis, additionalSize) {
                this.graphRenderer.renderTickLine({
                  areaSize,
                  additionalSize,
                  additionalWidth: this.paperAdditionalWidth,
                  additionalHeight: this.paperAdditionalHeight,
                  isPositionRight: this.data.isPositionRight,
                  isCenter: this.data.options.isCenter,
                  isNotDividedXAxis,
                  isVertical: this.isYAxis,
                  tickColor: this.theme.tickColor,
                  layout: this.layout,
                  paper: this.paper,
                  set: this.axisSet
                });
              };
              Axis2.prototype._renderTicks = function _renderTicks(size, tickCount, isNotDividedXAxis, additionalSize) {
                var tickColor = this.theme.tickColor;
                var _data3 = this.data, remainLastBlockInterval = _data3.remainLastBlockInterval, _data3$sizeRatio = _data3.sizeRatio, sizeRatio = _data3$sizeRatio === void 0 ? 1 : _data3$sizeRatio, dataTickCount = _data3.tickCount, isPositionRight = _data3.isPositionRight;
                var remainLastBlockIntervalPosition = remainLastBlockInterval ? size : 0;
                var isYAxis = this.isYAxis;
                var _data$options = this.data.options, isCenter = _data$options.isCenter, isDivided = _data$options.divided;
                var positions = _calculator2["default"].makeTickPixelPositions(size * sizeRatio, tickCount, 0, remainLastBlockIntervalPosition);
                var additionalHeight = this.paperAdditionalHeight + 1;
                var additionalWidth = this.paperAdditionalWidth;
                var positionLength = remainLastBlockIntervalPosition ? dataTickCount + 1 : dataTickCount;
                positions.length = positionLength;
                this.graphRenderer.renderTicks({
                  paper: this.paper,
                  layout: this.layout,
                  positions,
                  isVertical: isYAxis,
                  isCenter,
                  isDivided,
                  additionalSize,
                  additionalWidth,
                  additionalHeight,
                  otherSideDimension: this._getOtherSideDimension(),
                  isPositionRight,
                  tickColor,
                  set: this.axisSet
                });
              };
              Axis2.prototype._renderNegativeStandardsLine = function _renderNegativeStandardsLine(size, additionalSize, seriesDimension, axisLimit) {
                this.graphRenderer.renderStandardLine({
                  areaSize: size,
                  isVertical: this.isYAxis,
                  layout: this.layout,
                  paper: this.paper,
                  set: this.axisSet,
                  seriesDimension,
                  axisLimit
                });
              };
              Axis2.prototype._renderTickArea = function _renderTickArea(size, tickCount, additionalSize) {
                var isNotDividedXAxis = !this.isYAxis && !this.options.divided;
                this._renderTickLine(size, isNotDividedXAxis, additionalSize || 0);
                this._renderTicks(size, tickCount, isNotDividedXAxis, additionalSize || 0);
              };
              Axis2.prototype._renderLabelArea = function _renderLabelArea(size, tickCount, categories, additionalSize) {
                var _data4 = this.data, _data4$sizeRatio = _data4.sizeRatio, sizeRatio = _data4$sizeRatio === void 0 ? 1 : _data4$sizeRatio, remainLastBlockInterval = _data4.remainLastBlockInterval;
                var remainLastBlockIntervalPosition = remainLastBlockInterval ? size : 0;
                var tickPixelPositions = _calculator2["default"].makeTickPixelPositions(size * sizeRatio, tickCount, 0, remainLastBlockIntervalPosition);
                var labelDistance = tickPixelPositions[1] - tickPixelPositions[0];
                this._renderLabels(tickPixelPositions, categories, labelDistance, additionalSize || 0);
              };
              Axis2.prototype._renderRotationLabels = function _renderRotationLabels(positions, categories, labelSize, additionalSize) {
                var _this = this;
                var renderer = this.graphRenderer;
                var isYAxis = this.isYAxis;
                var theme = this.theme.label;
                var degree = this.data.degree;
                var halfWidth = labelSize / 2;
                var edgeAlignWidth = labelSize / AXIS_EDGE_RATIO;
                var _layout$position = this.layout.position, top = _layout$position.top, left = _layout$position.left;
                var horizontalTop = top + X_AXIS_LABEL_PADDING;
                var baseLeft = left;
                var labelMargin = this.options.labelMargin || 0;
                positions.forEach(function(position, index) {
                  var labelPosition = position + (additionalSize || 0);
                  var positionTopAndLeft = {};
                  if (isYAxis) {
                    positionTopAndLeft.top = labelPosition + halfWidth;
                    positionTopAndLeft.left = labelSize + labelMargin;
                  } else {
                    positionTopAndLeft.top = horizontalTop + labelMargin;
                    positionTopAndLeft.left = baseLeft + labelPosition + edgeAlignWidth;
                  }
                  renderer.renderRotatedLabel({
                    degree,
                    labelText: categories[index],
                    paper: _this.paper,
                    positionTopAndLeft,
                    set: _this.axisSet,
                    theme
                  });
                }, this);
              };
              Axis2.prototype._renderNormalLabels = function _renderNormalLabels(positions, categories, labelSize, additionalSize) {
                var _this2 = this;
                var renderer = this.graphRenderer;
                var isYAxis = this.isYAxis, isCategoryLabel = this.isLabelAxis, dataProcessor = this.dataProcessor, layout = this.layout;
                var isPositionRight = this.data.isPositionRight;
                var theme = this.theme.label;
                var _options2 = this.options, _options2$labelMargin = _options2.labelMargin, labelMargin = _options2$labelMargin === void 0 ? 0 : _options2$labelMargin, pointOnColumn = _options2.pointOnColumn, isCenter = _options2.isCenter, maxWidth = _options2.maxWidth;
                var isLineTypeChart = _predicate2["default"].isLineTypeChart(dataProcessor.chartType, dataProcessor.seriesTypes);
                var isPointOnColumn = isLineTypeChart && pointOnColumn;
                var isAutoTickInterval = _predicate2["default"].isAutoTickInterval(this.options.tickInterval);
                positions.forEach(function(position, index) {
                  var labelPosition = position + additionalSize;
                  var halfLabelDistance = labelSize / 2;
                  var isOverLapXAxisLabel = _this2._isOverLapXAxisLabel(categories[index], position, positions[index + 1]);
                  var positionTopAndLeft = {};
                  if (labelPosition < 0 || !isYAxis && isAutoTickInterval && isOverLapXAxisLabel) {
                    return;
                  }
                  if (isYAxis) {
                    positionTopAndLeft = _this2._getYAxisLabelPosition(layout, {
                      labelPosition,
                      isCategoryLabel,
                      halfLabelDistance,
                      isPositionRight
                    });
                  } else {
                    positionTopAndLeft = _this2._getXAxisLabelPosition(layout, {
                      labelMargin,
                      labelHeight: _renderUtil2["default"].getRenderedLabelsMaxHeight(categories, theme),
                      labelPosition,
                      isCategoryLabel,
                      isLineTypeChart,
                      isPointOnColumn,
                      halfLabelDistance
                    });
                  }
                  positionTopAndLeft.top = Math.round(positionTopAndLeft.top);
                  positionTopAndLeft.left = Math.round(positionTopAndLeft.left);
                  var labelText = categories[index];
                  if (maxWidth) {
                    labelText = _raphaelRenderUtil2["default"].getEllipsisText(categories[index], maxWidth, theme);
                  }
                  renderer.renderLabel({
                    isPositionRight,
                    isVertical: isYAxis,
                    isCenter,
                    labelSize,
                    labelText,
                    paper: _this2.paper,
                    positionTopAndLeft,
                    set: _this2.axisSet,
                    theme
                  });
                }, this);
              };
              Axis2.prototype._isOverLapXAxisLabel = function _isOverLapXAxisLabel(labelText, position, nextPosition) {
                var labelWidth = _renderUtil2["default"].getRenderedLabelWidth(labelText);
                return !(0, _isUndefined2["default"])(nextPosition) && nextPosition - position < labelWidth;
              };
              Axis2.prototype._getYAxisLabelPosition = function _getYAxisLabelPosition(layout, params) {
                var labelLeftPosition = void 0;
                var labelTopPosition = params.labelPosition;
                if (params.isCategoryLabel) {
                  labelTopPosition += params.halfLabelDistance + layout.position.top;
                } else {
                  labelTopPosition = layout.dimension.height + layout.position.top - labelTopPosition;
                }
                if (params.isPositionRight) {
                  labelLeftPosition = layout.position.left + layout.dimension.width;
                } else if (this.options.isCenter) {
                  labelLeftPosition = layout.position.left + layout.dimension.width / 2;
                } else {
                  labelLeftPosition = layout.position.left;
                }
                return {
                  top: labelTopPosition,
                  left: labelLeftPosition
                };
              };
              Axis2.prototype._getXAxisLabelPosition = function _getXAxisLabelPosition(layout, params) {
                var labelTopPosition = _calculator2["default"].sum([layout.position.top, X_AXIS_LABEL_PADDING, params.labelMargin, params.labelHeight / 2]);
                var labelLeftPosition = params.labelPosition + layout.position.left;
                if (params.isCategoryLabel) {
                  if (!params.isLineTypeChart || params.isPointOnColumn) {
                    labelLeftPosition += params.halfLabelDistance;
                  }
                }
                return {
                  top: labelTopPosition,
                  left: labelLeftPosition
                };
              };
              Axis2.prototype._renderLabels = function _renderLabels(positions, categories, labelSize, additionalSize) {
                var _options3 = this.options, rotateLabel = _options3.rotateLabel, prefix = _options3.prefix, suffix = _options3.suffix;
                var _data5 = this.data, degree = _data5.degree, multilineLabels = _data5.multilineLabels;
                var isRotationlessXAxis = !this.isYAxis && this.isLabelAxis && rotateLabel === false;
                var hasRotatedXAxisLabel = this.componentName === "xAxis" && degree;
                var axisLabels = void 0;
                if (isRotationlessXAxis) {
                  axisLabels = multilineLabels;
                } else {
                  axisLabels = categories;
                }
                if (axisLabels.length) {
                  positions.length = axisLabels.length;
                }
                axisLabels = _renderUtil2["default"].addPrefixSuffix(axisLabels, prefix, suffix);
                if (hasRotatedXAxisLabel) {
                  this._renderRotationLabels(positions, axisLabels, labelSize, additionalSize);
                } else {
                  this._renderNormalLabels(positions, axisLabels, labelSize, additionalSize);
                }
              };
              Axis2.prototype.animateForAddingData = function animateForAddingData(data) {
                if (!this.isYAxis) {
                  this.graphRenderer.animateForAddingData(data.tickSize);
                }
              };
              return Axis2;
            }();
            function axisFactory(axisParam) {
              var chartOptions = axisParam.chartOptions, name = axisParam.name, theme = axisParam.theme, seriesTypes = axisParam.seriesTypes;
              var chartType = chartOptions.chartType, series = chartOptions.series;
              axisParam.isYAxis = name === "yAxis" || name === "rightYAxis";
              axisParam.shifting = series.shifting;
              if (chartType === "combo") {
                if (axisParam.isYAxis) {
                  axisParam.theme = theme[seriesTypes[0]];
                } else if (name === "rightYAxis") {
                  axisParam.componentType = "yAxis";
                  axisParam.theme = theme[seriesTypes[1]];
                  axisParam.index = 1;
                }
              } else if (axisParam.isYAxis) {
                axisParam.theme = theme[chartType];
              } else {
                axisParam.theme = theme;
              }
              return new Axis(axisParam);
            }
            axisFactory.componentType = "axis";
            axisFactory.Axis = Axis;
          },
          /* 71 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            exports2["default"] = plotFactory;
            var _isArray = __webpack_require__(9);
            var _isArray2 = _interopRequireDefault(_isArray);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var Plot = function() {
              function Plot2(params) {
                _classCallCheck(this, Plot2);
                this.className = "tui-chart-plot-area";
                this.dataProcessor = params.dataProcessor;
                this.options = params.options || {};
                this.options.showLine = (0, _isUndefined2["default"])(this.options.showLine) ? true : this.options.showLine;
                this.options.lines = this.options.lines || [];
                this.options.bands = this.options.bands || [];
                this.xAxisTypeOption = params.xAxisTypeOption;
                this.theme = params.theme || {};
                this.chartType = params.chartType;
                this.chartTypes = params.chartTypes;
                this.layout = null;
                this.axisDataMap = null;
                this.drawingType = _const2["default"].COMPONENT_TYPE_RAPHAEL;
              }
              Plot2.prototype.presetForChangeData = function presetForChangeData() {
                var theme = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.theme;
                this.theme = theme;
              };
              Plot2.prototype._renderPlotArea = function _renderPlotArea(paper) {
                var dimension = this.layout.dimension;
                if (_predicate2["default"].isLineTypeChart(this.chartType, this.chartTypes)) {
                  this._renderOptionalLines(paper, dimension);
                }
                if (this.options.showLine) {
                  this._renderPlotLines(paper, dimension);
                }
              };
              Plot2.prototype._setDataForRendering = function _setDataForRendering(data) {
                if (data) {
                  this.layout = data.layout;
                  this.dimensionMap = data.dimensionMap;
                  this.axisDataMap = data.axisDataMap;
                  this.paper = data.paper;
                }
              };
              Plot2.prototype.render = function render(data) {
                var paper = data && data.paper || this.paper;
                this.plotSet = paper.set();
                this.additionalPlotSet = paper.set();
                this._setDataForRendering(data);
                this._renderPlotArea(this.paper);
                this.additionalPlotSet.toBack();
                this.plotSet.toBack();
                paper.pushDownBackgroundToBottom();
              };
              Plot2.prototype.rerender = function rerender(data) {
                this.additionalPlotSet.remove();
                this.plotSet.remove();
                this.render(data);
              };
              Plot2.prototype.resize = function resize(data) {
                this.rerender(data);
              };
              Plot2.prototype.zoom = function zoom(data) {
                this.rerender(data);
              };
              Plot2.prototype._makeVerticalLineTemplateParams = function _makeVerticalLineTemplateParams(additionalParams) {
                return Object.assign({
                  className: "vertical",
                  positionType: "left",
                  width: "1px"
                }, additionalParams);
              };
              Plot2.prototype._makeHorizontalLineTemplateParams = function _makeHorizontalLineTemplateParams(additionalParams) {
                return Object.assign({
                  className: "horizontal",
                  positionType: "bottom",
                  height: "1px"
                }, additionalParams);
              };
              Plot2.prototype._renderLine = function _renderLine(offsetPosition, attributes) {
                var _layout = this.layout, top = _layout.position.top, height = _layout.dimension.height;
                var pathString = "M" + offsetPosition + "," + top + "V" + (top + height);
                var path = this.paper.path(pathString);
                path.attr({
                  opacity: attributes.opacity || 1,
                  stroke: attributes.color
                });
                this.additionalPlotSet.push(path);
                return path;
              };
              Plot2.prototype._renderBand = function _renderBand(offsetPosition, plotWidth, attributes) {
                var _layout2 = this.layout, position = _layout2.position, dimension = _layout2.dimension;
                var remainingWidth = dimension.width - offsetPosition + position.left;
                var bandWidth = plotWidth < 0 ? remainingWidth : plotWidth;
                var rect = this.paper.rect(offsetPosition, position.top, bandWidth, dimension.height);
                rect.attr({
                  fill: attributes.color,
                  opacity: attributes.opacity || 1,
                  stroke: attributes.color
                });
                this.additionalPlotSet.push(rect);
                return rect;
              };
              Plot2.prototype._createOptionalLineValueRange = function _createOptionalLineValueRange(optionalLineData) {
                var range = optionalLineData.range || [optionalLineData.value];
                if (_predicate2["default"].isDatetimeType(this.xAxisTypeOption)) {
                  range = range.map(function(value) {
                    var date = new Date(value);
                    return date.getTime() || value;
                  });
                }
                return range;
              };
              Plot2.prototype._createOptionalLinePosition = function _createOptionalLinePosition(_ref, width, value) {
                var dataMin = _ref.dataMin, distance = _ref.distance;
                var ratio = (value - dataMin) / distance;
                var position = ratio * width;
                if (ratio === 1) {
                  position -= 1;
                }
                if (position < 0) {
                  position = null;
                }
                return position;
              };
              Plot2.prototype._calculateXAxisLabelDistance = function _calculateXAxisLabelDistance(width, xAxisData) {
                var _xAxisData$sizeRatio = xAxisData.sizeRatio, sizeRatio = _xAxisData$sizeRatio === void 0 ? 1 : _xAxisData$sizeRatio, tickCount = xAxisData.tickCount, remainLastBlockInterval = xAxisData.remainLastBlockInterval;
                var remainLastBlockIntervalPosition = remainLastBlockInterval ? width : 0;
                var tickPixelPositions = _calculator2["default"].makeTickPixelPositions(width * sizeRatio, tickCount, 0, remainLastBlockIntervalPosition);
                return tickPixelPositions[1] - tickPixelPositions[0];
              };
              Plot2.prototype._createOptionalLinePositionWhenLabelAxis = function _createOptionalLinePositionWhenLabelAxis(width, xAxisData, value) {
                var dataProcessor = this.dataProcessor;
                var isLineTypeChart = _predicate2["default"].isLineTypeChart(dataProcessor.chartType, dataProcessor.seriesTypes);
                var isPointOnColumn = isLineTypeChart && xAxisData.options.pointOnColumn;
                var index = dataProcessor.findCategoryIndex(value);
                var halfLabelDistance = this._calculateXAxisLabelDistance(width, xAxisData) / 2;
                var position = null;
                var ratio = void 0;
                if (!(0, _isNull2["default"])(index)) {
                  var categoryCount = dataProcessor.getCategoryCount();
                  var divCount = isPointOnColumn ? categoryCount : categoryCount - 1;
                  ratio = index === 0 ? 0 : index / divCount;
                  position = ratio * width;
                  if (isPointOnColumn) {
                    position += halfLabelDistance;
                  }
                }
                if (ratio === 1) {
                  position -= 1;
                }
                return position;
              };
              Plot2.prototype._createOptionalLinePositionMap = function _createOptionalLinePositionMap(optionalLineData, xAxisData, width) {
                var categories = this.dataProcessor.getCategories();
                var categoriesLen = categories.length;
                var xAxisValues = this.dataProcessor.valuesMap.linex;
                var range = this._createOptionalLineValueRange(optionalLineData);
                var startPosition = void 0, endPosition = void 0;
                if (xAxisData.isLabelAxis) {
                  startPosition = this._createOptionalLinePositionWhenLabelAxis(width, xAxisData, range[0]);
                  endPosition = this._createOptionalLinePositionWhenLabelAxis(width, xAxisData, range[1]);
                } else {
                  startPosition = this._createOptionalLinePosition(xAxisData, width, range[0]);
                  endPosition = range[1] && this._createOptionalLinePosition(xAxisData, width, range[1]);
                }
                if ((0, _isNull2["default"])(startPosition)) {
                  var startValue = categoriesLen ? categories[0] : xAxisValues[0];
                  startPosition = this._isBeforeVisibleValue(range[0], startValue) ? 0 : -1;
                }
                if ((0, _isNull2["default"])(endPosition) || endPosition > width) {
                  var endValue = categoriesLen ? categories[categoriesLen - 1] : xAxisValues[xAxisValues.length - 1];
                  endPosition = this._isAfterVisibleValue(range[1], endValue) ? width : -1;
                }
                return {
                  start: startPosition,
                  end: endPosition
                };
              };
              Plot2.prototype._isBeforeVisibleValue = function _isBeforeVisibleValue(value, firstValue) {
                var dataProcessor = this.dataProcessor;
                if (!(0, _isExisty2["default"])(value)) {
                  return false;
                }
                if (_predicate2["default"].isDatetimeType(this.xAxisTypeOption)) {
                  return value < firstValue;
                }
                var valueIndex = dataProcessor.findAbsoluteCategoryIndex(value);
                var firstValueIndex = dataProcessor.findAbsoluteCategoryIndex(firstValue);
                return valueIndex >= 0 && valueIndex < firstValueIndex;
              };
              Plot2.prototype._isAfterVisibleValue = function _isAfterVisibleValue(value, lastValue) {
                var dataProcessor = this.dataProcessor;
                if (!(0, _isExisty2["default"])(value)) {
                  return false;
                }
                if (_predicate2["default"].isDatetimeType(this.xAxisTypeOption)) {
                  return value > lastValue;
                }
                var valueIndex = dataProcessor.findAbsoluteCategoryIndex(value);
                var lastValueIndex = dataProcessor.findAbsoluteCategoryIndex(lastValue);
                return valueIndex >= 0 && valueIndex > lastValueIndex;
              };
              Plot2.prototype._renderOptionalLine = function _renderOptionalLine(xAxisData, width, attributes, optionalLineData) {
                var positionMap = this._createOptionalLinePositionMap(optionalLineData, xAxisData, width);
                var line = void 0;
                if (positionMap.start >= 0 && positionMap.start <= width) {
                  attributes.width = 1;
                  attributes.color = optionalLineData.color || "transparent";
                  attributes.opacity = optionalLineData.opacity;
                  line = this._renderLine(positionMap.start + this.layout.position.left, attributes);
                }
                return line;
              };
              Plot2.prototype._makeOptionalBand = function _makeOptionalBand(xAxisData, width, attributes, optionalLineData) {
                var _this = this;
                var range = optionalLineData.range;
                if (range && range.length) {
                  this._makeRangeTo2DArray(optionalLineData);
                }
                var positionMaps = optionalLineData.range.map(function(rangeItem) {
                  return _this._createOptionalLinePositionMap({
                    range: rangeItem
                  }, xAxisData, width);
                });
                if (optionalLineData.mergeOverlappingRanges) {
                  positionMaps.sort(compareByStartPosition);
                  positionMaps = this._mergeOverlappingPositionMaps(positionMaps);
                }
                return positionMaps.map(function(positionMap) {
                  var isStartPositionInsidePlotArea = positionMap.start >= 0 && positionMap.start <= width;
                  var band = void 0;
                  if (isStartPositionInsidePlotArea && positionMap.end >= 0) {
                    attributes.color = optionalLineData.color || "transparent";
                    attributes.opacity = optionalLineData.opacity;
                    var bandWidth = positionMap.end - positionMap.start;
                    band = _this._renderBand(positionMap.start + _this.layout.position.left, bandWidth, attributes);
                  }
                  return band;
                }, this);
              };
              Plot2.prototype._makeOptionalLines = function _makeOptionalLines(lines, _ref2) {
                var width = _ref2.width, height = _ref2.height;
                var xAxisData = this.axisDataMap.xAxis;
                var templateParams = this._makeVerticalLineTemplateParams({
                  height: height + "px"
                });
                var makeOptionalLineHtml = this._renderOptionalLine.bind(this, xAxisData, width, templateParams);
                return lines.map(makeOptionalLineHtml);
              };
              Plot2.prototype._makeOptionalBands = function _makeOptionalBands(lines, _ref3) {
                var width = _ref3.width, height = _ref3.height;
                var xAxisData = this.axisDataMap.xAxis;
                var templateParams = this._makeVerticalLineTemplateParams({
                  height: height + "px"
                });
                var makeOptionalLineHtml = this._makeOptionalBand.bind(this, xAxisData, width, templateParams);
                return lines.map(makeOptionalLineHtml);
              };
              Plot2.prototype._renderOptionalLines = function _renderOptionalLines(paper, dimension) {
                this.optionalBands = this._makeOptionalBands(this.options.bands, dimension);
                this.optionalLines = this._makeOptionalLines(this.options.lines, dimension);
              };
              Plot2.prototype._renderVerticalLines = function _renderVerticalLines(_ref4) {
                var _this2 = this;
                var width = _ref4.width;
                var positions = this._makeHorizontalPositions(width);
                var layout = this.layout, lineColor = this.theme.lineColor;
                var _layout$position = layout.position, top = _layout$position.top, left = _layout$position.left;
                positions.forEach(function(position) {
                  var pathString = "M" + (position + left) + "," + top + "V" + (top + layout.dimension.height);
                  var path = _this2.paper.path(pathString);
                  path.attr({
                    stroke: lineColor,
                    "stroke-width": 1,
                    "stroke-opacity": 0.05
                  });
                  _this2.plotSet.push(path);
                });
              };
              Plot2.prototype._renderHorizontalLines = function _renderHorizontalLines(_ref5) {
                var _this3 = this;
                var height = _ref5.height;
                var positions = this._makeVerticalPositions(height);
                var layout = this.layout, lineColor = this.theme.lineColor;
                var _layout$position2 = layout.position, left = _layout$position2.left, top = _layout$position2.top;
                var distance = positions.length > 1 ? positions[1] - positions[0] : 0;
                positions.forEach(function(position, index) {
                  var pathString = "M" + left + "," + (distance * index + top) + "H" + (left + layout.dimension.width);
                  var path = _this3.paper.path(pathString);
                  path.attr({
                    stroke: lineColor,
                    "stroke-width": 1,
                    "stroke-opacity": 0.05
                  });
                  _this3.plotSet.push(path);
                });
              };
              Plot2.prototype._renderPlotLines = function _renderPlotLines(container, dimension) {
                if (!this.options.hideLine) {
                  this._renderVerticalLines(dimension);
                  this._renderHorizontalLines(dimension);
                }
              };
              Plot2.prototype._makeVerticalPositions = function _makeVerticalPositions(height) {
                var axisDataMap = this.axisDataMap;
                var yAxis = axisDataMap.yAxis || axisDataMap.rightYAxis;
                var positions = _calculator2["default"].makeTickPixelPositions(height, yAxis.validTickCount);
                positions.shift();
                return positions;
              };
              Plot2.prototype._makeDividedPlotPositions = function _makeDividedPlotPositions(width, tickCount) {
                var yAxisWidth = this.dimensionMap.yAxis.width;
                tickCount = parseInt(tickCount / 2, 10) + 1;
                width -= yAxisWidth;
                var leftWidth = Math.round(width / 2);
                var rightWidth = width - leftWidth;
                var leftPositions = _calculator2["default"].makeTickPixelPositions(leftWidth, tickCount);
                var rightPositions = _calculator2["default"].makeTickPixelPositions(rightWidth, tickCount, leftWidth + yAxisWidth);
                leftPositions.pop();
                rightPositions.shift();
                return leftPositions.concat(rightPositions);
              };
              Plot2.prototype._makeHorizontalPositions = function _makeHorizontalPositions(width) {
                var tickCount = this.axisDataMap.xAxis.validTickCount;
                var positions = void 0;
                if (this.options.divided) {
                  positions = this._makeDividedPlotPositions(width, tickCount);
                } else {
                  positions = _calculator2["default"].makeTickPixelPositions(width, tickCount);
                  positions.shift();
                }
                return positions;
              };
              Plot2.prototype.addPlotLine = function addPlotLine(data) {
                this.options.lines.push(data);
                this.rerender();
              };
              Plot2.prototype.addPlotBand = function addPlotBand(data) {
                this.options.bands.push(data);
                this.rerender();
              };
              Plot2.prototype.removePlotLine = function removePlotLine(id) {
                this.options.lines = this.options.lines.filter(function(line) {
                  return line.id !== id;
                });
                this.rerender();
              };
              Plot2.prototype.removePlotBand = function removePlotBand(id) {
                this.options.bands = this.options.bands.filter(function(band) {
                  return band.id !== id;
                });
                this.rerender();
              };
              Plot2.prototype.animateForAddingData = function animateForAddingData(data) {
                var _this4 = this;
                var optionLines = this.options.lines;
                var optionBands = this.options.bands;
                if (!this.dataProcessor.isCoordinateType()) {
                  if (data.shifting) {
                    this._animateItemForAddingData(this.optionalLines, data, function(itemIdx) {
                      optionLines.splice(itemIdx, 1);
                    });
                    this.optionalBands.forEach(function(bandRanges, bandIdx) {
                      _this4._animateItemForAddingData(bandRanges, data, function(itemIdx) {
                        optionBands[bandIdx].range.splice(itemIdx, 1);
                      });
                    });
                  }
                }
              };
              Plot2.prototype._animateItemForAddingData = function _animateItemForAddingData(optionalItems, data, removePlotItem) {
                var _this5 = this;
                optionalItems.forEach(function(item, lineIdx) {
                  var bbox = item.getBBox();
                  if (bbox.x - data.tickSize < _this5.layout.position.left) {
                    item.animate({
                      transform: "T-" + data.tickSize + ",0",
                      opacity: 0
                    }, 300, "linear", function() {
                      removePlotItem(lineIdx);
                      item.remove();
                    });
                  } else {
                    item.animate({
                      transform: "T-" + data.tickSize + ",0"
                    }, 300);
                  }
                });
              };
              Plot2.prototype._makeRangeTo2DArray = function _makeRangeTo2DArray(optionalLineData) {
                var range = optionalLineData.range;
                var isOneDimensionArray = range && (0, _isArray2["default"])(range) && (range.length === 0 || !(0, _isArray2["default"])(range[0]));
                if (isOneDimensionArray) {
                  optionalLineData.range = [range];
                }
              };
              Plot2.prototype._mergeOverlappingPositionMaps = function _mergeOverlappingPositionMaps(positionMaps) {
                var len = positionMaps.length;
                var processedMap = void 0, previous = void 0;
                if (len) {
                  processedMap = [positionMaps[0]];
                  var _processedMap = processedMap;
                  var _processedMap2 = _slicedToArray(_processedMap, 1);
                  previous = _processedMap2[0];
                }
                for (var i = 1; i < len; i += 1) {
                  var current = positionMaps[i];
                  if (current.start <= previous.end) {
                    previous.end = Math.max(current.end, previous.end);
                  } else {
                    processedMap.push(current);
                    previous = current;
                  }
                }
                return processedMap;
              };
              return Plot2;
            }();
            function compareByStartPosition(previous, current) {
              return previous.start - current.start;
            }
            function plotFactory(param) {
              var seriesTypes = param.seriesTypes, _param$chartOptions = param.chartOptions, chartType = _param$chartOptions.chartType, xAxisType = _param$chartOptions.xAxis.type;
              param.chartType = chartType;
              param.chartTypes = seriesTypes;
              param.xAxisTypeOption = xAxisType;
              return new Plot(param);
            }
            plotFactory.componentType = "plot";
            plotFactory.Plot = Plot;
          },
          /* 72 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = titleFactory;
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _pluginFactory = __webpack_require__(51);
            var _pluginFactory2 = _interopRequireDefault(_pluginFactory);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var Title = function() {
              function Title2(params) {
                _classCallCheck(this, Title2);
                this.theme = params.theme || {};
                this.titleText = params.text;
                this.offset = params.offset;
                this.align = params.align;
                this.graphRenderer = _pluginFactory2["default"].get(_const2["default"].COMPONENT_TYPE_RAPHAEL, "title");
                this.drawingType = _const2["default"].COMPONENT_TYPE_RAPHAEL;
              }
              Title2.prototype.render = function render(data) {
                this.titleSet = this._renderTitleArea(data);
              };
              Title2.prototype.resize = function resize(data) {
                var dimensionMap = data.dimensionMap;
                var legendWidth = dimensionMap.legend ? dimensionMap.legend.width : 0;
                var width = dimensionMap.series.width + legendWidth;
                this.graphRenderer.resize(width, this.titleSet);
              };
              Title2.prototype.rerender = function rerender(data) {
                this.titleSet.remove();
                this.render(data);
              };
              Title2.prototype._renderTitleArea = function _renderTitleArea(data) {
                var paper = data.paper, dimensionMap = data.dimensionMap;
                var chartTitleAreaWidth = this._calculateForTitleAreaWidth(dimensionMap);
                return this.graphRenderer.render({
                  paper,
                  titleText: this.titleText,
                  offset: this.offset,
                  theme: this.theme,
                  align: this.align,
                  chartTitleAreaWidth
                });
              };
              Title2.prototype._calculateForTitleAreaWidth = function _calculateForTitleAreaWidth(_ref) {
                var chartExportMenu = _ref.chartExportMenu, chart = _ref.chart;
                var exportMenuWidth = chartExportMenu ? chartExportMenu.width * 2 : 0;
                return chart.width - exportMenuWidth;
              };
              return Title2;
            }();
            function titleFactory(param) {
              var options = param.chartOptions.chart || {
                title: {}
              };
              var title = null;
              if (options.title && options.title.text) {
                param.text = options.title.text;
                param.offset = options.title.offset;
                param.align = options.title.align;
                title = new Title(param);
              }
              return title;
            }
            titleFactory.componentType = "title";
            titleFactory.Title = Title;
          },
          /* 73 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = RadialPlotFactory;
            var _geometric = __webpack_require__(74);
            var _geometric2 = _interopRequireDefault(_geometric);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _pluginFactory = __webpack_require__(51);
            var _pluginFactory2 = _interopRequireDefault(_pluginFactory);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var COMPONENT_TYPE_RAPHAEL = _const2["default"].COMPONENT_TYPE_RAPHAEL, RADIAL_PLOT_PADDING = _const2["default"].RADIAL_PLOT_PADDING, RADIAL_MARGIN_FOR_CATEGORY = _const2["default"].RADIAL_MARGIN_FOR_CATEGORY, RADIAL_CATEGORY_PADDING = _const2["default"].RADIAL_CATEGORY_PADDING;
            var RadialPlot = function() {
              function RadialPlot2(params) {
                _classCallCheck(this, RadialPlot2);
                this.className = "tui-chart-plot-area";
                this.options = Object.assign({
                  type: "spiderweb"
                }, params.options);
                this.theme = params.theme || {};
                this.graphRenderer = _pluginFactory2["default"].get(COMPONENT_TYPE_RAPHAEL, "radialPlot");
                this.drawingType = COMPONENT_TYPE_RAPHAEL;
              }
              RadialPlot2.prototype._renderPlotArea = function _renderPlotArea(paper, layout, plotPositions, labelData) {
                var renderParams = {
                  paper,
                  layout,
                  plotPositions,
                  labelData,
                  theme: this.theme,
                  options: this.options
                };
                return this.graphRenderer.render(renderParams);
              };
              RadialPlot2.prototype._makePositions = function _makePositions(axisDataMap, layout) {
                var dimension = layout.dimension, _layout$position = layout.position, left = _layout$position.left, top = _layout$position.top;
                var width = dimension.width, height = dimension.height;
                width = width - RADIAL_PLOT_PADDING - RADIAL_MARGIN_FOR_CATEGORY;
                height = height - RADIAL_PLOT_PADDING - RADIAL_MARGIN_FOR_CATEGORY;
                var centerX = _calculator2["default"].sum([width / 2, RADIAL_PLOT_PADDING / 2, RADIAL_MARGIN_FOR_CATEGORY / 2, left]);
                var centerY = height / 2 - RADIAL_PLOT_PADDING / 2 - RADIAL_MARGIN_FOR_CATEGORY / 2 - top;
                var stepCount = axisDataMap.yAxis.tickCount;
                var angleStepCount = axisDataMap.xAxis.labels.length;
                return makeSpiderWebPositions({
                  width,
                  height,
                  centerX,
                  centerY,
                  angleStepCount,
                  stepCount
                });
              };
              RadialPlot2.prototype._makeCategoryPositions = function _makeCategoryPositions(axisDataMap, layout) {
                var dimension = layout.dimension, _layout$position2 = layout.position, left = _layout$position2.left, top = _layout$position2.top;
                var width = dimension.width, height = dimension.height;
                width = width - RADIAL_PLOT_PADDING - RADIAL_CATEGORY_PADDING;
                height = height - RADIAL_PLOT_PADDING - RADIAL_CATEGORY_PADDING;
                var centerX = _calculator2["default"].sum([width / 2, RADIAL_PLOT_PADDING / 2, RADIAL_CATEGORY_PADDING / 2, left]);
                var centerY = height / 2 - RADIAL_PLOT_PADDING / 2 - RADIAL_CATEGORY_PADDING / 2 - top;
                var angleStepCount = axisDataMap.xAxis.labels.length;
                return makeRadialCategoryPositions({
                  width,
                  height,
                  centerX,
                  centerY,
                  angleStepCount
                });
              };
              RadialPlot2.prototype._makeLabelData = function _makeLabelData(axisDataMap, dimension, plotPositions) {
                var categories = axisDataMap.xAxis.labels;
                var stepLabels = axisDataMap.yAxis.labels;
                var categoryPositions = this._makeCategoryPositions(axisDataMap, dimension);
                var categoryLabelData = [];
                var stepLabelData = [];
                for (var i = 0; i < categories.length; i += 1) {
                  categoryLabelData.push({
                    text: categories[i],
                    position: categoryPositions[i]
                  });
                }
                for (var j = 0; j < stepLabels.length - 1; j += 1) {
                  stepLabelData.push({
                    text: stepLabels[j],
                    position: plotPositions[j][0]
                  });
                }
                return {
                  category: categoryLabelData,
                  step: stepLabelData
                };
              };
              RadialPlot2.prototype.render = function render(_ref) {
                var axisDataMap = _ref.axisDataMap, layout = _ref.layout, paper = _ref.paper;
                var plotPositions = this._makePositions(axisDataMap, layout);
                var labelData = this._makeLabelData(axisDataMap, layout, plotPositions);
                this.plotSet = this._renderPlotArea(paper, layout, plotPositions, labelData);
              };
              RadialPlot2.prototype.rerender = function rerender(data) {
                this.plotSet.remove();
                this.render(data);
              };
              RadialPlot2.prototype.resize = function resize(data) {
                this.rerender(data);
              };
              return RadialPlot2;
            }();
            function makeSpiderWebPositions(params) {
              var width = params.width, height = params.height, centerX = params.centerX, centerY = params.centerY, angleStepCount = params.angleStepCount, stepCount = params.stepCount;
              var radius = Math.min(width, height) / 2;
              var angleStep = 360 / angleStepCount;
              var points = [];
              var stepPixel = radius / (stepCount - 1);
              for (var i = 0; i < stepCount; i += 1) {
                var stepPoints = [];
                var pointY = centerY + stepPixel * i;
                for (var j = 0; j < angleStepCount; j += 1) {
                  var point = _geometric2["default"].rotatePointAroundOrigin(centerX, centerY, centerX, pointY, angleStep * j);
                  stepPoints.push({
                    left: point.x,
                    top: height - point.y
                    // convert y to top
                  });
                }
                stepPoints.push(stepPoints[0]);
                points[i] = stepPoints;
              }
              return points;
            }
            function makeRadialCategoryPositions(params) {
              var width = params.width, height = params.height, centerX = params.centerX, centerY = params.centerY, angleStepCount = params.angleStepCount;
              var radius = Math.min(height, width) / 2;
              var angleStep = 360 / angleStepCount;
              var points = [];
              var pointY = centerY + radius;
              for (var i = 0; i < angleStepCount; i += 1) {
                var reversedAngle = 360 - angleStep * i;
                var point = _geometric2["default"].rotatePointAroundOrigin(centerX, centerY, centerX, pointY, reversedAngle);
                var anchor = void 0;
                if (reversedAngle > 0 && reversedAngle < 180) {
                  anchor = "end";
                } else if (reversedAngle > 180 && reversedAngle < 360) {
                  anchor = "start";
                } else {
                  anchor = "middle";
                }
                points.push({
                  left: point.x,
                  top: height - point.y,
                  // convert y to top
                  anchor
                });
              }
              return points;
            }
            function RadialPlotFactory(param) {
              return new RadialPlot(param);
            }
            RadialPlotFactory.componentType = "plot";
            RadialPlotFactory.RadialPlot = RadialPlot;
          },
          /* 74 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function rotatePointAroundOrigin(centerX, centerY, pointX, pointY, angle) {
              var rad = angle * (Math.PI / 180);
              var newX = (pointX - centerX) * Math.cos(rad) - (pointY - centerY) * Math.sin(rad);
              var newY = (pointX - centerX) * Math.sin(rad) + (pointY - centerY) * Math.cos(rad);
              newX += centerX;
              newY += centerY;
              return {
                x: newX,
                y: newY
              };
            }
            function calculateAdjacent(degree, hypotenuse) {
              return Math.cos(degree * _const2["default"].RAD) * hypotenuse;
            }
            function calculateOpposite(degree, hypotenuse) {
              return Math.sin(degree * _const2["default"].RAD) * hypotenuse;
            }
            function calculateRotatedWidth(degree, width, height) {
              var centerHalf = calculateAdjacent(degree, width / 2);
              var sideHalf = calculateAdjacent(_const2["default"].ANGLE_90 - degree, height / 2);
              return (centerHalf + sideHalf) * 2;
            }
            function calculateRotatedHeight(degree, width, height) {
              var centerHalf = calculateOpposite(degree, width / 2);
              var sideHalf = calculateOpposite(_const2["default"].ANGLE_90 - degree, height / 2);
              return (centerHalf + sideHalf) * 2;
            }
            exports2["default"] = {
              rotatePointAroundOrigin,
              calculateAdjacent,
              calculateRotatedHeight,
              calculateRotatedWidth,
              calculateOpposite
            };
          },
          /* 75 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = chartExportMenuFactory;
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _chartExporter = __webpack_require__(76);
            var _chartExporter2 = _interopRequireDefault(_chartExporter);
            var _domHandler = __webpack_require__(24);
            var _domHandler2 = _interopRequireDefault(_domHandler);
            var _eventListener = __webpack_require__(80);
            var _eventListener2 = _interopRequireDefault(_eventListener);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var CHART_EXPORT_MENU_ITEMS = ["xls", "csv", "png", "jpeg"];
            var CLASS_NAME_CHART_EXPORT_MENU_OPENED = "menu-opened";
            var CLASS_NAME_CHART_EXPORT_MENU_BUTTON = _const2["default"].CLASS_NAME_CHART_EXPORT_MENU_BUTTON, CLASS_NAME_CHART_EXPORT_MENU = _const2["default"].CLASS_NAME_CHART_EXPORT_MENU, CLASS_NAME_CHART_EXPORT_MENU_HEAD = _const2["default"].CLASS_NAME_CHART_EXPORT_MENU_HEAD, CLASS_NAME_CHART_EXPORT_MENU_BODY = _const2["default"].CLASS_NAME_CHART_EXPORT_MENU_BODY, CLASS_NAME_CHART_EXPORT_MENU_ITEM = _const2["default"].CLASS_NAME_CHART_EXPORT_MENU_ITEM, COMPONENT_TYPE_DOM = _const2["default"].COMPONENT_TYPE_DOM;
            var ChartExportMenu = function() {
              function ChartExportMenu2(params) {
                _classCallCheck(this, ChartExportMenu2);
                this.className = "tui-chart-chartExportMenu-area";
                this.dataProcessor = params.dataProcessor;
                this.chartTitle = params.chartTitle || "tui-chart";
                this.exportFilename = params.exportFilename || this.chartTitle;
                this.chartType = params.chartType;
                this.layout = null;
                this.chartExportMenuContainer = null;
                this.chartExportMenu = null;
                this.options = params.options;
                this.eventBus = params.eventBus;
                this.drawingType = COMPONENT_TYPE_DOM;
                this.theme = params.theme || null;
              }
              ChartExportMenu2.prototype._createChartExportMenuButton = function _createChartExportMenuButton() {
                var menuButton = _domHandler2["default"].create("div", CLASS_NAME_CHART_EXPORT_MENU_BUTTON);
                if (this.options.buttonClass) {
                  _domHandler2["default"].addClass(menuButton, this.options.buttonClass);
                }
                return menuButton;
              };
              ChartExportMenu2.prototype._renderChartExportMenuArea = function _renderChartExportMenuArea(chartExportMenuContainer) {
                var menuButton = this._createChartExportMenuButton();
                var dimension = this.layout.dimension;
                chartExportMenuContainer.appendChild(menuButton);
                _renderUtil2["default"].renderDimension(chartExportMenuContainer, dimension);
                _renderUtil2["default"].renderPosition(chartExportMenuContainer, this.layout.position);
              };
              ChartExportMenu2.prototype._renderChartExportMenu = function _renderChartExportMenu(chartExportMenuContainer) {
                var seriesDataModelMap = this.dataProcessor.seriesDataModelMap;
                var isDataDownloadAvailable = this.isDataDownloadAvailable(seriesDataModelMap);
                var isDownloadSupported = _chartExporter2["default"].isDownloadSupported, isImageExtension = _chartExporter2["default"].isImageExtension, isImageDownloadAvailable = _chartExporter2["default"].isImageDownloadAvailable;
                var menuElement = _domHandler2["default"].create("ul", CLASS_NAME_CHART_EXPORT_MENU);
                var menuHead = _domHandler2["default"].create("li", CLASS_NAME_CHART_EXPORT_MENU_HEAD);
                var menuBody = _domHandler2["default"].create("li", CLASS_NAME_CHART_EXPORT_MENU_BODY);
                var menuStyle = menuElement.style;
                var _theme = this.theme, borderWidth = _theme.borderWidth, borderRadius = _theme.borderRadius, backgroundColor = _theme.backgroundColor, color = _theme.color;
                var menuItems = [];
                if (isDownloadSupported && (isDataDownloadAvailable || isImageDownloadAvailable)) {
                  menuItems = CHART_EXPORT_MENU_ITEMS.map(function(exportItemType) {
                    var itemElement = void 0;
                    if (!isImageExtension(exportItemType) && isDataDownloadAvailable || isImageExtension(exportItemType) && isImageDownloadAvailable) {
                      itemElement = _domHandler2["default"].create("li", CLASS_NAME_CHART_EXPORT_MENU_ITEM);
                      itemElement.id = exportItemType;
                      itemElement.innerHTML = exportItemType;
                    }
                    return itemElement;
                  });
                } else {
                  menuStyle.width = "200px";
                  menuItems[0] = _domHandler2["default"].create("li", CLASS_NAME_CHART_EXPORT_MENU_ITEM);
                  menuItems[0].innerHTML = "Browser does not support client-side download.";
                }
                if (this.theme) {
                  if (borderWidth) {
                    menuStyle.borderWidth = borderWidth;
                  }
                  if (borderRadius) {
                    menuStyle.borderRadius = borderRadius;
                  }
                  if (backgroundColor) {
                    menuStyle.backgroundColor = backgroundColor;
                  }
                  if (color) {
                    menuStyle.color = color;
                  }
                }
                if (this.options.menuClass) {
                  _domHandler2["default"].addClass(menuElement, this.options.menuClass);
                }
                menuHead.innerHTML = "Export to";
                _domHandler2["default"].append(menuBody, menuItems);
                _domHandler2["default"].append(menuElement, menuHead);
                _domHandler2["default"].append(menuElement, menuBody);
                this.chartExportMenu = menuElement;
                _domHandler2["default"].append(chartExportMenuContainer, menuElement);
              };
              ChartExportMenu2.prototype._setDataForRendering = function _setDataForRendering(data) {
                if (data) {
                  this.layout = data.layout;
                  this.dimensionMap = data.dimensionMap;
                  this.axisDataMap = data.axisDataMap;
                }
              };
              ChartExportMenu2.prototype.render = function render(data) {
                var container = null;
                if (_chartExporter2["default"].isDownloadSupported) {
                  container = this.container = data.paper;
                  _domHandler2["default"].addClass(container, this.className);
                  this._setDataForRendering(data);
                  this._renderChartExportMenuArea(container);
                  this._renderChartExportMenu(container);
                  this.chartExportMenuContainer = container;
                  this._attachEvent();
                }
                return container;
              };
              ChartExportMenu2.prototype.rerender = function rerender() {
                this._hideChartExportMenu();
              };
              ChartExportMenu2.prototype.resize = function resize() {
              };
              ChartExportMenu2.prototype._showChartExportMenu = function _showChartExportMenu() {
                _domHandler2["default"].addClass(this.chartExportMenuContainer, CLASS_NAME_CHART_EXPORT_MENU_OPENED);
                this.chartExportMenu.style.display = "block";
              };
              ChartExportMenu2.prototype._hideChartExportMenu = function _hideChartExportMenu() {
                if (this.chartExportMenuContainer) {
                  _domHandler2["default"].removeClass(this.chartExportMenuContainer, CLASS_NAME_CHART_EXPORT_MENU_OPENED);
                  this.chartExportMenu.style.display = "none";
                }
              };
              ChartExportMenu2.prototype._onClick = function _onClick(e) {
                var elTarget = e.target || e.srcElement;
                if (_domHandler2["default"].hasClass(elTarget, CLASS_NAME_CHART_EXPORT_MENU_ITEM)) {
                  if (elTarget.id) {
                    var svgElement = this._getMainSvgElemenmt(this.container.parentNode);
                    this.eventBus.fire("beforeImageDownload");
                    _chartExporter2["default"].exportChart(this.exportFilename, elTarget.id, this.dataProcessor.rawData, svgElement, this.options);
                    this.eventBus.fire("afterImageDownload");
                  }
                  this._hideChartExportMenu();
                } else if (_domHandler2["default"].hasClass(elTarget, CLASS_NAME_CHART_EXPORT_MENU_BUTTON) && this.chartExportMenuContainer === elTarget.parentNode && !_domHandler2["default"].hasClass(this.chartExportMenuContainer, CLASS_NAME_CHART_EXPORT_MENU_OPENED)) {
                  this._showChartExportMenu();
                } else {
                  this._hideChartExportMenu();
                }
              };
              ChartExportMenu2.prototype._getMainSvgElemenmt = function _getMainSvgElemenmt(mainContainer) {
                var svgElements = Array.from(mainContainer.getElementsByTagName("svg"));
                var svgElement = void 0;
                svgElements.forEach(function(svg) {
                  if (mainContainer === svg.parentNode) {
                    svgElement = svg;
                  }
                });
                return svgElement;
              };
              ChartExportMenu2.prototype.isDataDownloadAvailable = function isDataDownloadAvailable(seriesDataModels) {
                var result = true;
                if (_predicate2["default"].isTreemapChart(this.chartType)) {
                  result = false;
                } else {
                  Object.values(seriesDataModels).forEach(function(seriesDataModel) {
                    if (seriesDataModel.isCoordinateType) {
                      result = false;
                    }
                    return false;
                  });
                }
                return result;
              };
              ChartExportMenu2.prototype._attachEvent = function _attachEvent() {
                _eventListener2["default"].on(this.chartExportMenuContainer.parentNode, "click", this._onClick, this);
              };
              ChartExportMenu2.prototype._detachEvent = function _detachEvent() {
                _eventListener2["default"].off(this.chartExportMenuContainer.parentNode, "click", this._onClick);
              };
              return ChartExportMenu2;
            }();
            function chartExportMenuFactory(params) {
              var isVisible = params.options.visible;
              var _params$chartOptions$ = params.chartOptions.chart, chartOption = _params$chartOptions$ === void 0 ? {} : _params$chartOptions$;
              var exportingOption = params.chartOptions.chartExportMenu;
              var chartExportMenu = null;
              if (chartOption.title) {
                params.chartTitle = chartOption.title.text;
              }
              if (exportingOption && exportingOption.filename) {
                params.exportFilename = exportingOption.filename;
              }
              if (isVisible) {
                chartExportMenu = new ChartExportMenu(params);
              }
              return chartExportMenu;
            }
            chartExportMenuFactory.componentType = "chartExportMenu";
          },
          /* 76 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _browser = __webpack_require__(22);
            var _browser2 = _interopRequireDefault(_browser);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isString = __webpack_require__(25);
            var _isString2 = _interopRequireDefault(_isString);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            var _dataExporter = __webpack_require__(77);
            var _dataExporter2 = _interopRequireDefault(_dataExporter);
            var _imageExporter = __webpack_require__(79);
            var _imageExporter2 = _interopRequireDefault(_imageExporter);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var isIE10OrIE11 = _browser2["default"].msie && (_browser2["default"].version === 10 || _browser2["default"].version === 11);
            var isImageDownloadAvailable = !isIE10OrIE11 || isIE10OrIE11 && document.createElement("canvas").getContext("2d").drawSvg;
            var isDownloadAttributeSupported = (0, _isExisty2["default"])(document.createElement("a").download);
            var isMsSaveOrOpenBlobSupported = window.Blob && window.navigator.msSaveOrOpenBlob;
            function isImageExtension(extension) {
              return _arrayUtil2["default"].any(_imageExporter2["default"].getExtensions(), function(imageExtension) {
                return extension === imageExtension;
              });
            }
            function isDataExtension(extension) {
              return _arrayUtil2["default"].any(_dataExporter2["default"].getExtensions(), function(dataExtension) {
                return extension === dataExtension;
              });
            }
            function exportChart(fileName, extension, rawData, svgElement, downloadOptions) {
              var downloadOption = downloadOptions && downloadOptions[extension] ? downloadOptions[extension] : {};
              if (isImageExtension(extension)) {
                _imageExporter2["default"].downloadImage(fileName, extension, svgElement);
              } else if (isDataExtension(extension)) {
                _dataExporter2["default"].downloadData(fileName, extension, rawData, downloadOption);
              }
            }
            exports2["default"] = {
              exportChart,
              isDownloadSupported: isDownloadAttributeSupported || isMsSaveOrOpenBlobSupported,
              isImageDownloadAvailable,
              isImageExtension,
              /**
               * Add file extension to dataExtension
               * @param {string} type file extension type
               * @param {string} extension file extension
               */
              addExtension: function addExtension(type, extension) {
                var isValidExtension = extension && (0, _isString2["default"])(extension);
                var exporter = void 0;
                var extensions = void 0;
                if (type === "data") {
                  exporter = _dataExporter2["default"];
                } else if (type === "image") {
                  exporter = _imageExporter2["default"];
                }
                if (exporter && isValidExtension) {
                  extensions = exporter.getExtensions();
                  extensions.push(extension);
                }
              }
            };
          },
          /* 77 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _templateObject = _taggedTemplateLiteral(['<html xmlns:o="urn:schemas-microsoft-com:office:office" \n        xmlns:x="urn:schemas-microsoft-com:office:excel" \n        xmlns="http://www.w3.org/TR/REC-html40">\n        <head>\n            <!--[if gte mso 9]>\n                <xml>\n                    <x:ExcelWorkbook>\n                        <x:ExcelWorksheets>\n                            <x:ExcelWorksheet>\n                                <x:Name>Ark1</x:Name>\n                                <x:WorksheetOptions>\n                                    <x:DisplayGridlines/>\n                                </x:WorksheetOptions>\n                            </x:ExcelWorksheet>\n                        </x:ExcelWorksheets>\n                        </x:ExcelWorkbook>\n                </xml>\n            <![endif]-->\n            <meta name=ProgId content=Excel.Sheet>\n            <meta charset=UTF-8>\n        </head>\n        <body>\n            ', "\n        </body>\n        </html>"], ['<html xmlns:o="urn:schemas-microsoft-com:office:office" \n        xmlns:x="urn:schemas-microsoft-com:office:excel" \n        xmlns="http://www.w3.org/TR/REC-html40">\n        <head>\n            <!--[if gte mso 9]>\n                <xml>\n                    <x:ExcelWorkbook>\n                        <x:ExcelWorksheets>\n                            <x:ExcelWorksheet>\n                                <x:Name>Ark1</x:Name>\n                                <x:WorksheetOptions>\n                                    <x:DisplayGridlines/>\n                                </x:WorksheetOptions>\n                            </x:ExcelWorksheet>\n                        </x:ExcelWorksheets>\n                        </x:ExcelWorkbook>\n                </xml>\n            <![endif]-->\n            <meta name=ProgId content=Excel.Sheet>\n            <meta charset=UTF-8>\n        </head>\n        <body>\n            ', "\n        </body>\n        </html>"]);
            var _isArray = __webpack_require__(9);
            var _isArray2 = _interopRequireDefault(_isArray);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isNumber = __webpack_require__(19);
            var _isNumber2 = _interopRequireDefault(_isNumber);
            var _forEach = __webpack_require__(8);
            var _forEach2 = _interopRequireDefault(_forEach);
            var _forEachArray = __webpack_require__(10);
            var _forEachArray2 = _interopRequireDefault(_forEachArray);
            var _downloader = __webpack_require__(78);
            var _downloader2 = _interopRequireDefault(_downloader);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _taggedTemplateLiteral(strings, raw) {
              return Object.freeze(Object.defineProperties(strings, {
                raw: {
                  value: Object.freeze(raw)
                }
              }));
            }
            function _toConsumableArray(arr) {
              if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              } else {
                return Array.from(arr);
              }
            }
            var DATA_URI_HEADERS = {
              xls: "data:application/vnd.ms-excel;base64,",
              csv: "data:text/csv;charset=utf-8,%EF%BB%BF"
              /* BOM for utf-8 */
            };
            var DATA_URI_BODY_MAKERS = {
              xls: _makeXlsBodyWithRawData,
              csv: _makeCsvBodyWithRawData
            };
            var dataExtensions = [].concat(_toConsumableArray(_const2["default"].DATA_EXTENSIONS));
            var dataExporter = {
              /**
               * Download chart data
               * @param {string} fileName file name
               * @param {string} extension file extension
               * @param {object} rawData raw data of chart
               * @param {object} [downloadOption] download option
               */
              downloadData: function downloadData(fileName, extension, rawData, downloadOption) {
                var chartData2DArray = _get2DArrayFromRawData(rawData);
                var contentType = DATA_URI_HEADERS[extension].replace(/(data:|;base64,|,%EF%BB%BF)/g, "");
                var content = DATA_URI_BODY_MAKERS[extension](chartData2DArray, downloadOption);
                if (this._isNeedDataEncodeing()) {
                  if (extension !== "csv") {
                    content = window.btoa(unescape(encodeURIComponent(content)));
                  }
                  content = DATA_URI_HEADERS[extension] + content;
                }
                _downloader2["default"].execDownload(fileName, extension, content, contentType);
              },
              /**
               * Whether need encode type or not
               * @returns {boolean}
               * @private
               */
              _isNeedDataEncodeing: function _isNeedDataEncodeing() {
                var isDownloadAttributeSupported = (0, _isExisty2["default"])(document.createElement("a").download);
                var isMsSaveOrOpenBlobSupported = window.Blob && window.navigator.msSaveOrOpenBlob;
                if (!isMsSaveOrOpenBlobSupported && isDownloadAttributeSupported) {
                  return true;
                }
                return false;
              },
              /**
               * Returns data extensions
               * @returns {Array.<string>}
               */
              getExtensions: function getExtensions() {
                return dataExtensions;
              }
            };
            function _get2DArrayFromRawData(rawData) {
              var resultArray = [];
              var isHeatMap = rawData.categories && (0, _isExisty2["default"])(rawData.categories.x);
              var isBullet = rawData.series && (0, _isExisty2["default"])(rawData.series.bullet);
              var return2DArrayData = false;
              if (rawData) {
                var categories = void 0;
                if (isHeatMap) {
                  return2DArrayData = _get2DArrayFromHeatmapRawData(rawData);
                } else if (isBullet) {
                  return2DArrayData = _get2DArrayFromBulletRawData(rawData);
                } else if (rawData.categories) {
                  categories = rawData.categories;
                }
                if (return2DArrayData) {
                  return return2DArrayData;
                }
                resultArray.push([""].concat(categories));
                Object.values(rawData.series || {}).forEach(function(seriesDatum) {
                  seriesDatum.forEach(function(seriesItem) {
                    var data = (0, _isArray2["default"])(seriesItem.data) ? seriesItem.data : [seriesItem.data];
                    resultArray.push([seriesItem.name].concat(_toConsumableArray(data)));
                  });
                });
              }
              return resultArray;
            }
            function _makeTHeadForBullet(maxRangeCount, maxMarkerCount) {
              var tableHead = ["", _const2["default"].BULLET_TYPE_ACTUAL];
              for (var i = 0; i < maxRangeCount; i += 1) {
                tableHead.push(_const2["default"].BULLET_TYPE_RANGE + i);
              }
              for (var _i = 0; _i < maxMarkerCount; _i += 1) {
                tableHead.push(_const2["default"].BULLET_TYPE_MARKER + _i);
              }
              return tableHead;
            }
            function _makeTCellsFromBulletRanges(ranges, maxRangeCount) {
              var cells = [];
              for (var i = 0; i < maxRangeCount; i += 1) {
                var dataText = "";
                if (ranges && ranges[i]) {
                  var rangeStart = ranges[i].length > 0 ? ranges[i][0] : "";
                  var rangeEnd = ranges[i].length > 1 ? ranges[i][1] : "";
                  dataText = rangeStart + "~" + rangeEnd;
                }
                cells.push(dataText);
              }
              return cells;
            }
            function _makeTCellsFromBulletMarkers(markers, maxMarkerCount) {
              var cells = [];
              for (var i = 0; i < maxMarkerCount; i += 1) {
                var dataText = markers && markers[i] ? markers[i] : "";
                cells.push(dataText);
              }
              return cells;
            }
            function _get2DArrayFromBulletRawData(rawData) {
              var resultArray = [];
              var maxCounts = _calculateMaxCounts(rawData.series.bullet);
              var maxRangeCount = maxCounts.maxRangeCount, maxMarkerCount = maxCounts.maxMarkerCount;
              resultArray.push(_makeTHeadForBullet(maxRangeCount, maxMarkerCount));
              (0, _forEach2["default"])(rawData.series.bullet, function(seriesItem) {
                var rangeArray = _makeTCellsFromBulletRanges(seriesItem.ranges, maxRangeCount);
                var markerArray = _makeTCellsFromBulletMarkers(seriesItem.markers, maxMarkerCount);
                var row = [seriesItem.name, seriesItem.data].concat(_toConsumableArray(rangeArray), _toConsumableArray(markerArray));
                resultArray.push(row);
              });
              return resultArray;
            }
            function _calculateMaxCounts(bulletSeries) {
              var maxRangeCount = 0;
              var maxMarkerCount = 0;
              (0, _forEach2["default"])(bulletSeries, function(series) {
                maxRangeCount = Math.max(maxRangeCount, series.ranges.length);
                maxMarkerCount = Math.max(maxMarkerCount, series.markers.length);
              });
              return {
                maxRangeCount,
                maxMarkerCount
              };
            }
            function _get2DArrayFromHeatmapRawData(rawData) {
              var resultArray = [];
              resultArray.push([""].concat(_toConsumableArray(rawData.categories.x)));
              (0, _forEach2["default"])(rawData.series, function(seriesDatum) {
                (0, _forEach2["default"])(seriesDatum, function(seriesItem, index) {
                  var row = [rawData.categories.y[index]].concat(_toConsumableArray(seriesItem));
                  resultArray.push(row);
                });
              });
              return resultArray;
            }
            function _getTableElementStringForXls(chartData2DArray) {
              var tableElementString = "<table>";
              (0, _forEach2["default"])(chartData2DArray, function(row, rowIndex) {
                var cellTagName = rowIndex === 0 ? "th" : "td";
                tableElementString += "<tr>";
                (0, _forEach2["default"])(row, function(cell, cellIndex) {
                  var cellNumberClass = rowIndex !== 0 || cellIndex === 0 ? ' class="number"' : "";
                  var cellString = "<" + cellTagName + cellNumberClass + ">" + cell + "</" + cellTagName + ">";
                  tableElementString += cellString;
                });
                tableElementString += "</tr>";
              });
              tableElementString += "</table>";
              return tableElementString;
            }
            function _makeXlsBodyWithRawData(chartData2DArray) {
              var xlsString = _renderUtil2["default"].oneLineTrim(_templateObject, _getTableElementStringForXls(chartData2DArray));
              return xlsString;
            }
            function _makeCsvBodyWithRawData(chartData2DArray) {
              var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              var _option$lineDelimiter = option.lineDelimiter, lineDelimiter = _option$lineDelimiter === void 0 ? "\n" : _option$lineDelimiter, _option$itemDelimiter = option.itemDelimiter, itemDelimiter = _option$itemDelimiter === void 0 ? "," : _option$itemDelimiter;
              var lastRowIndex = chartData2DArray.length - 1;
              var csvText = "";
              (0, _forEachArray2["default"])(chartData2DArray, function(row, rowIndex) {
                var lastCellIndex = row.length - 1;
                (0, _forEachArray2["default"])(row, function(cell, cellIndex) {
                  var cellContent = (0, _isNumber2["default"])(cell) ? cell : '"' + cell + '"';
                  csvText += cellContent;
                  if (cellIndex < lastCellIndex) {
                    csvText += itemDelimiter;
                  }
                });
                if (rowIndex < lastRowIndex) {
                  csvText += lineDelimiter;
                }
              });
              return csvText;
            }
            Object.assign(dataExporter, {
              _makeCsvBodyWithRawData,
              _makeXlsBodyWithRawData,
              _get2DArrayFromRawData,
              _get2DArrayFromBulletRawData,
              _get2DArrayFromHeatmapRawData,
              _makeTCellsFromBulletRanges,
              _makeTCellsFromBulletMarkers,
              _makeTHeadForBullet
            });
            exports2["default"] = dataExporter;
          },
          /* 78 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isString = __webpack_require__(25);
            var _isString2 = _interopRequireDefault(_isString);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var DOWNLOAD_HANDLERS = {
              downloadAttribute: downloadWithAnchorElementDownloadAttribute,
              msSaveOrOpenBlob: downloadWithMsSaveOrOpenBlob
            };
            function getDownloadMethod() {
              var isDownloadAttributeSupported = (0, _isExisty2["default"])(document.createElement("a").download);
              var isMsSaveOrOpenBlobSupported = window.Blob && window.navigator.msSaveOrOpenBlob;
              var method = void 0;
              if (isMsSaveOrOpenBlobSupported) {
                method = "msSaveOrOpenBlob";
              } else if (isDownloadAttributeSupported) {
                method = "downloadAttribute";
              }
              return method;
            }
            function base64toBlob(base64String) {
              var contentType = base64String.substr(0, base64String.indexOf(";base64,")).substr(base64String.indexOf(":") + 1);
              var sliceSize = 1024;
              var byteCharacters = atob(base64String.substr(base64String.indexOf(",") + 1));
              var byteArrays = [];
              for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
                var slice = byteCharacters.slice(offset, offset + sliceSize);
                var byteNumbers = new Array(slice.length);
                for (var i = 0; i < slice.length; i += 1) {
                  byteNumbers[i] = slice.charCodeAt(i);
                }
                var byteArray = new window.Uint8Array(byteNumbers);
                byteArrays.push(byteArray);
              }
              var resultBlob = new Blob(byteArrays, {
                type: contentType
              });
              return resultBlob;
            }
            function isImageExtension(extension) {
              return _arrayUtil2["default"].any(_const2["default"].IMAGE_EXTENSIONS, function(imageExtension) {
                return extension === imageExtension;
              });
            }
            function downloadWithMsSaveOrOpenBlob(fileName, extension, content, contentType) {
              var blobObject = isImageExtension(extension) ? base64toBlob(content) : new Blob([content], {
                type: contentType
              });
              window.navigator.msSaveOrOpenBlob(blobObject, fileName + "." + extension);
            }
            function downloadWithAnchorElementDownloadAttribute(fileName, extension, content) {
              if (content) {
                var anchorElement = document.createElement("a");
                anchorElement.href = content;
                anchorElement.target = "_blank";
                anchorElement.download = fileName + "." + extension;
                document.body.appendChild(anchorElement);
                anchorElement.click();
                anchorElement.remove();
              }
            }
            function execDownload(fileName, extension, content, contentType) {
              var downloadMethod = getDownloadMethod();
              if (downloadMethod && (0, _isString2["default"])(content)) {
                DOWNLOAD_HANDLERS[downloadMethod](fileName, extension, content, contentType);
              }
            }
            exports2["default"] = {
              execDownload
            };
          },
          /* 79 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _downloader = __webpack_require__(78);
            var _downloader2 = _interopRequireDefault(_downloader);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _browser = __webpack_require__(22);
            var _browser2 = _interopRequireDefault(_browser);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _toConsumableArray(arr) {
              if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              } else {
                return Array.from(arr);
              }
            }
            var isIE10OrIE11 = _browser2["default"].msie && (_browser2["default"].version === 10 || _browser2["default"].version === 11);
            var DOMURL = window.URL || window.webkitURL || window;
            var imageExtensions = [].concat(_toConsumableArray(_const2["default"].IMAGE_EXTENSIONS));
            function getSvgString(svgElement) {
              var svgParent = svgElement.parentNode;
              var tempWrapper = document.createElement("DIV");
              tempWrapper.appendChild(svgElement);
              var svgString = tempWrapper.innerHTML;
              svgParent.appendChild(svgElement);
              tempWrapper = null;
              svgParent = null;
              return svgString;
            }
            function downloadSvgWithCanvg(canvas, svgString, fileName, extension) {
              var ctx = canvas.getContext("2d");
              if (isIE10OrIE11) {
                svgString = svgString.replace(/xmlns:NS1=""/, "");
                svgString = svgString.replace(/NS1:xmlns:xlink="http:\/\/www\.w3\.org\/1999\/xlink"/, "");
                svgString = svgString.replace(/xmlns="http:\/\/www\.w3\.org\/2000\/svg"/, "");
                svgString = svgString.replace(/xmlns:xlink="http:\/\/www\.w3\.org\/1999\/xlink"/, "");
              }
              ctx.drawSvg(svgString, 0, 0);
              _downloader2["default"].execDownload(fileName, extension, canvas.toDataURL("image/" + extension, 1));
            }
            function downloadSvgWithBlobURL(canvas, svgString, fileName, extension) {
              var ctx = canvas.getContext("2d");
              var blob = new Blob([svgString], {
                type: "image/svg+xml"
              });
              var url = DOMURL.createObjectURL(blob);
              var img = new Image();
              img.onload = function() {
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                _downloader2["default"].execDownload(fileName, extension, canvas.toDataURL("image/" + extension, 1));
                DOMURL.revokeObjectURL(url);
              };
              img.src = url;
            }
            exports2["default"] = {
              /**
               * Download image with png format
               * @param {string} fileName - file name to save
               * @param {string} extension - extension type
               * @param {HTMLElement} imageSourceElement - image source element
               */
              downloadImage: function downloadImage(fileName, extension, imageSourceElement) {
                var canvas = void 0;
                if (imageSourceElement.tagName === "svg") {
                  var parentNode = imageSourceElement.parentNode;
                  var svgString = getSvgString(imageSourceElement);
                  canvas = document.createElement("canvas");
                  canvas.width = parentNode.offsetWidth;
                  canvas.height = parentNode.offsetHeight;
                  if (isIE10OrIE11) {
                    downloadSvgWithCanvg(canvas, svgString, fileName, extension);
                  } else {
                    downloadSvgWithBlobURL(canvas, svgString, fileName, extension);
                  }
                } else if (imageSourceElement.tagName === "canvas") {
                  canvas = imageSourceElement;
                  _downloader2["default"].execDownload(fileName, extension, canvas.toDataURL("image/" + extension, 1));
                }
              },
              /**
               * Returns data extensions
               * @returns {Array.<string>}
               */
              getExtensions: function getExtensions() {
                return imageExtensions;
              }
            };
          },
          /* 80 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isString = __webpack_require__(25);
            var _isString2 = _interopRequireDefault(_isString);
            var _forEach = __webpack_require__(8);
            var _forEach2 = _interopRequireDefault(_forEach);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var bindHandlerMap = {};
            var eventListener = {
              /**
               * Add event listener for IE.
               * @memberOf module:eventListener
               * @param {HTMLElement} target target element
               * @param {string} type event type
               * @param {function} handler callback function
               * @param {?object} context context for callback
               * @private
               */
              _attachEvent: function _attachEvent(target, type, handler, context) {
                var bindHandler = void 0;
                if (context) {
                  bindHandler = handler.bind(context);
                } else {
                  bindHandler = handler;
                }
                bindHandlerMap[type + handler] = bindHandler;
                target.attachEvent("on" + type, bindHandler);
              },
              /**
               * Add event listener for other browsers.
               * @memberOf module:eventListener
               * @param {HTMLElement} target - target element
               * @param {string} type - event type
               * @param {function} handler - handler
               * @param {object} [context] - context for handler
               * @private
               */
              _addEventListener: function _addEventListener(target, type, handler, context) {
                var bindHandler = void 0;
                if (context) {
                  bindHandler = handler.bind(context);
                } else {
                  bindHandler = handler;
                }
                bindHandlerMap[type + handler] = bindHandler;
                target.addEventListener(type, bindHandler);
              },
              /**
               * Bind DOM event.
               * @memberOf module:eventListener
               * @memberOf module:eventListener
               * @param {HTMLElement} target target element
               * @param {string} type event type
               * @param {function} handler handler function
               * @param {object} [context] - context for handler
               * @private
               */
              _bindEvent: function _bindEvent(target, type, handler, context) {
                var bindEvent = void 0;
                if ("addEventListener" in target) {
                  bindEvent = this._addEventListener;
                } else if ("attachEvent" in target) {
                  bindEvent = this._attachEvent;
                }
                eventListener._bindEvent = bindEvent;
                bindEvent(target, type, handler, context);
              },
              /**
               * Bind DOM events.
               * @memberOf module:eventListener
               * @param {HTMLElement} target - target element
               * @param {string | object} types - type or map of type and handler
               * @param {function | object} [handler] - handler or context
               * @param {object} [context] - context
               */
              on: function on(target, types, handler, context) {
                var handlerMap = {};
                if ((0, _isString2["default"])(types)) {
                  handlerMap[types] = handler;
                } else {
                  handlerMap = types;
                  context = handler;
                }
                (0, _forEach2["default"])(handlerMap, function(_handler, type) {
                  eventListener._bindEvent(target, type, _handler, context);
                });
              },
              /**
               * Remove event listener for IE.
               * @memberOf module:eventListener
               * @param {HTMLElement} target - target element
               * @param {string} type - event type
               * @param {function} handler - handler
               * @private
               */
              _detachEvent: function _detachEvent(target, type, handler) {
                if (bindHandlerMap[type + handler]) {
                  target.detachEvent("on" + type, bindHandlerMap[type + handler]);
                  delete bindHandlerMap[type + handler];
                }
              },
              /**
               * Add event listener for other browsers.
               * @memberOf module:eventListener
               * @param {HTMLElement} target - target element
               * @param {string} type - event type
               * @param {function} handler - handler
               * @private
               */
              _removeEventListener: function _removeEventListener(target, type, handler) {
                target.removeEventListener(type, bindHandlerMap[type + handler]);
                delete bindHandlerMap[type + handler];
              },
              /**
               * Unbind DOM event.
               * @memberOf module:eventListener
               * @param {HTMLElement} target - target element
               * @param {string} type - event type
               * @param {function} handler - handler
               * @private
               */
              _unbindEvent: function _unbindEvent(target, type, handler) {
                var unbindEvent = void 0;
                if ("removeEventListener" in target) {
                  unbindEvent = eventListener._removeEventListener;
                } else if ("detachEvent" in target) {
                  unbindEvent = eventListener._detachEvent;
                }
                eventListener._unbindEvent = unbindEvent;
                unbindEvent(target, type, handler);
              },
              /**
               * Unbind DOM events.
               * @memberOf module:eventListener
               * @param {HTMLElement} target - target element
               * @param {string | object} types - type or map of type and handler
               * @param {function} [handler] - handler
               */
              off: function off(target, types, handler) {
                var handlerMap = {};
                if ((0, _isString2["default"])(types)) {
                  handlerMap[types] = handler;
                } else {
                  handlerMap = types;
                }
                (0, _forEach2["default"])(handlerMap, function(_handler, type) {
                  eventListener._unbindEvent(target, type, _handler);
                });
              }
            };
            exports2["default"] = eventListener;
          },
          /* 81 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = legendFactory;
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _isNotEmpty = __webpack_require__(82);
            var _isNotEmpty2 = _interopRequireDefault(_isNotEmpty);
            var _customEvents = __webpack_require__(67);
            var _customEvents2 = _interopRequireDefault(_customEvents);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _legendModel = __webpack_require__(85);
            var _legendModel2 = _interopRequireDefault(_legendModel);
            var _pluginFactory = __webpack_require__(51);
            var _pluginFactory2 = _interopRequireDefault(_pluginFactory);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var LEGEND_ICON_HEIGHT = _const2["default"].LEGEND_ICON_HEIGHT, LINE_MARGIN_TOP = _const2["default"].LINE_MARGIN_TOP, LEGEND_AREA_H_PADDING = _const2["default"].LEGEND_AREA_H_PADDING, PUBLIC_EVENT_PREFIX = _const2["default"].PUBLIC_EVENT_PREFIX;
            var Legend = function() {
              function Legend2(params) {
                _classCallCheck(this, Legend2);
                this.theme = params.theme;
                this.options = params.options || {};
                this.chartType = params.chartType;
                this.seriesTypes = params.seriesTypes || [this.chartType];
                this.eventBus = params.eventBus;
                this.className = "tui-chart-legend-area";
                this.dataProcessor = params.dataProcessor;
                this.legendModel = new _legendModel2["default"]({
                  theme: this.theme,
                  labels: params.dataProcessor.getLegendLabels(),
                  legendData: params.dataProcessor.getLegendData(),
                  seriesTypes: this.seriesTypes,
                  chartType: this.chartType
                });
                this.layout = null;
                this.graphRenderer = _pluginFactory2["default"].get(_const2["default"].COMPONENT_TYPE_RAPHAEL, "legend");
                this.paper = null;
                this.drawingType = _const2["default"].COMPONENT_TYPE_RAPHAEL;
              }
              Legend2.prototype.presetForChangeData = function presetForChangeData() {
                var theme = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.theme;
                this.theme = theme;
                this.legendModel = new _legendModel2["default"]({
                  theme: this.theme,
                  labels: this.dataProcessor.getLegendLabels(),
                  legendData: this.dataProcessor.getLegendData(),
                  seriesTypes: this.seriesTypes,
                  chartType: this.chartType
                });
              };
              Legend2.prototype._setDataForRendering = function _setDataForRendering(data) {
                if (data) {
                  this.layout = data.layout;
                  this.paper = data.paper;
                }
              };
              Legend2.prototype._render = function _render(data) {
                this._setDataForRendering(data);
                var _renderLegendArea2 = this._renderLegendArea(data.paper), legendSet = _renderLegendArea2.legendSet, paginationElem = _renderLegendArea2.paginationElem;
                this.legendSet = legendSet;
                this.paginationArea = paginationElem;
              };
              Legend2.prototype.render = function render(data) {
                this._render(data);
                this._listenEvents();
              };
              Legend2.prototype.rerender = function rerender(data) {
                this.legendSet.remove();
                this.paginationArea.forEach(function(elem) {
                  return elem.remove();
                });
                this._render(data);
              };
              Legend2.prototype.resize = function resize(data) {
                this.rerender(data);
              };
              Legend2.prototype._getLegendRenderingData = function _getLegendRenderingData(legendData, labelHeight, labelWidths) {
                var _this = this;
                var colorByPoint = (_predicate2["default"].isBarTypeChart(this.chartType) || _predicate2["default"].isBoxplotChart(this.chartType)) && this.dataProcessor.options.series.colorByPoint;
                var data = legendData.map(function(legendDatum, index) {
                  var checkbox = _this.options.showCheckbox === false ? null : {
                    checked: _this.legendModel.isCheckedIndex(index)
                  };
                  var legendLabel = legendDatum.label;
                  if (_this.options.maxWidth) {
                    legendLabel = _raphaelRenderUtil2["default"].getEllipsisText(legendLabel, _this.options.maxWidth, _this.theme.label);
                  }
                  return {
                    checkbox,
                    iconType: legendDatum.chartType || "rect",
                    colorByPoint,
                    index,
                    theme: legendDatum.theme,
                    label: legendLabel,
                    labelHeight,
                    labelWidth: labelWidths[index],
                    isUnselected: _this.legendModel.isUnselectedIndex(index)
                  };
                });
                if ((_predicate2["default"].isAreaChart(this.chartType) || _predicate2["default"].isColumnChart(this.chartType)) && (0, _isNotEmpty2["default"])(this.dataProcessor.options.series.stack) && this.options.align !== "top" && this.options.align !== "bottom") {
                  data.reverse();
                }
                return data;
              };
              Legend2.prototype._renderLegendArea = function _renderLegendArea(paper) {
                var legendData = this.legendModel.getData();
                var graphRenderer = this.graphRenderer;
                var isHorizontal = _predicate2["default"].isHorizontalLegend(this.options.align);
                var basePosition = this.layout.position;
                var labelWidths = graphRenderer.makeLabelWidths(legendData, this.theme.label, this.options.maxWidth);
                var labelTheme = legendData[0] ? legendData[0].theme : {};
                var labelHeight = graphRenderer.getRenderedLabelHeight("DEFAULT_TEXT", labelTheme) - 1;
                var labelCount = labelWidths.length;
                var legendItemHeight = Math.max(LEGEND_ICON_HEIGHT, labelHeight);
                var dimensionHeight = (LINE_MARGIN_TOP + legendItemHeight) * (isHorizontal ? 1 : labelCount);
                var top = basePosition.top;
                var left = basePosition.left;
                if (!_predicate2["default"].isLegendAlignLeft(this.options.align)) {
                  left += LEGEND_AREA_H_PADDING;
                }
                return graphRenderer.render({
                  paper,
                  legendData: this._getLegendRenderingData(legendData, labelHeight, labelWidths),
                  isHorizontal,
                  position: {
                    left,
                    top
                  },
                  dimension: {
                    height: dimensionHeight,
                    width: this.layout.dimension.width
                  },
                  labelTheme: this.theme.label,
                  labelWidths,
                  eventBus: this.eventBus
                });
              };
              Legend2.prototype._fireChangeCheckedLegendsEvent = function _fireChangeCheckedLegendsEvent() {
                this.eventBus.fire("changeCheckedLegends", this.legendModel.getCheckedIndexes());
              };
              Legend2.prototype._fireChangeCheckedLegendsPublicEvent = function _fireChangeCheckedLegendsPublicEvent() {
                this.eventBus.fire(PUBLIC_EVENT_PREFIX + "changeCheckedLegends", this.legendModel.getCheckedIndexes());
              };
              Legend2.prototype._fireSelectLegendEvent = function _fireSelectLegendEvent(data) {
                var index = this.legendModel.getSelectedIndex();
                var legendIndex = !(0, _isNull2["default"])(index) ? data.seriesIndex : index;
                this.eventBus.fire("selectLegend", data.chartType, legendIndex);
              };
              Legend2.prototype._fireSelectLegendPublicEvent = function _fireSelectLegendPublicEvent(_ref) {
                var label = _ref.label, index = _ref.index, chartType = _ref.chartType;
                this.eventBus.fire(PUBLIC_EVENT_PREFIX + "selectLegend", {
                  legend: label,
                  chartType,
                  index
                });
              };
              Legend2.prototype._selectLegend = function _selectLegend(index) {
                var data = this.legendModel.getDatum(index);
                this.legendModel.toggleSelectedIndex(index);
                if (!(0, _isNull2["default"])(this.legendModel.getSelectedIndex()) && !this.legendModel.isCheckedSelectedIndex()) {
                  this.legendModel.checkSelectedIndex();
                  this._fireChangeCheckedLegendsEvent();
                }
                this.dataProcessor.selectLegendIndex = this.legendModel.getSelectedIndex();
                this.graphRenderer.selectLegend(this.dataProcessor.selectLegendIndex, this.legendSet);
                this._fireSelectLegendEvent(data);
                this._fireSelectLegendPublicEvent(data);
              };
              Legend2.prototype._getCheckedIndexes = function _getCheckedIndexes() {
                var checkedIndexes = [];
                this.legendModel.checkedWholeIndexes.forEach(function(checkbox, index) {
                  if (checkbox) {
                    checkedIndexes.push(index);
                  }
                });
                return checkedIndexes;
              };
              Legend2.prototype.getCheckedIndexes = function getCheckedIndexes() {
                return this.legendModel.getCheckedIndexes();
              };
              Legend2.prototype._checkLegend = function _checkLegend() {
                var selectedData = this.legendModel.getSelectedDatum();
                if (!this.legendModel.isCheckedSelectedIndex()) {
                  this.legendModel.updateSelectedIndex(null);
                }
                this._fireChangeCheckedLegendsEvent();
                this._fireChangeCheckedLegendsPublicEvent();
                if (selectedData) {
                  this._fireSelectLegendEvent(selectedData);
                }
              };
              Legend2.prototype._checkboxClick = function _checkboxClick(index) {
                this.legendModel.toggleCheckedIndex(index);
                var checkedIndexes = this._getCheckedIndexes();
                if (checkedIndexes.length > 0) {
                  this.legendModel.updateCheckedLegendsWith(checkedIndexes);
                  this._checkLegend();
                } else {
                  this.legendModel.toggleCheckedIndex(index);
                }
              };
              Legend2.prototype._labelClick = function _labelClick(index) {
                this._selectLegend(index);
              };
              Legend2.prototype._listenEvents = function _listenEvents() {
                this.eventBus.on("checkboxClicked", this._checkboxClick, this);
                this.eventBus.on("labelClicked", this._labelClick, this);
              };
              return Legend2;
            }();
            _customEvents2["default"].mixin(Legend);
            function legendFactory(params) {
              var options = params.options, seriesTypes = params.dataProcessor.seriesTypes, chartType = params.chartOptions.chartType;
              var isLegendVisible = (0, _isUndefined2["default"])(options.visible) ? true : options.visible;
              var legend = null;
              if (isLegendVisible) {
                params.seriesTypes = seriesTypes;
                params.chartType = chartType;
                legend = new Legend(params);
              }
              return legend;
            }
            legendFactory.componentType = "legend";
            legendFactory.Legend = Legend;
          },
          /* 82 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var isEmpty = __webpack_require__(83);
            function isNotEmpty(obj) {
              return !isEmpty(obj);
            }
            module2.exports = isNotEmpty;
          },
          /* 83 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var isString = __webpack_require__(25);
            var isExisty = __webpack_require__(15);
            var isArray = __webpack_require__(9);
            var isArguments = __webpack_require__(84);
            var isObject = __webpack_require__(7);
            var isFunction = __webpack_require__(56);
            function _isEmptyString(obj) {
              return isString(obj) && obj === "";
            }
            function _hasOwnProperty(obj) {
              var key;
              for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                  return true;
                }
              }
              return false;
            }
            function isEmpty(obj) {
              if (!isExisty(obj) || _isEmptyString(obj)) {
                return true;
              }
              if (isArray(obj) || isArguments(obj)) {
                return obj.length === 0;
              }
              if (isObject(obj) && !isFunction(obj)) {
                return !_hasOwnProperty(obj);
              }
              return true;
            }
            module2.exports = isEmpty;
          },
          /* 84 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var isExisty = __webpack_require__(15);
            function isArguments(obj) {
              var result = isExisty(obj) && (Object.prototype.toString.call(obj) === "[object Arguments]" || !!obj.callee);
              return result;
            }
            module2.exports = isArguments;
          },
          /* 85 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _toConsumableArray(arr) {
              if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              } else {
                return Array.from(arr);
              }
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var LegendModel = function() {
              function LegendModel2(params) {
                _classCallCheck(this, LegendModel2);
                this.theme = params.theme;
                this.labels = params.labels;
                this.legendData = params.legendData;
                this.seriesTypes = params.seriesTypes || [];
                this.chartType = params.chartType;
                this.data = null;
                this.selectedIndex = null;
                this.checkedIndexesMap = {};
                this.checkedWholeIndexes = [];
                this._setData();
                this._initCheckedIndexes();
              }
              LegendModel2.prototype._initCheckedIndexes = function _initCheckedIndexes() {
                var _this = this;
                var checkedIndexes = [];
                this.legendData.forEach(function(_ref, index) {
                  var visible = _ref.visible;
                  if (visible) {
                    checkedIndexes.push(index);
                  }
                  _this.checkedWholeIndexes[index] = visible;
                });
                this.updateCheckedLegendsWith(checkedIndexes);
              };
              LegendModel2.prototype._setThemeToLegendData = function _setThemeToLegendData(legendData, _ref2, checkedIndexes) {
                var colors = _ref2.colors, borderColor = _ref2.borderColor;
                var seriesIndex = 0;
                legendData.forEach(function(datum, index) {
                  var itemTheme = {
                    color: colors[index]
                  };
                  if (borderColor) {
                    itemTheme.borderColor = borderColor;
                  }
                  datum.theme = itemTheme;
                  datum.index = index;
                  if (!checkedIndexes || !(0, _isUndefined2["default"])(checkedIndexes[index])) {
                    datum.seriesIndex = seriesIndex;
                    seriesIndex += 1;
                  } else {
                    datum.seriesIndex = -1;
                  }
                });
              };
              LegendModel2.prototype._setData = function _setData() {
                var _this2 = this;
                var theme = this.theme, chartType = this.chartType, seriesTypes = this.seriesTypes, legendData = this.legendData, checkedIndexesMap = this.checkedIndexesMap;
                var data = void 0;
                if (!seriesTypes || seriesTypes.length < 2) {
                  this._setThemeToLegendData(legendData, theme[chartType], checkedIndexesMap[chartType]);
                  data = legendData;
                } else {
                  var _ref3;
                  var startIndex = 0;
                  var dataItems = seriesTypes.map(function(seriesType) {
                    var labelLen = _this2.labels[seriesType].length;
                    var endIndex = startIndex + labelLen;
                    var slicedLegendData = legendData.slice(startIndex, endIndex);
                    var checkedIndexes = checkedIndexesMap[seriesType];
                    startIndex = endIndex;
                    _this2._setThemeToLegendData(slicedLegendData, theme[seriesType], checkedIndexes);
                    return slicedLegendData;
                  });
                  data = (_ref3 = []).concat.apply(_ref3, _toConsumableArray(dataItems));
                }
                this.data = data;
              };
              LegendModel2.prototype.getData = function getData() {
                return this.data;
              };
              LegendModel2.prototype.getDatum = function getDatum(index) {
                return this.data[index];
              };
              LegendModel2.prototype.getDatumByLabel = function getDatumByLabel(label) {
                var foundDatum = null;
                this.data.forEach(function(datum) {
                  if (datum.label === label) {
                    foundDatum = datum;
                  }
                  return !foundDatum;
                });
                return foundDatum;
              };
              LegendModel2.prototype.getSelectedDatum = function getSelectedDatum() {
                return this.getDatum(this.selectedIndex);
              };
              LegendModel2.prototype.updateSelectedIndex = function updateSelectedIndex(value) {
                this.selectedIndex = value;
              };
              LegendModel2.prototype.toggleSelectedIndex = function toggleSelectedIndex(index) {
                var selectedIndex = void 0;
                if (this.selectedIndex === index) {
                  selectedIndex = null;
                } else {
                  selectedIndex = index;
                }
                this.updateSelectedIndex(selectedIndex);
              };
              LegendModel2.prototype.getSelectedIndex = function getSelectedIndex() {
                return this.selectedIndex;
              };
              LegendModel2.prototype.isUnselectedIndex = function isUnselectedIndex(index) {
                return !(0, _isNull2["default"])(this.selectedIndex) && this.selectedIndex !== index;
              };
              LegendModel2.prototype.isCheckedSelectedIndex = function isCheckedSelectedIndex() {
                return this.isCheckedIndex(this.selectedIndex);
              };
              LegendModel2.prototype.toggleCheckedIndex = function toggleCheckedIndex(index) {
                this.checkedWholeIndexes[index] = !this.checkedWholeIndexes[index];
              };
              LegendModel2.prototype._updateCheckedIndex = function _updateCheckedIndex(index) {
                this.checkedWholeIndexes[index] = true;
              };
              LegendModel2.prototype.isCheckedIndex = function isCheckedIndex(index) {
                return !!this.checkedWholeIndexes[index];
              };
              LegendModel2.prototype._addSendingDatum = function _addSendingDatum(index) {
                var legendDatum = this.getDatum(index);
                var chartType = legendDatum.chartType, chartIndex = legendDatum.index;
                if (!this.checkedIndexesMap[chartType]) {
                  this.checkedIndexesMap[chartType] = new Array(this.labels[chartType].length).fill(false);
                }
                this.checkedIndexesMap[chartType][chartIndex] = true;
              };
              LegendModel2.prototype.checkSelectedIndex = function checkSelectedIndex() {
                this._updateCheckedIndex(this.selectedIndex);
                this._addSendingDatum(this.selectedIndex);
                this._setData();
              };
              LegendModel2.prototype.getCheckedIndexes = function getCheckedIndexes() {
                var _this3 = this;
                return Object.keys(this.checkedIndexesMap).reduce(function(booleanizeObject, chartType) {
                  booleanizeObject[chartType] = Array.from(_this3.checkedIndexesMap[chartType], function(checked) {
                    return !!checked;
                  });
                  return booleanizeObject;
                }, {});
              };
              LegendModel2.prototype._resetCheckedData = function _resetCheckedData() {
                this.checkedWholeIndexes = [];
                this.checkedIndexesMap = {};
              };
              LegendModel2.prototype.updateCheckedLegendsWith = function updateCheckedLegendsWith(indexes) {
                var _this4 = this;
                this._resetCheckedData();
                indexes.forEach(function(index) {
                  _this4._updateCheckedIndex(index);
                  _this4._addSendingDatum(index);
                });
                this._setData();
              };
              return LegendModel2;
            }();
            exports2["default"] = LegendModel;
          },
          /* 86 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = spectrumLegendFactory;
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _pluginFactory = __webpack_require__(51);
            var _pluginFactory2 = _interopRequireDefault(_pluginFactory);
            var _defaultTheme = __webpack_require__(53);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var COMPONENT_TYPE_RAPHAEL = _const2["default"].COMPONENT_TYPE_RAPHAEL, MAP_LEGEND_LABEL_PADDING = _const2["default"].MAP_LEGEND_LABEL_PADDING, MAP_LEGEND_GRAPH_SIZE = _const2["default"].MAP_LEGEND_GRAPH_SIZE, CHART_PADDING = _const2["default"].CHART_PADDING;
            var SpectrumLegend = function() {
              SpectrumLegend2.prototype._isDefaultLegendLabelColor = function _isDefaultLegendLabelColor(color) {
                return color === _defaultTheme.DEFAULT_LEGEND_LABEL_FONTCOLOR;
              };
              function SpectrumLegend2(params) {
                _classCallCheck(this, SpectrumLegend2);
                var libType = params.libType, chartType = params.chartType, theme = params.theme, _params$options = params.options, options = _params$options === void 0 ? {} : _params$options, dataProcessor = params.dataProcessor, colorSpectrum = params.colorSpectrum, eventBus = params.eventBus;
                this.chartType = chartType;
                this.theme = theme;
                if (this._isDefaultLegendLabelColor(this.theme.label.color)) {
                  this.theme.label.color = "#fff";
                }
                this.options = options;
                this.dataProcessor = dataProcessor;
                this.colorSpectrum = colorSpectrum;
                this.eventBus = eventBus;
                this.graphRenderer = _pluginFactory2["default"].get(libType, "mapLegend");
                this.isHorizontal = _predicate2["default"].isHorizontalLegend(this.options.align);
                this.scaleData = null;
                this.drawingType = COMPONENT_TYPE_RAPHAEL;
                this._attachToEventBus();
              }
              SpectrumLegend2.prototype._attachToEventBus = function _attachToEventBus() {
                this.eventBus.on({
                  showWedge: this.onShowWedge,
                  hideTooltip: this.onHideWedge
                }, this);
                this.eventBus.on("beforeImageDownload", this._removeLocationURLFromFillAttribute.bind(this));
                this.eventBus.on("afterImageDownload", this._restoreLocationURLToFillAttribute.bind(this));
              };
              SpectrumLegend2.prototype._removeLocationURLFromFillAttribute = function _removeLocationURLFromFillAttribute() {
                this.graphRenderer.removeLocationURLFromFillAttribute();
              };
              SpectrumLegend2.prototype._restoreLocationURLToFillAttribute = function _restoreLocationURLToFillAttribute() {
                this.graphRenderer.restoreLocationURLToFillAttribute();
              };
              SpectrumLegend2.prototype._makeBaseDataToMakeTickArea = function _makeBaseDataToMakeTickArea() {
                var dimension = this.layout.dimension;
                var scaleData = this.scaleData, align = this.options.align;
                var stepCount = scaleData.stepCount || scaleData.tickCount - 1;
                var baseData = {};
                baseData.position = this.layout.position;
                if (this.isHorizontal) {
                  baseData.step = dimension.width / stepCount;
                  if (_predicate2["default"].isLegendAlignTop(align)) {
                    baseData.position.top -= MAP_LEGEND_LABEL_PADDING;
                  } else {
                    baseData.position.top += MAP_LEGEND_GRAPH_SIZE + MAP_LEGEND_LABEL_PADDING;
                  }
                } else {
                  baseData.step = dimension.height / stepCount;
                  if (_predicate2["default"].isLegendAlignLeft(align)) {
                    baseData.position.left = CHART_PADDING;
                  } else {
                    baseData.position.left += MAP_LEGEND_GRAPH_SIZE + MAP_LEGEND_LABEL_PADDING;
                  }
                }
                return baseData;
              };
              SpectrumLegend2.prototype._renderTickArea = function _renderTickArea(legendSet) {
                if (this.options.reversed) {
                  this.scaleData.labels.sort(function(prev, next) {
                    return next - prev;
                  });
                }
                this.graphRenderer.renderTickLabels(this.paper, this._makeBaseDataToMakeTickArea(), this.scaleData.labels, this.options.align, legendSet);
              };
              SpectrumLegend2.prototype._makeVerticalGraphDimension = function _makeVerticalGraphDimension() {
                return {
                  width: MAP_LEGEND_GRAPH_SIZE,
                  height: this.layout.dimension.height
                };
              };
              SpectrumLegend2.prototype._makeHorizontalGraphDimension = function _makeHorizontalGraphDimension() {
                return {
                  width: this.layout.dimension.width,
                  height: MAP_LEGEND_GRAPH_SIZE
                };
              };
              SpectrumLegend2.prototype._renderGraph = function _renderGraph(legendSet) {
                var position = this.layout.position;
                var dimension = void 0;
                if (this.isHorizontal) {
                  dimension = this._makeHorizontalGraphDimension();
                } else {
                  dimension = this._makeVerticalGraphDimension();
                }
                if (this.options.reversed) {
                  var startForSwap = this.colorSpectrum.start;
                  this.colorSpectrum.start = this.colorSpectrum.end;
                  this.colorSpectrum.end = startForSwap;
                }
                this.graphRenderer.render({
                  paper: this.paper,
                  layout: {
                    dimension,
                    position
                  },
                  colorSpectrum: this.colorSpectrum,
                  align: this.options.align,
                  legendSet,
                  theme: this.theme.label,
                  labels: this.scaleData.labels
                });
              };
              SpectrumLegend2.prototype._renderLegendArea = function _renderLegendArea() {
                var legendSet = this.paper.set();
                this._renderGraph(legendSet);
                this._renderTickArea(legendSet);
                return legendSet;
              };
              SpectrumLegend2.prototype._setDataForRendering = function _setDataForRendering(_ref) {
                var layout = _ref.layout, paper = _ref.paper, legendScaleData = _ref.legendScaleData;
                this.layout = layout;
                this.paper = paper;
                this.scaleData = legendScaleData;
              };
              SpectrumLegend2.prototype.render = function render(data) {
                this._setDataForRendering(data);
                this.legendSet = this._renderLegendArea();
              };
              SpectrumLegend2.prototype.rerender = function rerender(data) {
                this.legendSet.remove();
                this.render(data);
              };
              SpectrumLegend2.prototype.resize = function resize(data) {
                this.rerender(data);
              };
              SpectrumLegend2.prototype.onShowWedge = function onShowWedge(ratio, label) {
                ratio = this.options.reversed ? 1 - ratio : ratio;
                this.graphRenderer.showWedge(ratio, label);
              };
              SpectrumLegend2.prototype.onHideWedge = function onHideWedge() {
                this.graphRenderer.hideWedge();
              };
              return SpectrumLegend2;
            }();
            function spectrumLegendFactory(params) {
              var isLegendVisible = (0, _isUndefined2["default"])(params.options.visible) ? true : params.options.visible;
              var chartType = params.chartOptions.chartType;
              var spectrumLegend = null;
              if (isLegendVisible) {
                params.chartType = chartType;
                spectrumLegend = new SpectrumLegend(params);
              }
              return spectrumLegend;
            }
            spectrumLegendFactory.componentType = "legend";
            spectrumLegendFactory.SpectrumLegend = SpectrumLegend;
          },
          /* 87 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = circleLegendFactory;
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _pick = __webpack_require__(21);
            var _pick2 = _interopRequireDefault(_pick);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _pluginFactory = __webpack_require__(51);
            var _pluginFactory2 = _interopRequireDefault(_pluginFactory);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var CircleLegend = function() {
              function CircleLegend2(_ref) {
                var libType = _ref.libType, chartType = _ref.chartType, dataProcessor = _ref.dataProcessor, baseFontFamily = _ref.baseFontFamily;
                _classCallCheck(this, CircleLegend2);
                this.circleRatios = [1, 0.5, 0.25];
                this.chartType = chartType;
                this.dataProcessor = dataProcessor;
                this.labelTheme = {
                  fontSize: _const2["default"].CIRCLE_LEGEND_LABEL_FONT_SIZE,
                  fontFamily: baseFontFamily
                };
                this.graphRenderer = _pluginFactory2["default"].get(libType, "circleLegend");
                this.layout = null;
                this.maxRadius = null;
                this.drawingType = _const2["default"].COMPONENT_TYPE_RAPHAEL;
              }
              CircleLegend2.prototype._formatLabel = function _formatLabel(label, decimalLength) {
                var formatFunctions = this.dataProcessor.getFormatFunctions();
                var formattedLabel = void 0;
                if (decimalLength === 0) {
                  formattedLabel = String(parseInt(label, 10));
                } else {
                  formattedLabel = _renderUtil2["default"].formatToDecimal(String(label), decimalLength);
                }
                return _renderUtil2["default"].formatValue({
                  value: formattedLabel,
                  formatFunctions,
                  chartType: this.chartType,
                  areaType: "circleLegend",
                  valueType: "r"
                });
              };
              CircleLegend2.prototype._makeLabels = function _makeLabels() {
                var _this = this;
                var maxValueRadius = this.dataProcessor.getMaxValue(this.chartType, "r");
                var decimalLength = _calculator2["default"].getDecimalLength(maxValueRadius);
                return this.circleRatios.map(function(ratio) {
                  return _this._formatLabel(maxValueRadius * ratio, decimalLength);
                });
              };
              CircleLegend2.prototype._render = function _render(paper) {
                return this.graphRenderer.render(paper, this.layout, this.maxRadius, this.circleRatios, this._makeLabels());
              };
              CircleLegend2.prototype._setDataForRendering = function _setDataForRendering(data) {
                this.layout = data.layout;
                this.maxRadius = data.maxRadius;
              };
              CircleLegend2.prototype.render = function render(data) {
                this._setDataForRendering(data);
                this.circleLegendSet = this._render(data.paper);
              };
              CircleLegend2.prototype.rerender = function rerender(data) {
                this.circleLegendSet.remove();
                this._setDataForRendering(data);
                this.circleLegendSet = this._render(data.paper);
              };
              CircleLegend2.prototype.resize = function resize(data) {
                this.rerender(data);
              };
              return CircleLegend2;
            }();
            function circleLegendFactory(params) {
              var chartTheme = params.chartTheme, chartType = params.chartOptions.chartType;
              var visibleOption = (0, _pick2["default"])(params.chartOptions, "circleLegend", "visible");
              var circleLegend = null;
              var isLegendVisible = void 0;
              if ((0, _isUndefined2["default"])(visibleOption)) {
                isLegendVisible = true;
              } else {
                isLegendVisible = visibleOption;
              }
              if (isLegendVisible) {
                params.chartType = chartType;
                params.baseFontFamily = chartTheme.chart.fontFamily;
                circleLegend = new CircleLegend(params);
              }
              return circleLegend;
            }
            circleLegendFactory.componentType = "legend";
            circleLegendFactory.CircleLegend = CircleLegend;
          },
          /* 88 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = tooltipFactory;
            var _normalTooltip = __webpack_require__(89);
            var _normalTooltip2 = _interopRequireDefault(_normalTooltip);
            var _groupTooltip = __webpack_require__(94);
            var _groupTooltip2 = _interopRequireDefault(_groupTooltip);
            var _mapChartTooltip = __webpack_require__(96);
            var _mapChartTooltip2 = _interopRequireDefault(_mapChartTooltip);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _isArray = __webpack_require__(9);
            var _isArray2 = _interopRequireDefault(_isArray);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function pieTooltipLabelFormatter(seriesItem, tooltipDatum, labelPrefix) {
              var percentageString = (seriesItem.ratio * 100).toFixed(4);
              var percent = parseFloat(percentageString);
              var needSlice = percent < 9e-4 || percentageString.length > 5;
              percentageString = needSlice ? percentageString.substr(0, 4) : String(percent);
              var ratioLabel = percentageString + "&nbsp;%&nbsp;" || "";
              tooltipDatum.ratioLabel = labelPrefix + ratioLabel;
              tooltipDatum.label = seriesItem.tooltipLabel || (seriesItem.label ? seriesItem.label : "");
              return tooltipDatum;
            }
            function tooltipFactory(params) {
              var chartType = params.chartOptions.chartType, seriesTypes = params.seriesTypes;
              var xAxisOptions = params.chartOptions.xAxis;
              var colors = [];
              var factory = void 0;
              var legendTheme = Object.values(params.chartTheme.legend).filter(function(item) {
                return (0, _isArray2["default"])(item.colors);
              });
              legendTheme.forEach(function(series) {
                colors = colors.concat(series.colors);
              });
              if (chartType === "map") {
                factory = _mapChartTooltip2["default"];
              } else if (params.options.grouped) {
                factory = _groupTooltip2["default"];
              } else {
                factory = _normalTooltip2["default"];
              }
              if (chartType === "pie" || _predicate2["default"].isPieDonutComboChart(chartType, seriesTypes)) {
                params.labelFormatter = pieTooltipLabelFormatter;
              }
              params.chartType = chartType;
              params.chartTypes = seriesTypes;
              params.xAxisType = xAxisOptions.type;
              params.dateFormat = xAxisOptions.dateFormat;
              params.colors = colors;
              return factory(params);
            }
            tooltipFactory.componentType = "tooltip";
          },
          /* 89 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = normalTooltipFactory;
            var _isArray = __webpack_require__(9);
            var _isArray2 = _interopRequireDefault(_isArray);
            var _isNumber = __webpack_require__(19);
            var _isNumber2 = _interopRequireDefault(_isNumber);
            var _pick = __webpack_require__(21);
            var _pick2 = _interopRequireDefault(_pick);
            var _tooltipBase = __webpack_require__(90);
            var _tooltipBase2 = _interopRequireDefault(_tooltipBase);
            var _singleTooltipMixer = __webpack_require__(91);
            var _singleTooltipMixer2 = _interopRequireDefault(_singleTooltipMixer);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _tooltipTemplate = __webpack_require__(92);
            var _tooltipTemplate2 = _interopRequireDefault(_tooltipTemplate);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var DEFAULT_TOOLTIP_COLOR = "#aaa";
            var NormalTooltip = function(_TooltipBase) {
              _inherits(NormalTooltip2, _TooltipBase);
              function NormalTooltip2(params) {
                _classCallCheck(this, NormalTooltip2);
                var _this = _possibleConstructorReturn(this, _TooltipBase.call(this, params));
                _this.colorSpectrum = params.colorSpectrum;
                return _this;
              }
              NormalTooltip2.prototype._makeTooltipHtml = function _makeTooltipHtml(category, item) {
                var template = this._getTooltipTemplate(item);
                return template(Object.assign({
                  categoryVisible: category ? "show" : "hide",
                  category
                }, item));
              };
              NormalTooltip2.prototype._getTooltipTemplate = function _getTooltipTemplate(item) {
                var template = _tooltipTemplate2["default"].tplDefault;
                if (_predicate2["default"].isBoxplotChart(this.chartType)) {
                  template = this._getBoxplotTooltipTemplate(item);
                } else if (_predicate2["default"].isPieChart(this.chartType) || _predicate2["default"].isPieDonutComboChart(this.chartType, this.chartTypes)) {
                  template = _tooltipTemplate2["default"].tplPieChart;
                } else if (this.dataProcessor.coordinateType) {
                  template = _tooltipTemplate2["default"].tplCoordinatetypeChart;
                } else if (_predicate2["default"].isBulletChart(this.chartType)) {
                  template = _tooltipTemplate2["default"].tplBulletChartDefault;
                } else if (_predicate2["default"].isHeatmapChart(this.chartType)) {
                  template = _tooltipTemplate2["default"].tplHeatmapChart;
                }
                return template;
              };
              NormalTooltip2.prototype._getBoxplotTooltipTemplate = function _getBoxplotTooltipTemplate(item) {
                var template = _tooltipTemplate2["default"].tplBoxplotChartDefault;
                if ((0, _isNumber2["default"])(item.outlierIndex)) {
                  template = _tooltipTemplate2["default"].tplBoxplotChartOutlier;
                  item.label = item.outliers[item.outlierIndex].label;
                }
                return template;
              };
              NormalTooltip2.prototype._makeHtmlForValueTypes = function _makeHtmlForValueTypes(data, valueTypes) {
                return valueTypes.map(function(type) {
                  if (data[type]) {
                    return "<tr><td>" + type + '</td><td class="' + _const2["default"].CLASS_NAME_TOOLTIP_VALUE + '">' + data[type] + "</td></tr>";
                  }
                  return "";
                }).join("");
              };
              NormalTooltip2.prototype._makeSingleTooltipHtml = function _makeSingleTooltipHtml(chartType, indexes) {
                var groupIndex = indexes.groupIndex;
                var data = this._findTooltipData(chartType, indexes);
                var color = this._findTooltipColor(chartType, indexes, data);
                if (_predicate2["default"].isBoxplotChart(this.chartType) && (0, _isNumber2["default"])(indexes.outlierIndex)) {
                  data.outlierIndex = indexes.outlierIndex;
                }
                if (this.colorSpectrum) {
                  color = this.colorSpectrum.getColor(data.colorRatio || data.ratio);
                }
                data.color = color;
                data.chartType = this.chartType;
                data.cssText = "background-color: " + color;
                data = Object.assign({
                  suffix: this.suffix
                }, data);
                data.valueTypes = this._makeHtmlForValueTypes(data, ["x", "y", "r"]);
                return this.templateFunc(data.category, data, this.getRawCategory(groupIndex));
              };
              NormalTooltip2.prototype._findTooltipData = function _findTooltipData(chartType, indexes) {
                var chartData = this.data[chartType];
                var selectIndex = indexes.groupIndex;
                if (_predicate2["default"].isRadialChart(chartType) && chartData.length === selectIndex) {
                  selectIndex = 0;
                }
                return Object.assign({}, (0, _pick2["default"])(chartData, selectIndex, indexes.index));
              };
              NormalTooltip2.prototype._findTooltipColor = function _findTooltipColor(hoveredChartType, indexes, data) {
                var isBar = _predicate2["default"].isBarTypeChart(this.chartType);
                var isBoxplot = _predicate2["default"].isBoxplotChart(this.chartType);
                var colorByPoint = (isBar || isBoxplot) && this.dataProcessor.options.series.colorByPoint;
                var groupIndex = indexes.groupIndex;
                var seriesIndex = indexes.index;
                if (_predicate2["default"].isBulletChart(this.chartType)) {
                  seriesIndex = groupIndex;
                } else if (_predicate2["default"].isTreemapChart(this.chartType)) {
                  seriesIndex = data.tooltipColorIndex;
                }
                return colorByPoint ? DEFAULT_TOOLTIP_COLOR : this.tooltipColors[hoveredChartType][seriesIndex];
              };
              NormalTooltip2.prototype._setDefaultTooltipPositionOption = function _setDefaultTooltipPositionOption() {
                if (this.options.align) {
                  return;
                }
                if (this.isVertical) {
                  this.options.align = _const2["default"].TOOLTIP_DEFAULT_ALIGN_OPTION;
                } else {
                  this.options.align = _const2["default"].TOOLTIP_DEFAULT_HORIZONTAL_ALIGN_OPTION;
                }
              };
              NormalTooltip2.prototype._makeShowTooltipParams = function _makeShowTooltipParams(indexes, additionParams) {
                var legendIndex = indexes.index;
                var legendData = this.dataProcessor.getLegendItem(legendIndex);
                if (!legendData) {
                  return null;
                }
                var chartType = legendData.chartType, label = legendData.label;
                var params = Object.assign({
                  chartType,
                  legend: label,
                  legendIndex,
                  index: indexes.groupIndex
                }, additionParams);
                if (_predicate2["default"].isBoxplotChart(chartType) && (0, _isNumber2["default"])(indexes.outlierIndex)) {
                  params.outlierIndex = indexes.outlierIndex;
                }
                return params;
              };
              NormalTooltip2.prototype._makeTooltipDatum = function _makeTooltipDatum() {
                var legendLabel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
                var category = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
                var seriesItem = arguments[2];
                var tooltipLabel = seriesItem.tooltipLabel;
                var labelFormatter = this.labelFormatter;
                var tooltipDatum = {
                  legend: legendLabel,
                  label: tooltipLabel || (seriesItem.label ? seriesItem.label : ""),
                  category
                };
                if (labelFormatter) {
                  tooltipDatum = labelFormatter(seriesItem, tooltipDatum, "");
                }
                tooltipDatum.category = category;
                return Object.assign(tooltipDatum, seriesItem.pickValueMapForTooltip());
              };
              NormalTooltip2.prototype.makeTooltipData = function makeTooltipData() {
                var _this2 = this;
                var orgLegendLabels = this.dataProcessor.getLegendLabels();
                var isPivot = _predicate2["default"].isTreemapChart(this.chartType);
                var legendLabels = {};
                var tooltipData = {};
                if ((0, _isArray2["default"])(orgLegendLabels)) {
                  legendLabels[this.chartType] = orgLegendLabels;
                } else {
                  legendLabels = orgLegendLabels;
                }
                this.dataProcessor.eachBySeriesGroup(function(seriesGroup, groupIndex, chartType) {
                  chartType = chartType || _this2.chartType;
                  var isBulletChart = _predicate2["default"].isBulletChart(chartType);
                  var data = seriesGroup.map(function(seriesItem, index) {
                    var category = _this2.dataProcessor.makeTooltipCategory(groupIndex, index, _this2.isVertical);
                    var legendIndex = isBulletChart ? groupIndex : index;
                    if (!seriesItem) {
                      return null;
                    }
                    return _this2._makeTooltipDatum(legendLabels[chartType][legendIndex], category, seriesItem);
                  });
                  if (!tooltipData[chartType]) {
                    tooltipData[chartType] = [];
                  }
                  tooltipData[chartType].push(data);
                }, isPivot);
                return tooltipData;
              };
              return NormalTooltip2;
            }(_tooltipBase2["default"]);
            _singleTooltipMixer2["default"].mixin(NormalTooltip);
            function normalTooltipFactory(params) {
              return new NormalTooltip(params);
            }
            normalTooltipFactory.componentType = "tooltip";
            normalTooltipFactory.NormalTooltip = NormalTooltip;
          },
          /* 90 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _raphael = __webpack_require__(4);
            var _raphael2 = _interopRequireDefault(_raphael);
            var _objectUtil = __webpack_require__(55);
            var _objectUtil2 = _interopRequireDefault(_objectUtil);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _domHandler = __webpack_require__(24);
            var _domHandler2 = _interopRequireDefault(_domHandler);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var TooltipBase = function() {
              function TooltipBase2(params) {
                _classCallCheck(this, TooltipBase2);
                var isPieChart = _predicate2["default"].isPieChart(params.chartType);
                this.chartType = params.chartType;
                this.chartTypes = params.chartTypes;
                this.dataProcessor = params.dataProcessor;
                this.options = params.options;
                this.colors = params.colors;
                this.theme = params.theme;
                this.originalTheme = _objectUtil2["default"].deepCopy(params.theme);
                this.isVertical = params.isVertical;
                this.eventBus = params.eventBus;
                this.labelTheme = params.labelTheme;
                this.xAxisType = params.xAxisType;
                this.dateFormat = params.dateFormat;
                this.labelFormatter = params.labelFormatter;
                this.className = "tui-chart-tooltip-area";
                this.tooltipContainer = null;
                this.suffix = this.options.suffix ? "&nbsp;" + this.options.suffix : "";
                this.templateFunc = this.options.template || this._makeTooltipHtml.bind(this);
                this.animationTime = isPieChart ? _const2["default"].TOOLTIP_PIE_ANIMATION_TIME : _const2["default"].TOOLTIP_ANIMATION_TIME;
                this.data = [];
                this.layout = null;
                this.dimensionMap = null;
                this.positionMap = null;
                this.drawingType = _const2["default"].COMPONENT_TYPE_DOM;
                this._setDefaultTooltipPositionOption();
                this._saveOriginalPositionOptions();
                this._attachToEventBus();
              }
              TooltipBase2.prototype.presetForChangeData = function presetForChangeData() {
                var theme = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.theme;
                this.theme = theme;
                this.originalTheme = _objectUtil2["default"].deepCopy(theme);
              };
              TooltipBase2.prototype._attachToEventBus = function _attachToEventBus() {
                this.eventBus.on({
                  showTooltip: this.onShowTooltip,
                  hideTooltip: this.onHideTooltip
                }, this);
                if (this.onShowTooltipContainer) {
                  this.eventBus.on({
                    showTooltipContainer: this.onShowTooltipContainer,
                    hideTooltipContainer: this.onHideTooltipContainer
                  }, this);
                }
              };
              TooltipBase2.prototype._makeTooltipHtml = function _makeTooltipHtml() {
              };
              TooltipBase2.prototype._setDefaultTooltipPositionOption = function _setDefaultTooltipPositionOption() {
              };
              TooltipBase2.prototype._saveOriginalPositionOptions = function _saveOriginalPositionOptions() {
                this.orgPositionOptions = {
                  align: this.options.align,
                  offset: this.options.offset
                };
              };
              TooltipBase2.prototype.makeLineLegendIcon = function makeLineLegendIcon(iconElement) {
                var iconElementLength = iconElement.length;
                for (var i = 0; i < iconElementLength; i += 1) {
                  var icon = iconElement[i];
                  var strokeColor = icon.style["background-color"];
                  var paper = (0, _raphael2["default"])(icon, 10, 10);
                  var line = paper.path(_const2["default"].LEGEND_LINE_ICON_PATH);
                  icon.style["background-color"] = "";
                  line.attr({
                    stroke: strokeColor,
                    "stroke-width": 2,
                    "stroke-opacity": 1
                  });
                }
              };
              TooltipBase2.prototype.makeTooltipData = function makeTooltipData() {
              };
              TooltipBase2.prototype._setDataForRendering = function _setDataForRendering(data) {
                this.layout = data.layout;
                this.dimensionMap = data.dimensionMap;
                this.positionMap = data.positionMap;
              };
              TooltipBase2.prototype.render = function render(data) {
                var el = data.paper;
                _domHandler2["default"].addClass(el, this.className);
                this._setDataForRendering(data);
                this.data = this.makeTooltipData();
                this.tooltipColors = this.makeTooltipLegendColor(data.checkedLegends);
                _renderUtil2["default"].renderPosition(el, this.layout.position);
                this.tooltipContainer = el;
                return el;
              };
              TooltipBase2.prototype.rerender = function rerender(data) {
                this.resize(data);
                this.data = this.makeTooltipData();
                this.tooltipColors = this.makeTooltipLegendColor(data.checkedLegends);
              };
              TooltipBase2.prototype.makeTooltipLegendColor = function makeTooltipLegendColor(checkedLegends) {
                var _this = this;
                var colors = {};
                if (checkedLegends) {
                  Object.keys(this.theme).forEach(function(themeKey) {
                    if (!colors[themeKey]) {
                      colors[themeKey] = [];
                    }
                    (checkedLegends[themeKey] || []).forEach(function(checked, index) {
                      if (checked) {
                        colors[themeKey].push(_this.theme[themeKey].colors[index]);
                      }
                    });
                  });
                }
                return colors;
              };
              TooltipBase2.prototype.resize = function resize(data) {
                this._setDataForRendering(data);
                _renderUtil2["default"].renderPosition(this.tooltipContainer, this.layout.position);
                if (this.positionModel) {
                  this.positionModel.updateBound(this.layout);
                }
              };
              TooltipBase2.prototype.zoom = function zoom() {
                this.data = this.makeTooltipData();
              };
              TooltipBase2.prototype._getTooltipElement = function _getTooltipElement() {
                if (!this.tooltipElement) {
                  var tooltipElement = this.tooltipElement = _domHandler2["default"].create("DIV", "tui-chart-tooltip");
                  _domHandler2["default"].append(this.tooltipContainer, tooltipElement);
                }
                return this.tooltipElement;
              };
              TooltipBase2.prototype.onShowTooltip = function onShowTooltip(params) {
                var tooltipElement = this._getTooltipElement();
                var isScatterCombo = _predicate2["default"].isComboChart(this.chartType) && _predicate2["default"].isScatterChart(params.chartType);
                var prevPosition = void 0;
                if ((!_predicate2["default"].isChartToDetectMouseEventOnSeries(params.chartType) || isScatterCombo) && tooltipElement.offsetWidth) {
                  prevPosition = {
                    left: tooltipElement.offsetLeft,
                    top: tooltipElement.offsetTop
                  };
                }
                this._showTooltip(tooltipElement, params, prevPosition);
              };
              TooltipBase2.prototype.getTooltipDimension = function getTooltipDimension(_ref) {
                var offsetWidth = _ref.offsetWidth, offsetHeight = _ref.offsetHeight;
                return {
                  width: offsetWidth,
                  height: offsetHeight
                };
              };
              TooltipBase2.prototype._moveToPosition = function _moveToPosition(tooltipElement, position, prevPosition) {
                if (prevPosition) {
                  this._slideTooltip(tooltipElement, prevPosition, position);
                } else {
                  _renderUtil2["default"].renderPosition(tooltipElement, position);
                }
              };
              TooltipBase2.prototype._slideTooltip = function _slideTooltip(tooltipElement, prevPosition, position) {
                var moveTop = position.top - prevPosition.top;
                var moveLeft = position.left - prevPosition.left;
                _renderUtil2["default"].cancelAnimation(this.slidingAnimation);
                this.slidingAnimation = _renderUtil2["default"].startAnimation(this.animationTime, function(ratio) {
                  var left = moveLeft * ratio;
                  var top = moveTop * ratio;
                  tooltipElement.style.left = prevPosition.left + left + "px";
                  tooltipElement.style.top = prevPosition.top + top + "px";
                });
              };
              TooltipBase2.prototype.onHideTooltip = function onHideTooltip(prevFound, options) {
                var tooltipElement = this._getTooltipElement();
                this._hideTooltip(tooltipElement, prevFound, options);
              };
              TooltipBase2.prototype.setAlign = function setAlign(align) {
                this.options.align = align;
                if (this.positionModel) {
                  this.positionModel.updateOptions(this.options);
                }
              };
              TooltipBase2.prototype._updateOffsetOption = function _updateOffsetOption(offset) {
                this.options.offset = offset;
                if (this.positionModel) {
                  this.positionModel.updateOptions(this.options);
                }
              };
              TooltipBase2.prototype.setOffset = function setOffset(offset) {
                var offsetOption = Object.assign({}, this.options.offset);
                if ((0, _isExisty2["default"])(offset.x)) {
                  offsetOption.x = offset.x;
                }
                if ((0, _isExisty2["default"])(offset.y)) {
                  offsetOption.y = offset.y;
                }
                this._updateOffsetOption(Object.assign({}, this.options.offset, offsetOption));
              };
              TooltipBase2.prototype.setPosition = function setPosition(position) {
                var offsetOption = Object.assign({}, this.options.offset);
                if ((0, _isExisty2["default"])(position.left)) {
                  offsetOption.x = position.left;
                }
                if ((0, _isExisty2["default"])(position.top)) {
                  offsetOption.y = position.y;
                }
                this._updateOffsetOption(offsetOption);
              };
              TooltipBase2.prototype.resetAlign = function resetAlign() {
                var align = this.orgPositionOptions.align;
                this.options.align = align;
                if (this.positionModel) {
                  this.positionModel.updateOptions(this.options);
                }
              };
              TooltipBase2.prototype.resetOffset = function resetOffset() {
                this.options.offset = this.orgPositionOptions.offset;
                this._updateOffsetOption(this.options.offset);
              };
              TooltipBase2.prototype.getRawCategory = function getRawCategory(index, format) {
                var axis = this.isVertical ? "x" : "y";
                var categories = this.dataProcessor.categoriesMap ? this.dataProcessor.categoriesMap[axis] : null;
                var rawCategory = "";
                if (categories) {
                  rawCategory = categories[index];
                }
                if (format) {
                  rawCategory = _renderUtil2["default"].formatDate(rawCategory, format);
                }
                return rawCategory;
              };
              return TooltipBase2;
            }();
            exports2["default"] = TooltipBase;
          },
          /* 91 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _domHandler = __webpack_require__(24);
            var _domHandler2 = _interopRequireDefault(_domHandler);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            exports2["default"] = {
              /**
               * Set data indexes.
               * @param {HTMLElement} elTooltip tooltip element
               * @param {{groupIndex: number, index:number}} indexes indexes
               * @private
               */
              _setIndexesCustomAttribute: function _setIndexesCustomAttribute(elTooltip, indexes) {
                elTooltip.setAttribute("data-groupIndex", indexes.groupIndex);
                elTooltip.setAttribute("data-index", indexes.index);
              },
              /**
               * Get data indexes
               * @param {HTMLElement} elTooltip tooltip element
               * @returns {{groupIndex: number, index: number}} indexes
               * @private
               */
              _getIndexesCustomAttribute: function _getIndexesCustomAttribute(elTooltip) {
                var groupIndex = elTooltip.getAttribute("data-groupIndex");
                var index = elTooltip.getAttribute("data-index");
                var indexes = null;
                if (!(0, _isNull2["default"])(groupIndex) && !(0, _isNull2["default"])(index)) {
                  indexes = {
                    groupIndex: parseInt(groupIndex, 10),
                    index: parseInt(index, 10)
                  };
                }
                return indexes;
              },
              /**
               * Set showed custom attribute.
               * @param {HTMLElement} elTooltip tooltip element
               * @param {boolean} status whether showed or not
               * @private
               */
              _setShowedCustomAttribute: function _setShowedCustomAttribute(elTooltip, status) {
                elTooltip.setAttribute("data-showed", status);
              },
              /**
               * Whether showed tooltip or not.
               * @param {HTMLElement} elTooltip tooltip element
               * @returns {boolean} whether showed tooltip or not
               * @private
               */
              _isShowedTooltip: function _isShowedTooltip(elTooltip) {
                var isShowed = elTooltip.getAttribute("data-showed");
                return isShowed === "true" || isShowed === true;
              },
              /**
               * Make tooltip position for bullet chart
               * @param {object} params - mouse position
               * @returns {object} - position of single tooltip
               * @private
               */
              _makeTooltipPositionForBulletChart: function _makeTooltipPositionForBulletChart(_ref) {
                var mousePosition = _ref.mousePosition;
                var tooltipAreaPosition = this.layout.position;
                return {
                  left: mousePosition.left - tooltipAreaPosition.left,
                  top: mousePosition.top - tooltipAreaPosition.top
                };
              },
              /**
               * Make left position of not bar chart.
               * @param {number} baseLeft base left
               * @param {string} alignOption align option
               * @param {number} minusWidth minus width
               * @param {number} lineGap line gap
               * @returns {number} left position value
               * @private
               */
              _makeLeftPositionOfNotBarChart: function _makeLeftPositionOfNotBarChart(baseLeft, alignOption, minusWidth, lineGap) {
                var left = baseLeft;
                var offsetNegative = minusWidth || 0;
                var lineGapOffset = lineGap || _const2["default"].TOOLTIP_GAP;
                if (alignOption.indexOf("left") > -1) {
                  left -= offsetNegative + lineGapOffset;
                } else if (alignOption.indexOf("center") > -1 && offsetNegative) {
                  left -= offsetNegative / 2;
                } else {
                  left += lineGapOffset;
                }
                return left;
              },
              /**
               * Make top position of not bar chart.
               * @param {number} baseTop base top
               * @param {string} alignOption align option
               * @param {number} tooltipHeight tooltip height
               * @param {number} lineGap line gap
               * @returns {number} top position value
               * @private
               */
              _makeTopPositionOfNotBarChart: function _makeTopPositionOfNotBarChart(baseTop, alignOption, tooltipHeight, lineGap) {
                var top = baseTop;
                var offsetNegative = tooltipHeight || 0;
                if (alignOption.indexOf("bottom") > -1) {
                  top += offsetNegative + lineGap;
                } else if (alignOption.indexOf("middle") > -1 && offsetNegative) {
                  top += offsetNegative / 2;
                } else {
                  top -= offsetNegative + _const2["default"].TOOLTIP_GAP;
                }
                return top;
              },
              /**
               * Make tooltip position for not bar chart.
               * @param {object} params parameters
               *      @param {{bound: object}} params.data graph information
               *      @param {{width: number, height: number}} params.dimension tooltip dimension
               *      @param {string} params.alignOption position option (ex: 'left top')
               * @returns {{top: number, left: number}} position
               * @private
               */
              _makeTooltipPositionForNotBarChart: function _makeTooltipPositionForNotBarChart(params) {
                var bound = params.bound, positionOption = params.positionOption, dimension = params.dimension, _params$alignOption = params.alignOption, alignOption = _params$alignOption === void 0 ? "" : _params$alignOption;
                var minusWidth = dimension.width - (bound.width || 0);
                var lineGap = bound.width ? 0 : _const2["default"].TOOLTIP_GAP;
                var tooltipHeight = dimension.height;
                var baseLeft = bound.left - this.layout.position.left + positionOption.left;
                var baseTop = bound.top - this.layout.position.top + positionOption.top - _const2["default"].TOOLTIP_GAP;
                return {
                  left: this._makeLeftPositionOfNotBarChart(baseLeft, alignOption, minusWidth, lineGap),
                  top: this._makeTopPositionOfNotBarChart(baseTop, alignOption, tooltipHeight, lineGap)
                };
              },
              /**
               * Make tooltip position to event position.
               * @param {object} params parameters
               *      @param {{left: number, top: number}} params.bound bound
               *      @param {{left: number, top: number}} params.mousePosition mouse position
               * @returns {{top: number, left: number}} position
               * @private
               */
              _makeTooltipPositionToMousePosition: function _makeTooltipPositionToMousePosition(params) {
                if (!params.bound) {
                  params.bound = params.bound || {};
                  Object.assign(params.bound, params.mousePosition);
                }
                return this._makeTooltipPositionForNotBarChart(params);
              },
              /**
               * Make left position for bar chart.
               * @param {number} baseLeft base left
               * @param {string} alignOption align option
               * @param {number} tooltipWidth tooltip width
               * @returns {number} left position value
               * @private
               */
              _makeLeftPositionForBarChart: function _makeLeftPositionForBarChart(baseLeft, alignOption, tooltipWidth) {
                var left = baseLeft;
                if (alignOption.indexOf("left") > -1) {
                  left -= tooltipWidth;
                } else if (alignOption.indexOf("center") > -1) {
                  left -= tooltipWidth / 2;
                } else {
                  left += _const2["default"].TOOLTIP_GAP;
                }
                return left;
              },
              /**
               * Make top position for bar chart.
               * @param {number} baseTop base top
               * @param {string} alignOption align option
               * @param {number} minusHeight minus width
               * @returns {number} top position value
               * @private
               */
              _makeTopPositionForBarChart: function _makeTopPositionForBarChart(baseTop, alignOption, minusHeight) {
                var top = baseTop;
                if (alignOption.indexOf("top") > -1) {
                  top -= minusHeight;
                } else if (alignOption.indexOf("middle") > -1) {
                  top -= minusHeight / 2;
                }
                return top;
              },
              /**
               * Make tooltip position for bar chart.
               * @param {object} params parameters
               *      @param {{bound: object}} params.data graph information
               *      @param {{width: number, height: number}} params.dimension tooltip dimension
               *      @param {string} params.alignOption position option (ex: 'left top')
               * @returns {{top: number, left: number}} position
               * @private
               */
              _makeTooltipPositionForBarChart: function _makeTooltipPositionForBarChart(params) {
                var position = this.layout.position;
                var bound = params.bound, positionOption = params.positionOption, dimension = params.dimension, _params$alignOption2 = params.alignOption, alignOption = _params$alignOption2 === void 0 ? "" : _params$alignOption2;
                var minusHeight = dimension.height - (bound.height || 0);
                var tooltipWidth = dimension.width;
                var baseLeft = bound.left + bound.width + positionOption.left - position.left;
                var baseTop = bound.top + positionOption.top - position.top;
                return {
                  left: this._makeLeftPositionForBarChart(baseLeft, alignOption, tooltipWidth),
                  top: this._makeTopPositionForBarChart(baseTop, alignOption, minusHeight)
                };
              },
              /**
               * Make tooltip position for treemap chart.
               * @param {object} params parameters
               *      @param {{bound: object}} params.data - graph information
               *      @param {{width: number, height: number}} params.dimension - tooltip dimension
               * @returns {{left: number, top: number}}
               * @private
               */
              _makeTooltipPositionForTreemapChart: function _makeTooltipPositionForTreemapChart(params) {
                var position = this.layout.position;
                var bound = params.bound, positionOption = params.positionOption, dimension = params.dimension;
                var labelHeight = _renderUtil2["default"].getRenderedLabelHeight(_const2["default"].MAX_HEIGHT_WORD, this.labelTheme);
                return {
                  left: bound.left + (bound.width - dimension.width) / 2 + positionOption.left - position.left,
                  top: bound.top + bound.height / 2 - labelHeight + positionOption.top - position.top
                };
              },
              /**
               * Adjust position.
               * @param {{width: number, height: number}} tooltipDimension tooltip dimension
               * @param {{left: number, top: number}} position position
               * @returns {{left: number, top: number}} adjusted position
               * @private
               */
              _adjustPosition: function _adjustPosition(tooltipDimension, position) {
                var chartDimension = this.dimensionMap.chart;
                var areaPosition = this.layout.position;
                position.left = Math.max(position.left, -areaPosition.left);
                position.left = Math.min(position.left, chartDimension.width - areaPosition.left - tooltipDimension.width);
                position.top = Math.max(position.top, -areaPosition.top);
                position.top = Math.min(position.top, chartDimension.height - areaPosition.top - tooltipDimension.height);
                return position;
              },
              /**
               * Make tooltip position.
               * @param {object} params parameters
               *      @param {{left: number, top: number, width: number, height: number}} params.bound graph bound
               *      @param {string} params.chartType chart type
               *      @param {boolean} params.allowNegativeTooltip whether allow negative tooltip or not
               *      @param {{width: number, height: number}} params.dimension tooltip dimension
               *      @param {string} params.alignOption position option (ex: 'left top')
               * @returns {{top: number, left: number}} position
               * @private
               */
              _makeTooltipPosition: function _makeTooltipPosition(params) {
                var position = {};
                if (params.mousePosition) {
                  position = this._makeTooltipPositionToMousePosition(params);
                } else {
                  var sizeType = void 0, positionType = void 0, addPadding = void 0;
                  if (_predicate2["default"].isBarChart(params.chartType)) {
                    position = this._makeTooltipPositionForBarChart(params);
                    sizeType = "width";
                    positionType = "left";
                    addPadding = 1;
                  } else if (_predicate2["default"].isTreemapChart(params.chartType)) {
                    position = this._makeTooltipPositionForTreemapChart(params);
                  } else {
                    position = this._makeTooltipPositionForNotBarChart(params);
                    sizeType = "height";
                    positionType = "top";
                    addPadding = -1;
                  }
                  if (params.allowNegativeTooltip) {
                    position = this._moveToSymmetry(position, {
                      bound: params.bound,
                      indexes: params.indexes,
                      dimension: params.dimension,
                      chartType: params.chartType,
                      sizeType,
                      positionType,
                      addPadding
                    });
                  }
                  position = this._adjustPosition(params.dimension, position);
                }
                return position;
              },
              /**
               * Move to symmetry.
               * @param {{left: number, top: number}} position tooltip position
               * @param {object} params parameters
               *      @param {{left: number, top: number, width: number, height: number}} params.bound graph bound
               *      @param {string} params.id tooltip id
               *      @param {{width: number, height: number}} params.dimension tooltip dimension
               *      @param {string} params.sizeType size type (width or height)
               *      @param {string} params.positionType position type (left or top)
               *      @param {number} params.addPadding add padding
               * @returns {{left: number, top: number}} moved position
               * @private
               */
              _moveToSymmetry: function _moveToSymmetry(position, params) {
                var bound = params.bound, sizeType = params.sizeType, positionType = params.positionType, indexes = params.indexes;
                var seriesType = params.seriesType || params.chartType;
                var value = this.dataProcessor.getValue(indexes.groupIndex, indexes.index, seriesType);
                var direction = _predicate2["default"].isBarChart(this.chartType) ? -1 : 1;
                if (value < 0) {
                  var tooltipSize = params.dimension[sizeType];
                  var barSize = bound[sizeType];
                  var movedPositionValue = position[positionType] + (barSize + tooltipSize) * direction;
                  position[positionType] = movedPositionValue;
                }
                return position;
              },
              /**
               * Whether changed indexes or not.
               * @param {{groupIndex: number, index: number}} prevIndexes prev indexes
               * @param {{groupIndex: number, index: number}} indexes indexes
               * @returns {boolean} whether changed or not
               * @private
               */
              _isChangedIndexes: function _isChangedIndexes(prevIndexes, indexes) {
                return !!prevIndexes && (prevIndexes.groupIndex !== indexes.groupIndex || prevIndexes.index !== indexes.index);
              },
              /**
               * Show tooltip.
               * @param {HTMLElement} elTooltip tooltip element
               * @param {{indexes: {groupIndex: number, index: number}, bound: object}} params tooltip data
               * @param {{left: number, top: number}} prevPosition prev position
               * @private
               */
              _showTooltip: function _showTooltip(elTooltip, params, prevPosition) {
                var boundingClientRect = this.tooltipContainer.parentNode.getBoundingClientRect();
                var indexes = params.indexes;
                var prevIndexes = this._getIndexesCustomAttribute(elTooltip);
                var offset = this.options.offset || {};
                var positionOption = {};
                var prevChartType = elTooltip && elTooltip.getAttribute("data-chart-type");
                if (!params.bound && params.mousePosition) {
                  params.bound = {
                    left: params.mousePosition.left - boundingClientRect.left + _const2["default"].CHART_PADDING,
                    top: params.mousePosition.top - boundingClientRect.top + _const2["default"].CHART_PADDING
                  };
                }
                if (this._isChangedIndexes(prevIndexes, indexes) || prevChartType !== params.chartType) {
                  this.eventBus.fire("hoverOffSeries", prevIndexes, prevChartType);
                }
                elTooltip.innerHTML = this._makeSingleTooltipHtml(params.seriesType || params.chartType, indexes);
                if (params.chartType === "line") {
                  this.makeLineLegendIcon(elTooltip.querySelectorAll(".tui-chart-legend-rect.line"));
                }
                elTooltip.setAttribute("data-chart-type", params.chartType);
                this._setIndexesCustomAttribute(elTooltip, indexes);
                this._setShowedCustomAttribute(elTooltip, true);
                this._fireBeforeShowTooltipPublicEvent(indexes, params.silent);
                _domHandler2["default"].addClass(elTooltip, "show");
                positionOption.left = offset.x || 0;
                positionOption.top = offset.y || 0;
                var position = this._makeTooltipPosition(Object.assign({
                  dimension: this.getTooltipDimension(elTooltip),
                  positionOption,
                  alignOption: this.options.align || ""
                }, params));
                this._moveToPosition(elTooltip, position, prevPosition);
                this.eventBus.fire("hoverSeries", indexes, params.chartType);
                this._fireAfterShowTooltipPublicEvent(indexes, {
                  element: elTooltip,
                  position
                }, params.silent);
                delete params.silent;
              },
              /**
               * To call beforeShowTooltip callback of public event.
               * @param {{groupIndex: number, index: number}} indexes indexes
               * @param {boolean} [silent] - whether invoke a public beforeHideTooltip event or not
               * @private
               */
              _fireBeforeShowTooltipPublicEvent: function _fireBeforeShowTooltipPublicEvent(indexes, silent) {
                if (silent) {
                  return;
                }
                var params = this._makeShowTooltipParams(indexes);
                this.eventBus.fire(_const2["default"].PUBLIC_EVENT_PREFIX + "beforeShowTooltip", params);
              },
              /**
               * To call afterShowTooltip callback of public event.
               * @param {{groupIndex: number, index: number}} indexes indexes
               * @param {object} additionParams addition parameters
               * @param {boolean} [silent] - whether invoke a public beforeHideTooltip event or not
               * @private
               */
              _fireAfterShowTooltipPublicEvent: function _fireAfterShowTooltipPublicEvent(indexes, additionParams, silent) {
                if (silent) {
                  return;
                }
                var params = this._makeShowTooltipParams(indexes, additionParams);
                this.eventBus.fire(_const2["default"].PUBLIC_EVENT_PREFIX + "afterShowTooltip", params);
              },
              /**
               * Execute hiding tooltip.
               * @param {HTMLElement} tooltipElement tooltip element
               * @private
               */
              _executeHidingTooltip: function _executeHidingTooltip(tooltipElement) {
                _domHandler2["default"].removeClass(tooltipElement, "show");
                tooltipElement.removeAttribute("data-groupIndex");
                tooltipElement.removeAttribute("data-index");
                tooltipElement.style.cssText = "";
              },
              /**
               * Hide tooltip.
               * @param {HTMLElement} tooltipElement - tooltip element
               * @param {object} prevFoundData - data represented by tooltip elements
               * @param {{silent: {boolean}}} [options] - options for hiding a tooltip element
               * @private
               */
              _hideTooltip: function _hideTooltip(tooltipElement, prevFoundData, options) {
                var _this = this;
                var indexes = this._getIndexesCustomAttribute(tooltipElement);
                var chartType = tooltipElement.getAttribute("data-chart-type");
                var silent = !!(options && options.silent);
                if (_predicate2["default"].isChartToDetectMouseEventOnSeries(chartType)) {
                  this.eventBus.fire("hoverOffSeries", indexes, chartType);
                  this._fireBeforeHideTooltipPublicEvent(indexes, silent);
                  this._executeHidingTooltip(tooltipElement);
                } else if (chartType) {
                  this._setShowedCustomAttribute(tooltipElement, false);
                  this.eventBus.fire("hoverOffSeries", indexes, chartType);
                  if (this._isChangedIndexes(this.prevIndexes, indexes)) {
                    delete this.prevIndexes;
                  }
                  setTimeout(function() {
                    if (_this._isShowedTooltip(tooltipElement)) {
                      return;
                    }
                    _this._fireBeforeHideTooltipPublicEvent(indexes, silent);
                    _this._executeHidingTooltip(tooltipElement);
                  }, _const2["default"].HIDE_DELAY);
                }
              },
              /**
               * To call afterShowTooltip callback of public event.
               * @param {{groupIndex: number, index: number}} indexes indexes=
               * @param {boolean} [silent] - whether invoke a public beforeHideTooltip event or not
               * @private
               */
              _fireBeforeHideTooltipPublicEvent: function _fireBeforeHideTooltipPublicEvent(indexes, silent) {
                var params = void 0;
                if (silent) {
                  return;
                }
                this.eventBus.fire(_const2["default"].PUBLIC_EVENT_PREFIX + "beforeHideTooltip", params);
              },
              /**
               * On show tooltip container.
               */
              onShowTooltipContainer: function onShowTooltipContainer() {
                this.tooltipContainer.style.zIndex = _const2["default"].TOOLTIP_ZINDEX;
              },
              /**
               * On hide tooltip container.
               */
              onHideTooltipContainer: function onHideTooltipContainer() {
                this.tooltipContainer.style.zIndex = 0;
              },
              /**
               * Mix in.
               * @param {function} func target function
               * @ignore
               */
              mixin: function mixin(func) {
                Object.assign(func.prototype, this);
              }
            };
          },
          /* 92 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _templateMaker = __webpack_require__(93);
            var _templateMaker2 = _interopRequireDefault(_templateMaker);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var htmls = {
              HTML_DEFAULT_TEMPLATE: '<div class="tui-chart-default-tooltip">\n      <div class="tui-chart-tooltip-head {{ categoryVisible }}">{{ category }}</div>\n      <div class="tui-chart-tooltip-body">\n        <span class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></span>\n        <span>{{ legend }}</span>\n        <span class="tui-chart-tooltip-value">{{ label }}{{ suffix }}</span>\n      </div>\n    </div>',
              HTML_PIE_TEMPLATE: '<div class="tui-chart-default-tooltip">\n      <div class="tui-chart-tooltip-head {{ categoryVisible }}">{{ category }}</div>\n      <div class="tui-chart-tooltip-body">\n        <span class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></span>\n        <span>{{ legend }}</span>\n        <span class="tui-chart-tooltip-value">{{ ratioLabel }} ( {{ label }} {{ suffix }})</span>\n      </div>\n    </div>',
              HTML_COORDINATE_TYPE_CHART_TEMPLATE: '<div class="tui-chart-default-tooltip">\n    <div class="tui-chart-tooltip-head {{ categoryVisible }}">\n      <span class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></span>\n      {{ category }}\n    </div>\n    <div class="tui-chart-tooltip-body">\n      <span class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></span>\n      <span>{{ legend }}</span>\n      <span class="tui-chart-tooltip-value">{{ label }}</span>\n    </div>\n    <table class="tui-chart-tooltip-body">{{ valueTypes }}</table>\n  </div>',
              HTML_GROUP: '<div class="tui-chart-default-tooltip tui-chart-group-tooltip">\n    <div class="tui-chart-tooltip-head">{{ category }}</div>\n    <table class="tui-chart-tooltip-body">\n      {{ items }}\n    </table>\n  </div>',
              HTML_GROUP_TYPE: '\n  <tr>\n    <td colspan="3" class="tui-chart-tooltip-type">{{ type }}</div>\n  </tr>',
              HTML_GROUP_ITEM: '<tr>\n    <td><div class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></div></td>\n    <td>{{ legend }}</td>\n    <td class="tui-chart-tooltip-value">{{ value }} {{ suffix }}</td>\n  </tr>',
              GROUP_CSS_TEXT: "background-color:{{ color }}",
              HTML_MAP_CHART_DEFAULT_TEMPLATE: '<div class="tui-chart-default-tooltip">\n    <div class="tui-chart-tooltip-body">\n      <span class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></span>\n      <span>{{ name }}</span>\n      <span class="tui-chart-tooltip-value">{{ value }}{{ suffix }}</span>\n    </div>\n  </div>',
              HTML_HEATMAP_TEMPLATE: '<div class="tui-chart-default-tooltip">\n    <div class="tui-chart-tooltip-head {{ categoryVisible }}">{{ category }}</div>\n    <div class="tui-chart-tooltip-body">\n      <span class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></span>\n      <span>{{ label }}{{ suffix }}</span>\n    </div>\n  </div>',
              HTML_BOXPLOT_TEMPLATE: '<div class="tui-chart-default-tooltip">\n    <div class="tui-chart-tooltip-head {{ categoryVisible }}">{{ category }}</div>\n    <table class="tui-chart-tooltip-body">\n      <tr>\n        <td colspan="2">\n          <span class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></span>\n          {{ legend }}\n        </td>\n      </tr>\n      <tr>\n        <td>Maximum: </td>\n        <td class="tui-chart-tooltip-value">{{ maxLabel }} {{ suffix }}</td>\n      </tr>\n      <tr>\n        <td>Upper Quartile: </td>\n        <td class="tui-chart-tooltip-value">{{ uqLabel }} {{ suffix }}</td>\n      </tr>\n      <tr>\n        <td>Median: </td>\n        <td class="tui-chart-tooltip-value">{{ medianLabel }} {{ suffix }}</td>\n      </tr>\n      <tr>\n        <td>Lower Quartile: </td>\n        <td class="tui-chart-tooltip-value">{{ lqLabel }} {{ suffix }}</td>\n      </tr>\n      <tr>\n        <td>Minimum: </td>\n        <td class="tui-chart-tooltip-value">{{ minLabel }} {{ suffix }}</td>\n      </tr>\n    </table>\n  </div>',
              HTML_BOXPLOT_OUTLIER: '<div class="tui-chart-default-tooltip">\n    <div class="tui-chart-tooltip-head {{ categoryVisible }}">{{ category }}</div>\n      <div class="tui-chart-tooltip-body">\n        <span>{{ legend }}</span>\n      </div>\n      <div class="tui-chart-tooltip-body">\n        <span>Outlier: </span>\n        <span class="tui-chart-tooltip-value">{{ label }} {{ suffix }}</span>\n      </div>\n  </div>',
              HTML_BULLET_TEMPLATE: '<div class="tui-chart-default-tooltip">\n    <div class="tui-chart-tooltip-body {{ categoryVisible }}">\n      <span class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></span>\n      <span>{{ category }}</span>\n      <span class="tui-chart-tooltip-value">{{ label }} {{ suffix }}</span>\n    </div>\n  </div>'
            };
            exports2["default"] = {
              tplDefault: _templateMaker2["default"].template(htmls.HTML_DEFAULT_TEMPLATE),
              tplPieChart: _templateMaker2["default"].template(htmls.HTML_PIE_TEMPLATE),
              tplCoordinatetypeChart: _templateMaker2["default"].template(htmls.HTML_COORDINATE_TYPE_CHART_TEMPLATE),
              tplGroup: _templateMaker2["default"].template(htmls.HTML_GROUP),
              tplGroupType: _templateMaker2["default"].template(htmls.HTML_GROUP_TYPE),
              tplGroupItem: _templateMaker2["default"].template(htmls.HTML_GROUP_ITEM),
              tplGroupCssText: _templateMaker2["default"].template(htmls.GROUP_CSS_TEXT),
              tplMapChartDefault: _templateMaker2["default"].template(htmls.HTML_MAP_CHART_DEFAULT_TEMPLATE),
              tplHeatmapChart: _templateMaker2["default"].template(htmls.HTML_HEATMAP_TEMPLATE),
              tplBoxplotChartDefault: _templateMaker2["default"].template(htmls.HTML_BOXPLOT_TEMPLATE),
              tplBoxplotChartOutlier: _templateMaker2["default"].template(htmls.HTML_BOXPLOT_OUTLIER),
              tplBulletChartDefault: _templateMaker2["default"].template(htmls.HTML_BULLET_TEMPLATE)
            };
          },
          /* 93 */
          /***/
          function(module2, exports2) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            exports2["default"] = {
              /**
               * This is template maker.
               * @param {string} html html
               * @returns {function} template function
               * @eaxmple
               *
               *   var template = templateMaker.template('<span>{{ name }}</span>'),
               *       result = template({name: 'John');
               *   console.log(result); // <span>John</span>
               *
               */
              template: function template(html) {
                return function(data) {
                  var result = html;
                  Object.entries(data).forEach(function(_ref) {
                    var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
                    var regExp = new RegExp("{{\\s*" + key + "\\s*}}", "g");
                    result = result.replace(regExp, String(value).replace("$", "＄"));
                  });
                  return result;
                };
              }
            };
          },
          /* 94 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = groupTooltipFactory;
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _pluck = __webpack_require__(58);
            var _pluck2 = _interopRequireDefault(_pluck);
            var _tooltipBase = __webpack_require__(90);
            var _tooltipBase2 = _interopRequireDefault(_tooltipBase);
            var _groupTooltipPositionModel = __webpack_require__(95);
            var _groupTooltipPositionModel2 = _interopRequireDefault(_groupTooltipPositionModel);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _domHandler = __webpack_require__(24);
            var _domHandler2 = _interopRequireDefault(_domHandler);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _defaultTheme = __webpack_require__(53);
            var _defaultTheme2 = _interopRequireDefault(_defaultTheme);
            var _tooltipTemplate = __webpack_require__(92);
            var _tooltipTemplate2 = _interopRequireDefault(_tooltipTemplate);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var TOOLTIP_DEFAULT_GROUP_ALIGN_OPTION = _const2["default"].TOOLTIP_DEFAULT_GROUP_ALIGN_OPTION, TOOLTIP_DEFAULT_GROUP_HORIZONTAL_ALIGN_OPTION = _const2["default"].TOOLTIP_DEFAULT_GROUP_HORIZONTAL_ALIGN_OPTION, SERIES_EXPAND_SIZE = _const2["default"].SERIES_EXPAND_SIZE, PUBLIC_EVENT_PREFIX = _const2["default"].PUBLIC_EVENT_PREFIX;
            var GroupTooltip = function(_TooltipBase) {
              _inherits(GroupTooltip2, _TooltipBase);
              function GroupTooltip2(params) {
                _classCallCheck(this, GroupTooltip2);
                var _this = _possibleConstructorReturn(this, _TooltipBase.call(this, params));
                _this.prevIndex = null;
                _this.tickInterval = null;
                _this.isBullet = _predicate2["default"].isBulletChart(params.chartType);
                return _this;
              }
              GroupTooltip2.prototype._makeTooltipHtml = function _makeTooltipHtml(category, items, rawCategory, groupIndex) {
                var template = _tooltipTemplate2["default"].tplGroupItem;
                var cssTextTemplate = _tooltipTemplate2["default"].tplGroupCssText;
                var isBar = _predicate2["default"].isBarChart(this.chartType);
                var isBarType = _predicate2["default"].isBarTypeChart(this.chartType);
                var isBoxplot = _predicate2["default"].isBoxplotChart(this.chartType);
                var seriesOptions = this.dataProcessor.options.series;
                var colorByPoint = (isBarType || isBoxplot) && seriesOptions && seriesOptions.colorByPoint;
                var needReverse = !isBar && seriesOptions && seriesOptions.stack;
                var colors = this._makeColors(this.theme, groupIndex);
                var prevType = void 0;
                var itemsHtml = items.map(function(item, index) {
                  var type = item.type;
                  var typeVisible = type !== "data" && prevType !== type;
                  var itemHtml = "";
                  prevType = type;
                  if (!item.value) {
                    return null;
                  }
                  if (typeVisible) {
                    itemHtml = _tooltipTemplate2["default"].tplGroupType({
                      type
                    });
                  }
                  itemHtml += template(Object.assign({
                    cssText: cssTextTemplate({
                      color: colorByPoint ? "#aaa" : colors[index]
                    })
                  }, item));
                  return itemHtml;
                });
                if (needReverse) {
                  itemsHtml.reverse();
                }
                return _tooltipTemplate2["default"].tplGroup({
                  category,
                  items: itemsHtml.join("")
                });
              };
              GroupTooltip2.prototype._setDefaultTooltipPositionOption = function _setDefaultTooltipPositionOption() {
                if (this.options.align) {
                  return;
                }
                if (this.isVertical) {
                  this.options.align = TOOLTIP_DEFAULT_GROUP_ALIGN_OPTION;
                } else {
                  this.options.align = TOOLTIP_DEFAULT_GROUP_HORIZONTAL_ALIGN_OPTION;
                }
              };
              GroupTooltip2.prototype.render = function render(data) {
                var container = _tooltipBase2["default"].prototype.render.call(this, data);
                var chartDimension = this.dimensionMap.chart;
                var bound = this.layout;
                if (data.checkedLegends) {
                  this.theme = this._updateLegendTheme(data.checkedLegends);
                }
                this.positionModel = new _groupTooltipPositionModel2["default"](chartDimension, bound, this.isVertical, this.options);
                return container;
              };
              GroupTooltip2.prototype.rerender = function rerender(data) {
                _tooltipBase2["default"].prototype.rerender.call(this, data);
                this.prevIndex = null;
                if (data.checkedLegends) {
                  this.theme = this._updateLegendTheme(data.checkedLegends);
                }
              };
              GroupTooltip2.prototype.zoom = function zoom() {
                this.prevIndex = null;
                this.tickInterval = null;
                _tooltipBase2["default"].prototype.zoom.call(this);
              };
              GroupTooltip2.prototype._updateLegendTheme = function _updateLegendTheme(checkedLegends) {
                var _this2 = this;
                var colors = [];
                var chartTypes = Object.keys(this.originalTheme);
                chartTypes.forEach(function(chartType) {
                  var chartColors = _this2.originalTheme[chartType].colors;
                  chartColors.forEach(function(color, index) {
                    var _checkedLegends = checkedLegends[chartType] || checkedLegends;
                    if (_checkedLegends[index]) {
                      colors.push(color);
                    }
                  });
                });
                return {
                  colors
                };
              };
              GroupTooltip2.prototype.makeTooltipData = function makeTooltipData() {
                var _this3 = this;
                var length = this.dataProcessor.getCategoryCount(this.isVertical);
                return this.dataProcessor.getSeriesGroups().map(function(seriesGroup, index) {
                  var values = seriesGroup.map(function(item) {
                    return {
                      type: item.type || "data",
                      label: item.tooltipLabel || item.label
                    };
                  });
                  return {
                    category: _this3.dataProcessor.makeTooltipCategory(index, length - index, _this3.isVertical),
                    values
                  };
                });
              };
              GroupTooltip2.prototype._makeColors = function _makeColors(theme, groupIndex) {
                var colorIndex = 0;
                var legendLabels = this.dataProcessor.getLegendData();
                var colors = void 0, prevChartType = void 0;
                if (this.isBullet) {
                  return this.dataProcessor.getGraphColors()[groupIndex];
                }
                if (theme.colors) {
                  return theme.colors;
                }
                var defaultColors = _defaultTheme2["default"].series.colors.slice(0, legendLabels.length);
                return (0, _pluck2["default"])(legendLabels, "chartType").map(function(chartType) {
                  if (prevChartType !== chartType) {
                    colors = theme[chartType] ? theme[chartType].colors : defaultColors;
                    colorIndex = 0;
                  }
                  prevChartType = chartType;
                  var color = colors[colorIndex];
                  colorIndex += 1;
                  return color;
                });
              };
              GroupTooltip2.prototype._makeItemRenderingData = function _makeItemRenderingData(values, groupIndex) {
                var _this4 = this;
                var dataProcessor = this.dataProcessor, suffix = this.suffix;
                var colors = this._makeColors(this.theme, groupIndex);
                return values.map(function(data, index) {
                  var item = {
                    value: data.label,
                    type: data.type,
                    suffix,
                    legend: "",
                    color: colors[index]
                  };
                  var legendLabel = void 0;
                  if (_this4.isBullet) {
                    legendLabel = dataProcessor.getLegendItem(groupIndex);
                  } else {
                    legendLabel = dataProcessor.getLegendItem(index);
                    item.legend = legendLabel.label;
                  }
                  item.chartType = legendLabel.chartType;
                  return item;
                });
              };
              GroupTooltip2.prototype._makeGroupTooltipHtml = function _makeGroupTooltipHtml(groupIndex) {
                var data = this.data[groupIndex];
                var htmlString = "";
                if (data) {
                  var items = this._makeItemRenderingData(data.values, groupIndex);
                  htmlString = this.templateFunc(data.category, items, this.getRawCategory(groupIndex), groupIndex);
                }
                return htmlString;
              };
              GroupTooltip2.prototype._getTooltipSectorElement = function _getTooltipSectorElement() {
                if (!this.groupTooltipSector) {
                  var groupTooltipSector = this.groupTooltipSector = _domHandler2["default"].create("DIV", "tui-chart-group-tooltip-sector");
                  _domHandler2["default"].append(this.tooltipContainer, groupTooltipSector);
                }
                return this.groupTooltipSector;
              };
              GroupTooltip2.prototype._makeVerticalTooltipSectorBound = function _makeVerticalTooltipSectorBound(height, range, isLine) {
                var width = void 0;
                if (isLine) {
                  width = 1;
                } else {
                  width = range.end - range.start;
                }
                return {
                  dimension: {
                    width,
                    height
                  },
                  position: {
                    left: range.start + this.tickInterval / 2,
                    top: SERIES_EXPAND_SIZE
                  }
                };
              };
              GroupTooltip2.prototype._makeHorizontalTooltipSectorBound = function _makeHorizontalTooltipSectorBound(width, range) {
                return {
                  dimension: {
                    width,
                    height: range.end - range.start
                  },
                  position: {
                    left: SERIES_EXPAND_SIZE,
                    top: range.start
                  }
                };
              };
              GroupTooltip2.prototype._makeTooltipSectorBound = function _makeTooltipSectorBound(size, range, isVertical, isLine) {
                if (isVertical) {
                  return this._makeVerticalTooltipSectorBound(size, range, isLine);
                }
                return this._makeHorizontalTooltipSectorBound(size, range);
              };
              GroupTooltip2.prototype._showTooltipSector = function _showTooltipSector(size, range, isVertical, index, isMoving) {
                var groupTooltipSector = this._getTooltipSectorElement();
                var isLine = range.start === range.end;
                var bound = this._makeTooltipSectorBound(size, range, isVertical, isLine);
                if (isLine) {
                  this.eventBus.fire("showGroupTooltipLine", bound);
                } else {
                  _renderUtil2["default"].renderDimension(groupTooltipSector, bound.dimension);
                  _renderUtil2["default"].renderPosition(groupTooltipSector, bound.position);
                  _domHandler2["default"].addClass(groupTooltipSector, "show");
                }
                if (isMoving) {
                  index -= 1;
                }
                this.eventBus.fire("showGroupAnimation", index);
              };
              GroupTooltip2.prototype._hideTooltipSector = function _hideTooltipSector(index) {
                var groupTooltipSector = this._getTooltipSectorElement();
                if (!_domHandler2["default"].hasClass(groupTooltipSector, "show")) {
                  this.eventBus.fire("hideGroupTooltipLine");
                } else {
                  _domHandler2["default"].removeClass(groupTooltipSector, "show");
                }
                this.eventBus.fire("hideGroupAnimation", index);
                this.eventBus.fire("hideGroupTooltipLine");
              };
              GroupTooltip2.prototype._showTooltip = function _showTooltip(elTooltip, params, prevPosition) {
                if (!(0, _isNull2["default"])(this.prevIndex)) {
                  this.eventBus.fire("hideGroupAnimation", this.prevIndex);
                }
                if ((0, _isNull2["default"])(this.tickInterval)) {
                  this.tickInterval = params.tickInterval;
                }
                elTooltip.innerHTML = this._makeGroupTooltipHtml(params.index);
                this._fireBeforeShowTooltipPublicEvent(params.index, params.range, params.silent);
                if (document.getElementsByClassName) {
                  this.makeLineLegendIcon(elTooltip.querySelectorAll(".tui-chart-legend-rect.line"));
                }
                _domHandler2["default"].addClass(elTooltip, "show");
                this._showTooltipSector(params.size, params.range, params.isVertical, params.index, params.isMoving);
                var dimension = this.getTooltipDimension(elTooltip);
                var position = this.positionModel.calculatePosition(dimension, params.range);
                this._moveToPosition(elTooltip, position, prevPosition);
                this._fireAfterShowTooltipPublicEvent(params.index, params.range, {
                  element: elTooltip,
                  position
                }, params.silent);
                this.prevIndex = params.index;
              };
              GroupTooltip2.prototype._fireBeforeShowTooltipPublicEvent = function _fireBeforeShowTooltipPublicEvent(index, range, silent) {
                if (silent) {
                  return;
                }
                this.eventBus.fire(PUBLIC_EVENT_PREFIX + "beforeShowTooltip", {
                  chartType: this.chartType,
                  index,
                  range
                });
              };
              GroupTooltip2.prototype._fireAfterShowTooltipPublicEvent = function _fireAfterShowTooltipPublicEvent(index, range, additionParams, silent) {
                if (silent) {
                  return;
                }
                this.eventBus.fire(PUBLIC_EVENT_PREFIX + "afterShowTooltip", Object.assign({
                  chartType: this.chartType,
                  index,
                  range
                }, additionParams));
              };
              GroupTooltip2.prototype._hideTooltip = function _hideTooltip(tooltipElement, prevFoundIndex, options) {
                var silent = !!(options && options.silent);
                this.prevIndex = null;
                this._fireBeforeHideTooltipPublicEvent(prevFoundIndex, silent);
                this._hideTooltipSector(prevFoundIndex);
                _domHandler2["default"].removeClass(tooltipElement, "show");
                tooltipElement.style.cssText = "";
              };
              GroupTooltip2.prototype._fireBeforeHideTooltipPublicEvent = function _fireBeforeHideTooltipPublicEvent(index, silent) {
                if (silent) {
                  return;
                }
                this.eventBus.fire(PUBLIC_EVENT_PREFIX + "beforeHideTooltip", {
                  chartType: this.chartType,
                  index
                });
              };
              return GroupTooltip2;
            }(_tooltipBase2["default"]);
            function groupTooltipFactory(params) {
              return new GroupTooltip(params);
            }
            groupTooltipFactory.componentType = "tooltip";
            groupTooltipFactory.GroupTooltip = GroupTooltip;
          },
          /* 95 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var GroupTooltipPositionModel = function() {
              function GroupTooltipPositionModel2(chartDimension, areaBound, isVertical, options) {
                _classCallCheck(this, GroupTooltipPositionModel2);
                this.chartDimension = chartDimension;
                this.areaBound = areaBound;
                this.isVertical = isVertical;
                this.options = options;
                this.positions = {};
                this._setData(chartDimension, areaBound, isVertical, options);
              }
              GroupTooltipPositionModel2.prototype._getHorizontalDirection = function _getHorizontalDirection() {
                var alignOption = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
                var direction = void 0;
                if (alignOption.indexOf("left") > -1) {
                  direction = _const2["default"].TOOLTIP_DIRECTION_BACKWARD;
                } else if (alignOption.indexOf("center") > -1) {
                  direction = _const2["default"].TOOLTIP_DIRECTION_CENTER;
                } else {
                  direction = _const2["default"].TOOLTIP_DIRECTION_FORWARD;
                }
                return direction;
              };
              GroupTooltipPositionModel2.prototype._makeVerticalData = function _makeVerticalData(chartDimension, areaBound, alignOption) {
                var hDirection = this._getHorizontalDirection(alignOption);
                return {
                  positionType: "left",
                  sizeType: "width",
                  direction: hDirection,
                  areaPosition: areaBound.position.left,
                  areaSize: areaBound.dimension.width,
                  chartSize: chartDimension.width,
                  basePosition: _const2["default"].SERIES_EXPAND_SIZE
                };
              };
              GroupTooltipPositionModel2.prototype._getVerticalDirection = function _getVerticalDirection(alignOption) {
                var direction = void 0;
                alignOption = alignOption || "";
                if (alignOption.indexOf("top") > -1) {
                  direction = _const2["default"].TOOLTIP_DIRECTION_BACKWARD;
                } else if (alignOption.indexOf("bottom") > -1) {
                  direction = _const2["default"].TOOLTIP_DIRECTION_FORWARD;
                } else {
                  direction = _const2["default"].TOOLTIP_DIRECTION_CENTER;
                }
                return direction;
              };
              GroupTooltipPositionModel2.prototype._makeHorizontalData = function _makeHorizontalData(chartDimension, areaBound, alignOption) {
                var vDirection = this._getVerticalDirection(alignOption);
                return {
                  positionType: "top",
                  sizeType: "height",
                  direction: vDirection,
                  areaPosition: areaBound.position.top,
                  areaSize: areaBound.dimension.height,
                  chartSize: chartDimension.height,
                  basePosition: _const2["default"].SERIES_EXPAND_SIZE
                };
              };
              GroupTooltipPositionModel2.prototype._setData = function _setData(chartDimension, areaBound, isVertical, options) {
                var verticalData = this._makeVerticalData(chartDimension, areaBound, options.align);
                var horizontalData = this._makeHorizontalData(chartDimension, areaBound, options.align);
                var offset = options.offset || {};
                if (isVertical) {
                  this.mainData = verticalData;
                  this.subData = horizontalData;
                } else {
                  this.mainData = horizontalData;
                  this.subData = verticalData;
                }
                this.positionOption = {};
                this.positionOption.left = offset.x || 0;
                this.positionOption.top = offset.y || 0;
                this.positions = {};
              };
              GroupTooltipPositionModel2.prototype._calculateMainPositionValue = function _calculateMainPositionValue(tooltipSize, range, data) {
                var isLine = range.start === range.end;
                var lineTypePadding = 9;
                var otherTypePadding = 5;
                var padding = isLine ? lineTypePadding : otherTypePadding;
                var value = data.basePosition;
                if (data.direction === _const2["default"].TOOLTIP_DIRECTION_FORWARD) {
                  value += range.end + padding;
                } else if (data.direction === _const2["default"].TOOLTIP_DIRECTION_BACKWARD) {
                  value += range.start - tooltipSize - padding;
                } else if (isLine) {
                  value += range.start - tooltipSize / 2;
                } else {
                  value += range.start + (range.end - range.start - tooltipSize) / 2;
                }
                return value;
              };
              GroupTooltipPositionModel2.prototype._calculateSubPositionValue = function _calculateSubPositionValue(tooltipSize, data) {
                var middle = data.areaSize / 2;
                var value = void 0;
                if (data.direction === _const2["default"].TOOLTIP_DIRECTION_FORWARD) {
                  value = middle + data.basePosition;
                } else if (data.direction === _const2["default"].TOOLTIP_DIRECTION_BACKWARD) {
                  value = middle - tooltipSize + data.basePosition;
                } else {
                  value = middle - tooltipSize / 2 + data.basePosition;
                }
                return value;
              };
              GroupTooltipPositionModel2.prototype._makePositionValueDiff = function _makePositionValueDiff(value, tooltipSize, data) {
                return value + data.areaPosition + tooltipSize - data.chartSize;
              };
              GroupTooltipPositionModel2.prototype._adjustBackwardPositionValue = function _adjustBackwardPositionValue(value, range, tooltipSize, data) {
                var changedValue = void 0;
                if (value < -data.areaPosition) {
                  changedValue = this._calculateMainPositionValue(tooltipSize, range, {
                    direction: _const2["default"].TOOLTIP_DIRECTION_FORWARD,
                    basePosition: data.basePosition
                  });
                  if (this._makePositionValueDiff(changedValue, tooltipSize, data) > 0) {
                    value = -data.areaPosition;
                  } else {
                    value = changedValue;
                  }
                }
                return value;
              };
              GroupTooltipPositionModel2.prototype._adjustForwardPositionValue = function _adjustForwardPositionValue(value, range, tooltipSize, data) {
                var diff = this._makePositionValueDiff(value, tooltipSize, data);
                if (diff > 0) {
                  var changedValue = this._calculateMainPositionValue(tooltipSize, range, {
                    direction: _const2["default"].TOOLTIP_DIRECTION_BACKWARD,
                    basePosition: data.basePosition
                  });
                  if (changedValue < -data.areaPosition) {
                    value -= diff;
                  } else {
                    value = changedValue;
                  }
                }
                return value;
              };
              GroupTooltipPositionModel2.prototype._adjustMainPositionValue = function _adjustMainPositionValue(value, range, tooltipSize, data) {
                if (data.direction === _const2["default"].TOOLTIP_DIRECTION_BACKWARD) {
                  value = this._adjustBackwardPositionValue(value, range, tooltipSize, data);
                } else if (data.direction === _const2["default"].TOOLTIP_DIRECTION_FORWARD) {
                  value = this._adjustForwardPositionValue(value, range, tooltipSize, data);
                } else {
                  value = Math.max(value, -data.areaPosition);
                  value = Math.min(value, data.chartSize - data.areaPosition - tooltipSize);
                }
                return value;
              };
              GroupTooltipPositionModel2.prototype._adjustSubPositionValue = function _adjustSubPositionValue(value, tooltipSize, data) {
                if (data.direction === _const2["default"].TOOLTIP_DIRECTION_FORWARD) {
                  value = Math.min(value, data.chartSize - data.areaPosition - tooltipSize);
                } else {
                  value = Math.max(value, -data.areaPosition);
                }
                return value;
              };
              GroupTooltipPositionModel2.prototype._makeCachingKey = function _makeCachingKey(_ref) {
                var start = _ref.start, end = _ref.end;
                return start + "-" + end;
              };
              GroupTooltipPositionModel2.prototype._addPositionOptionValue = function _addPositionOptionValue(position, positionType) {
                return position + this.positionOption[positionType];
              };
              GroupTooltipPositionModel2.prototype._makeMainPositionValue = function _makeMainPositionValue(tooltipDimension, range, main) {
                var value = this._calculateMainPositionValue(tooltipDimension[main.sizeType], range, main);
                value = this._addPositionOptionValue(value, main.positionType);
                value = this._adjustMainPositionValue(value, range, tooltipDimension[main.sizeType], main);
                return value;
              };
              GroupTooltipPositionModel2.prototype._makeSubPositionValue = function _makeSubPositionValue(tooltipDimension, sub) {
                var value = this._calculateSubPositionValue(tooltipDimension[sub.sizeType], sub);
                value = this._addPositionOptionValue(value, sub.positionType);
                value = this._adjustSubPositionValue(value, tooltipDimension[sub.sizeType], sub);
                return value;
              };
              GroupTooltipPositionModel2.prototype.calculatePosition = function calculatePosition(tooltipDimension, range) {
                var key = this._makeCachingKey(range);
                var main = this.mainData;
                var sub = this.subData;
                var position = this.positions[key];
                if (!position) {
                  position = {};
                  position[main.positionType] = this._makeMainPositionValue(tooltipDimension, range, main);
                  position[sub.positionType] = this._makeSubPositionValue(tooltipDimension, sub);
                  this.positions[key] = position;
                }
                return position;
              };
              GroupTooltipPositionModel2.prototype.updateOptions = function updateOptions(options) {
                this.options = options;
                this._setData(this.chartDimension, this.areaBound, this.isVertical, options);
              };
              GroupTooltipPositionModel2.prototype.updateBound = function updateBound(bound) {
                this.areaBound = bound;
                this._setData(this.chartDimension, bound, this.isVertical, this.options);
              };
              return GroupTooltipPositionModel2;
            }();
            exports2["default"] = GroupTooltipPositionModel;
          },
          /* 96 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = mapChartTooltipFactory;
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _tooltipBase = __webpack_require__(90);
            var _tooltipBase2 = _interopRequireDefault(_tooltipBase);
            var _singleTooltipMixer = __webpack_require__(91);
            var _singleTooltipMixer2 = _interopRequireDefault(_singleTooltipMixer);
            var _tooltipTemplate = __webpack_require__(92);
            var _tooltipTemplate2 = _interopRequireDefault(_tooltipTemplate);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var MapChartTooltip = function(_TooltipBase) {
              _inherits(MapChartTooltip2, _TooltipBase);
              function MapChartTooltip2(params) {
                _classCallCheck(this, MapChartTooltip2);
                var _this = _possibleConstructorReturn(this, _TooltipBase.call(this, params));
                _this.mapModel = params.mapModel;
                _this.colorSpectrum = params.colorSpectrum;
                return _this;
              }
              MapChartTooltip2.prototype._makeTooltipHtml = function _makeTooltipHtml(datum) {
                return _tooltipTemplate2["default"].tplMapChartDefault(datum);
              };
              MapChartTooltip2.prototype._makeSingleTooltipHtml = function _makeSingleTooltipHtml(chartType, indexes) {
                var datum = this.mapModel.getDatum(indexes.index);
                var suffix = this.options.suffix ? " " + this.options.suffix : "";
                var color = this.colorSpectrum.getColor(datum.ratio);
                return this.templateFunc({
                  name: datum.name || datum.code,
                  value: datum.label,
                  suffix,
                  cssText: "background-color: " + color,
                  color
                });
              };
              MapChartTooltip2.prototype._makeShowTooltipParams = function _makeShowTooltipParams(indexes, additionParams) {
                var datum = this.mapModel.getDatum(indexes.index);
                var params = Object.assign({
                  chartType: this.chartType,
                  code: datum.code,
                  name: datum.name,
                  value: datum.label,
                  index: indexes.index
                }, additionParams);
                return params;
              };
              MapChartTooltip2.prototype._setDefaultTooltipPositionOption = function _setDefaultTooltipPositionOption() {
                if (!this.options.align) {
                  this.options.align = _const2["default"].TOOLTIP_DEFAULT_ALIGN_OPTION;
                }
              };
              return MapChartTooltip2;
            }(_tooltipBase2["default"]);
            _singleTooltipMixer2["default"].mixin(MapChartTooltip);
            function mapChartTooltipFactory(params) {
              return new MapChartTooltip(params);
            }
            mapChartTooltipFactory.componentType = "tooltip";
          },
          /* 97 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = mapChartEventDetectorFactory;
            var _mouseEventDetectorBase = __webpack_require__(98);
            var _mouseEventDetectorBase2 = _interopRequireDefault(_mouseEventDetectorBase);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _eventListener = __webpack_require__(80);
            var _eventListener2 = _interopRequireDefault(_eventListener);
            var _domHandler = __webpack_require__(24);
            var _domHandler2 = _interopRequireDefault(_domHandler);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _browser = __webpack_require__(22);
            var _browser2 = _interopRequireDefault(_browser);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var MapChartEventDetector = function(_MouseEventDetectorBa) {
              _inherits(MapChartEventDetector2, _MouseEventDetectorBa);
              function MapChartEventDetector2(params) {
                _classCallCheck(this, MapChartEventDetector2);
                var _this = _possibleConstructorReturn(this, _MouseEventDetectorBa.call(this));
                _this.chartType = params.chartType;
                _this.eventBus = params.eventBus;
                _this.isDown = false;
                _this.drawingType = _const2["default"].COMPONENT_TYPE_DOM;
                return _this;
              }
              MapChartEventDetector2.prototype._renderMouseEventDetectorArea = function _renderMouseEventDetectorArea(mouseEventDetectorContainer) {
                _renderUtil2["default"].renderDimension(mouseEventDetectorContainer, this.layout.dimension);
                _renderUtil2["default"].renderPosition(mouseEventDetectorContainer, this.layout.position);
              };
              MapChartEventDetector2.prototype._onClick = function _onClick() {
              };
              MapChartEventDetector2.prototype._onMousedown = function _onMousedown(e) {
                this.isDown = true;
                this.eventBus.fire("dragStartMapSeries", {
                  left: e.clientX,
                  top: e.clientY
                });
              };
              MapChartEventDetector2.prototype._dragEnd = function _dragEnd() {
                this.isDrag = false;
                _domHandler2["default"].removeClass(this.mouseEventDetectorContainer, "drag");
                this.eventBus.fire("dragEndMapSeries");
              };
              MapChartEventDetector2.prototype._onMouseup = function _onMouseup(e) {
                this.isDown = false;
                if (this.isDrag) {
                  this._dragEnd();
                } else {
                  this._onMouseEvent("click", e);
                }
                this.isMove = false;
              };
              MapChartEventDetector2.prototype._onMousemove = function _onMousemove(e) {
                if (this.isDown) {
                  if (!this.isDrag) {
                    _domHandler2["default"].addClass(this.mouseEventDetectorContainer, "drag");
                  }
                  this.isDrag = true;
                  this.eventBus.fire("dragMapSeries", {
                    left: e.clientX,
                    top: e.clientY
                  });
                } else {
                  this.isMove = true;
                  this._onMouseEvent("move", e);
                }
              };
              MapChartEventDetector2.prototype._onMouseout = function _onMouseout(e) {
                if (this.isDrag) {
                  this._dragEnd();
                } else {
                  this._onMouseEvent("move", e);
                }
                this.isDown = false;
              };
              MapChartEventDetector2.prototype._onMousewheel = function _onMousewheel(e) {
                var wheelDelta = e.wheelDelta || e.detail * _const2["default"].FF_WHEELDELTA_ADJUSTING_VALUE;
                this.eventBus.fire("wheel", wheelDelta, {
                  left: e.clientX,
                  top: e.clientY
                });
                if (e.preventDefault) {
                  e.preventDefault();
                }
                return false;
              };
              MapChartEventDetector2.prototype.attachEvent = function attachEvent(target) {
                _mouseEventDetectorBase2["default"].prototype.attachEvent.call(this, target);
                if (_browser2["default"].firefox) {
                  _eventListener2["default"].on(target, "DOMMouseScroll", this._onMousewheel, this);
                } else {
                  _eventListener2["default"].on(target, "mousewheel", this._onMousewheel, this);
                }
              };
              return MapChartEventDetector2;
            }(_mouseEventDetectorBase2["default"]);
            function mapChartEventDetectorFactory(params) {
              return new MapChartEventDetector(params);
            }
            mapChartEventDetectorFactory.componentType = "mouseEventDetector";
          },
          /* 98 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _customEvents = __webpack_require__(67);
            var _customEvents2 = _interopRequireDefault(_customEvents);
            var _tickBaseCoordinateModel = __webpack_require__(99);
            var _tickBaseCoordinateModel2 = _interopRequireDefault(_tickBaseCoordinateModel);
            var _boundsBaseCoordinateModel = __webpack_require__(100);
            var _boundsBaseCoordinateModel2 = _interopRequireDefault(_boundsBaseCoordinateModel);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _eventListener = __webpack_require__(80);
            var _eventListener2 = _interopRequireDefault(_eventListener);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _domHandler = __webpack_require__(24);
            var _domHandler2 = _interopRequireDefault(_domHandler);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var MouseEventDetectorBase = function() {
              function MouseEventDetectorBase2(params) {
                _classCallCheck(this, MouseEventDetectorBase2);
                if (!params) {
                  return;
                }
                this.chartType = params.chartType;
                this.chartTypes = params.chartTypes;
                this.isVertical = params.isVertical;
                this.dataProcessor = params.dataProcessor;
                this.allowSelect = params.allowSelect;
                this.eventBus = params.eventBus;
                this.layout = null;
                this.selectedData = null;
                var isLineTypeChart = _predicate2["default"].isLineTypeChart(this.chartType, this.chartTypes);
                this.expandSize = isLineTypeChart ? _const2["default"].SERIES_EXPAND_SIZE : 0;
                this.seriesItemBoundsData = [];
                this.seriesCount = _predicate2["default"].isComboChart(this.chartType) ? 2 : 1;
                this._attachToEventBus();
                this.drawingType = _const2["default"].COMPONENT_TYPE_DOM;
              }
              MouseEventDetectorBase2.prototype._attachToEventBus = function _attachToEventBus() {
                this.eventBus.on("receiveSeriesData", this.onReceiveSeriesData, this);
              };
              MouseEventDetectorBase2.prototype._getRenderingBound = function _getRenderingBound() {
                var renderingBound = _renderUtil2["default"].expandBound(this.layout);
                return renderingBound;
              };
              MouseEventDetectorBase2.prototype._renderMouseEventDetectorArea = function _renderMouseEventDetectorArea(mouseEventDetectorContainer, tickCount) {
                this.dimension = this.layout.dimension;
                var tbcm = new _tickBaseCoordinateModel2["default"](this.layout, tickCount, this.chartType, this.isVertical, this.chartTypes);
                this.tickBaseCoordinateModel = tbcm;
                var _getRenderingBound2 = this._getRenderingBound(), dimension = _getRenderingBound2.dimension, position = _getRenderingBound2.position;
                _renderUtil2["default"].renderDimension(mouseEventDetectorContainer, dimension);
                _renderUtil2["default"].renderPosition(mouseEventDetectorContainer, position);
              };
              MouseEventDetectorBase2.prototype._setDataForRendering = function _setDataForRendering(data) {
                this.layout = data.layout;
              };
              MouseEventDetectorBase2.prototype._pickTickCount = function _pickTickCount(axisDataMap) {
                if (this.isVertical) {
                  return axisDataMap.xAxis.eventTickCount || axisDataMap.xAxis.tickCount;
                }
                return axisDataMap.yAxis.tickCount;
              };
              MouseEventDetectorBase2.prototype.render = function render(data) {
                this.positionMap = data.positionMap;
                var container = data.paper;
                var tickCount = void 0;
                _domHandler2["default"].addClass(container, "tui-chart-series-custom-event-area");
                container.style.backgroundColor = "aliceblue";
                if (data.axisDataMap.xAxis) {
                  tickCount = this._pickTickCount(data.axisDataMap);
                }
                this._setDataForRendering(data);
                this._renderMouseEventDetectorArea(container, tickCount);
                this.attachEvent(container);
                this.mouseEventDetectorContainer = container;
                this.transparentChild = this._createTransparentChild();
                _domHandler2["default"].append(container, this.transparentChild);
                return container;
              };
              MouseEventDetectorBase2.prototype._createTransparentChild = function _createTransparentChild() {
                var child = document.createElement("DIV");
                var style = child.style;
                style.backgroundColor = "#fff";
                style.height = _renderUtil2["default"].getStyle(this.mouseEventDetectorContainer).height;
                _renderUtil2["default"].setOpacity(child, 0);
                return child;
              };
              MouseEventDetectorBase2.prototype._calculateLayerPosition = function _calculateLayerPosition(clientX, clientY, checkLimit) {
                var _mouseEventDetectorCo = this.mouseEventDetectorContainer.getBoundingClientRect(), left = _mouseEventDetectorCo.left, right = _mouseEventDetectorCo.right, top = _mouseEventDetectorCo.top;
                var seriesPosition = this.positionMap.series;
                var expandSize = this.expandSize;
                var layerPosition = {};
                checkLimit = (0, _isUndefined2["default"])(checkLimit) ? true : checkLimit;
                if (checkLimit) {
                  var maxLeft = right - expandSize;
                  var minLeft = left + expandSize;
                  clientX = Math.min(Math.max(clientX, minLeft), maxLeft);
                }
                layerPosition.x = clientX - left + seriesPosition.left - _const2["default"].CHART_PADDING;
                if (!(0, _isUndefined2["default"])(clientY)) {
                  layerPosition.y = clientY - top + seriesPosition.top - _const2["default"].CHART_PADDING;
                }
                return layerPosition;
              };
              MouseEventDetectorBase2.prototype.onReceiveSeriesData = function onReceiveSeriesData(seriesItemBoundsDatum) {
                var seriesCount = this.seriesCount;
                var seriesItemBoundsData = this.seriesItemBoundsData;
                if (seriesItemBoundsData.length === seriesCount) {
                  seriesItemBoundsData = [];
                }
                seriesItemBoundsData.push(seriesItemBoundsDatum);
                if (seriesItemBoundsData.length === seriesCount) {
                  this.boundsBaseCoordinateModel = new _boundsBaseCoordinateModel2["default"](seriesItemBoundsData);
                }
              };
              MouseEventDetectorBase2.prototype.rerender = function rerender(data) {
                var tickCount = void 0;
                this.positionMap = data.positionMap;
                if (data.axisDataMap.xAxis) {
                  tickCount = this._pickTickCount(data.axisDataMap);
                }
                this.selectedData = null;
                this._setDataForRendering(data);
                this._renderMouseEventDetectorArea(this.mouseEventDetectorContainer, tickCount);
                this.transparentChild.style.height = _renderUtil2["default"].getStyle(this.mouseEventDetectorContainer).height;
              };
              MouseEventDetectorBase2.prototype.resize = function resize(data) {
                this.containerBound = null;
                this.rerender(data);
              };
              MouseEventDetectorBase2.prototype._isChangedSelectData = function _isChangedSelectData(prev, cur) {
                return !prev || !cur || prev.chartType !== cur.chartType || prev.indexes.groupIndex !== cur.indexes.groupIndex || prev.indexes.index !== cur.indexes.index;
              };
              MouseEventDetectorBase2.prototype._findDataFromBoundsCoordinateModel = function _findDataFromBoundsCoordinateModel(layerPosition) {
                var layerX = layerPosition.x;
                var layerY = layerPosition.y;
                var groupIndex = void 0;
                if (_predicate2["default"].isTreemapChart(this.chartType)) {
                  groupIndex = 0;
                } else {
                  groupIndex = this.tickBaseCoordinateModel.findIndex(this.isVertical ? layerX : layerY);
                }
                return this.boundsBaseCoordinateModel.findData(groupIndex, layerX, layerY);
              };
              MouseEventDetectorBase2.prototype._findData = function _findData(clientX, clientY) {
                var layerPosition = this._calculateLayerPosition(clientX, clientY);
                return this._findDataFromBoundsCoordinateModel(layerPosition);
              };
              MouseEventDetectorBase2.prototype._showTooltip = function _showTooltip() {
              };
              MouseEventDetectorBase2.prototype._hideTooltip = function _hideTooltip() {
              };
              MouseEventDetectorBase2.prototype._onMouseEvent = function _onMouseEvent(eventType, e) {
                _domHandler2["default"].addClass(this.mouseEventDetectorContainer, "hide");
                this.eventBus.fire(eventType + "Series", {
                  left: e.clientX,
                  top: e.clientY
                });
                _domHandler2["default"].removeClass(this.mouseEventDetectorContainer, "hide");
              };
              MouseEventDetectorBase2.prototype.unselectSeries = function unselectSeries() {
                if (this.selectedData) {
                  this.eventBus.fire("unselectSeries", this.selectedData);
                  this.selectedData = null;
                }
              };
              MouseEventDetectorBase2.prototype._onClick = function _onClick(e) {
                var foundData = this._findData(e.clientX, e.clientY);
                this.selectSeries(foundData);
              };
              MouseEventDetectorBase2.prototype.selectSeries = function selectSeries(seriesData) {
                var shouldSelect = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                if (!this._isChangedSelectData(this.selectedData, seriesData)) {
                  this.unselectSeries();
                } else if (seriesData) {
                  if (this.selectedData) {
                    this.unselectSeries();
                  }
                  this.eventBus.fire("selectSeries", seriesData, shouldSelect);
                  if (this.allowSelect) {
                    this.selectedData = seriesData;
                  }
                }
              };
              MouseEventDetectorBase2.prototype._onMousedown = function _onMousedown() {
              };
              MouseEventDetectorBase2.prototype._onMouseup = function _onMouseup() {
              };
              MouseEventDetectorBase2.prototype._onMousemove = function _onMousemove() {
              };
              MouseEventDetectorBase2.prototype._onMouseout = function _onMouseout() {
              };
              MouseEventDetectorBase2.prototype.attachEvent = function attachEvent(target) {
                _eventListener2["default"].on(target, {
                  click: this._onClick,
                  mousedown: this._onMousedown,
                  mouseup: this._onMouseup,
                  mousemove: this._onMousemove,
                  mouseout: this._onMouseout
                }, this);
              };
              MouseEventDetectorBase2.prototype.findDataByIndexes = function findDataByIndexes() {
              };
              MouseEventDetectorBase2.prototype._setPrevClientPosition = function _setPrevClientPosition(event) {
                if (!event) {
                  this.prevClientPosition = null;
                } else {
                  this.prevClientPosition = {
                    x: event.clientX,
                    y: event.clientY
                  };
                }
              };
              return MouseEventDetectorBase2;
            }();
            _customEvents2["default"].mixin(MouseEventDetectorBase);
            exports2["default"] = MouseEventDetectorBase;
          },
          /* 99 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _range = __webpack_require__(13);
            var _range2 = _interopRequireDefault(_range);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var TickBaseDataModel = function() {
              function TickBaseDataModel2(layout, tickCount, chartType, isVertical, chartTypes) {
                _classCallCheck(this, TickBaseDataModel2);
                this.isLineType = _predicate2["default"].isLineTypeChart(chartType, chartTypes);
                this.data = this._makeData(layout, tickCount, isVertical);
              }
              TickBaseDataModel2.prototype._getRanges = function _getRanges(tickCount, firstPosition, tickInterval) {
                var prev = firstPosition;
                var halfInterval = tickInterval / 2;
                return (0, _range2["default"])(0, tickCount).map(function() {
                  var limit = {
                    min: prev - halfInterval,
                    max: prev + halfInterval
                  };
                  prev += tickInterval;
                  return limit;
                });
              };
              TickBaseDataModel2.prototype._makeLineTypeData = function _makeLineTypeData(width, tickCount, firstPosition) {
                var tickInterval = (width + 1) / (tickCount - 1);
                var ranges = this._getRanges(tickCount, firstPosition || 0, tickInterval);
                ranges[tickCount - 1].max -= 1;
                return ranges;
              };
              TickBaseDataModel2.prototype._makeNormalData = function _makeNormalData(size, tickCount, firstPosition) {
                var len = tickCount - 1;
                var tickInterval = size / len;
                var prev = firstPosition || 0;
                return (0, _range2["default"])(0, len).map(function() {
                  var max = _arrayUtil2["default"].min([size + prev, tickInterval + prev]);
                  var limit = {
                    min: prev,
                    max
                  };
                  prev = max;
                  return limit;
                });
              };
              TickBaseDataModel2.prototype._makeData = function _makeData(layout, tickCount, isVertical) {
                var sizeType = isVertical ? "width" : "height";
                var positionType = isVertical ? "left" : "top";
                if (this.isLineType) {
                  return this._makeLineTypeData(layout.dimension[sizeType], tickCount, layout.position[positionType]);
                }
                return this._makeNormalData(layout.dimension[sizeType], tickCount, layout.position[positionType]);
              };
              TickBaseDataModel2.prototype.findIndex = function findIndex(pointValue) {
                var foundIndex = -1;
                this.data.forEach(function(limit, index) {
                  if (limit.min < pointValue && limit.max >= pointValue) {
                    foundIndex = index;
                    return false;
                  }
                  return true;
                });
                return foundIndex;
              };
              TickBaseDataModel2.prototype.getLastIndex = function getLastIndex() {
                return this.data.length - 1;
              };
              TickBaseDataModel2.prototype.makeRange = function makeRange(index, positionValue) {
                var limit = this.data[index];
                var center = void 0;
                if (this.isLineType) {
                  center = parseInt(limit.max - (limit.max - limit.min) / 2, 10);
                  return {
                    start: center,
                    end: center
                  };
                }
                return {
                  start: limit.min - (positionValue || 0),
                  end: limit.max - (positionValue || 0)
                };
              };
              return TickBaseDataModel2;
            }();
            exports2["default"] = TickBaseDataModel;
          },
          /* 100 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isNumber = __webpack_require__(19);
            var _isNumber2 = _interopRequireDefault(_isNumber);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _toConsumableArray(arr) {
              if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              } else {
                return Array.from(arr);
              }
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var BoundsBaseCoordinateModel = function() {
              function BoundsBaseCoordinateModel2(seriesItemBoundsData) {
                _classCallCheck(this, BoundsBaseCoordinateModel2);
                this.data = this._makeData(seriesItemBoundsData);
              }
              BoundsBaseCoordinateModel2.prototype._makeTooltipData = function _makeTooltipData(chartType, indexes, allowNegativeTooltip, bound) {
                return {
                  sendData: {
                    chartType,
                    indexes,
                    allowNegativeTooltip,
                    bound
                  },
                  bound: {
                    left: bound.left,
                    top: bound.top,
                    right: bound.left + bound.width,
                    bottom: bound.top + bound.height
                  }
                };
              };
              BoundsBaseCoordinateModel2.prototype._makeRectTypePositionData = function _makeRectTypePositionData(groupBounds, chartType) {
                var _this = this;
                var allowNegativeTooltip = !_predicate2["default"].isBoxTypeChart(chartType);
                return groupBounds.map(function(bounds, groupIndex) {
                  return bounds.map(function(bound, index) {
                    if (!bound) {
                      return null;
                    }
                    return _this._makeTooltipData(chartType, {
                      groupIndex,
                      index
                    }, allowNegativeTooltip, bound.end || bound);
                  });
                });
              };
              BoundsBaseCoordinateModel2.prototype._makeOutliersPositionDataForBoxplot = function _makeOutliersPositionDataForBoxplot(groupBounds, chartType, resultData) {
                var _this2 = this;
                var allowNegativeTooltip = !_predicate2["default"].isBoxTypeChart(chartType);
                var _groupBounds = [].concat(_toConsumableArray(groupBounds));
                _groupBounds.forEach(function(bounds, groupIndex) {
                  bounds.forEach(function(bound, index) {
                    var outliers = void 0;
                    if (bound.outliers && bound.outliers.length) {
                      outliers = bound.outliers.map(function(outlier, outlierIndex) {
                        var outlierBound = {
                          top: outlier.top - 3,
                          left: outlier.left - 3,
                          width: 6,
                          height: 6
                        };
                        return _this2._makeTooltipData(chartType, {
                          groupIndex,
                          index,
                          outlierIndex
                        }, allowNegativeTooltip, outlierBound);
                      });
                      resultData[groupIndex] = resultData[groupIndex].concat(outliers);
                    }
                  });
                });
              };
              BoundsBaseCoordinateModel2.prototype._makeDotTypePositionData = function _makeDotTypePositionData(groupPositions, chartType) {
                if (!groupPositions) {
                  return [];
                }
                return _arrayUtil2["default"].pivot(groupPositions).map(function(positions, groupIndex) {
                  return positions.map(function(position, index) {
                    if (!position) {
                      return null;
                    }
                    return {
                      sendData: {
                        chartType,
                        indexes: {
                          groupIndex,
                          index
                        },
                        bound: position
                      },
                      bound: {
                        left: position.left - _const2["default"].DOT_RADIUS,
                        top: position.top - _const2["default"].DOT_RADIUS,
                        right: position.left + _const2["default"].DOT_RADIUS,
                        bottom: position.top + _const2["default"].DOT_RADIUS
                      }
                    };
                  });
                });
              };
              BoundsBaseCoordinateModel2.prototype._joinData = function _joinData(dataGroupSet) {
                var results = [];
                dataGroupSet.forEach(function(dataGroup) {
                  dataGroup.forEach(function(data, index) {
                    var additionalIndex = void 0;
                    if (!results[index]) {
                      results[index] = data;
                    } else {
                      additionalIndex = results[index].length;
                      data.forEach(function(datum) {
                        if (datum) {
                          datum.sendData.indexes.legendIndex = datum.sendData.indexes.index + additionalIndex;
                        }
                      });
                      results[index] = results[index].concat(data);
                    }
                  });
                });
                return results;
              };
              BoundsBaseCoordinateModel2.prototype._makeData = function _makeData(seriesItemBoundsData) {
                var _this3 = this;
                var data = seriesItemBoundsData.map(function(info) {
                  var result = void 0;
                  if (_predicate2["default"].isLineTypeChart(info.chartType)) {
                    result = _this3._makeDotTypePositionData(info.data.groupPositions, info.chartType);
                  } else {
                    result = _this3._makeRectTypePositionData(info.data.groupBounds, info.chartType);
                  }
                  if (_predicate2["default"].isBoxplotChart(info.chartType)) {
                    _this3._makeOutliersPositionDataForBoxplot(info.data.groupBounds, info.chartType, result);
                  }
                  return result;
                });
                return this._joinData(data);
              };
              BoundsBaseCoordinateModel2.prototype._findCandidates = function _findCandidates(data, layerX, layerY) {
                var _this4 = this;
                return data.filter(function(datum) {
                  var bound = datum && datum.bound;
                  if (bound) {
                    if (bound.top === bound.bottom) {
                      bound.top -= _const2["default"].SERIES_EXTRA_EVENT_AREA_FOR_ZERO;
                      bound.bottom += _const2["default"].SERIES_EXTRA_EVENT_AREA_FOR_ZERO;
                    }
                    if (bound.left === bound.right) {
                      bound.left -= _const2["default"].SERIES_EXTRA_EVENT_AREA_FOR_ZERO;
                      bound.right += _const2["default"].SERIES_EXTRA_EVENT_AREA_FOR_ZERO;
                    }
                    return _this4._isCandidateTarget(bound, {
                      layerX,
                      layerY
                    });
                  }
                  return false;
                });
              };
              BoundsBaseCoordinateModel2.prototype._isCandidateTarget = function _isCandidateTarget(bound, _ref) {
                var layerX = _ref.layerX, layerY = _ref.layerY;
                var includedX = bound.left <= layerX && bound.right >= layerX;
                var includedY = bound.top <= layerY && bound.bottom >= layerY;
                return includedX && includedY;
              };
              BoundsBaseCoordinateModel2.prototype.findData = function findData(groupIndex, layerX, layerY) {
                var min = 1e4;
                var result = null;
                if (groupIndex > -1 && this.data[groupIndex]) {
                  var candidates = this._findCandidates(this.data[groupIndex], layerX, layerY);
                  candidates.forEach(function(data) {
                    var diff = Math.abs(layerY - data.bound.top);
                    if (min > diff) {
                      min = diff;
                      result = data.sendData;
                    }
                  });
                }
                return result;
              };
              BoundsBaseCoordinateModel2.prototype.findDataByIndexes = function findDataByIndexes(indexes) {
                var foundData = this.data[indexes.index][indexes.seriesIndex].sendData;
                if ((0, _isNumber2["default"])(indexes.outlierIndex)) {
                  return this._findOutlierDataByIndexes(indexes);
                }
                return foundData;
              };
              BoundsBaseCoordinateModel2.prototype._findOutlierDataByIndexes = function _findOutlierDataByIndexes(indexes) {
                var foundData = null;
                this.data[indexes.index].forEach(function(datum) {
                  var datumIndexes = datum.sendData.indexes;
                  var found = datumIndexes.index === indexes.seriesIndex && datumIndexes.outlierIndex === indexes.outlierIndex;
                  if (found) {
                    foundData = datum.sendData;
                  }
                  return !found;
                });
                return foundData;
              };
              return BoundsBaseCoordinateModel2;
            }();
            exports2["default"] = BoundsBaseCoordinateModel;
          },
          /* 101 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = mouseEventDetectorFactory;
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _areaTypeEventDetector = __webpack_require__(102);
            var _areaTypeEventDetector2 = _interopRequireDefault(_areaTypeEventDetector);
            var _simpleEventDetector = __webpack_require__(105);
            var _simpleEventDetector2 = _interopRequireDefault(_simpleEventDetector);
            var _groupTypeEventDetector = __webpack_require__(106);
            var _groupTypeEventDetector2 = _interopRequireDefault(_groupTypeEventDetector);
            var _boundsTypeEventDetector = __webpack_require__(107);
            var _boundsTypeEventDetector2 = _interopRequireDefault(_boundsTypeEventDetector);
            var _mapChartEventDetector = __webpack_require__(97);
            var _mapChartEventDetector2 = _interopRequireDefault(_mapChartEventDetector);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function mouseEventDetectorFactory(params) {
              var chartOptions = params.chartOptions, seriesTypes = params.seriesTypes;
              var chartType = chartOptions.chartType, _chartOptions$series = chartOptions.series, zoomable = _chartOptions$series.zoomable, seriesAllowSelect = _chartOptions$series.allowSelect, pointOnColumn = chartOptions.xAxis.pointOnColumn;
              var factory = void 0;
              if (params.chartOptions.tooltip.grouped) {
                factory = _groupTypeEventDetector2["default"];
              } else if (_predicate2["default"].isMapChart(chartType)) {
                factory = _mapChartEventDetector2["default"];
              } else if (_predicate2["default"].isBarTypeChart(chartType) || _predicate2["default"].isBoxplotChart(chartType) || _predicate2["default"].isHeatmapChart(chartType) || _predicate2["default"].isTreemapChart(chartType) || _predicate2["default"].isBulletChart(chartType)) {
                factory = _boundsTypeEventDetector2["default"];
              } else if (_predicate2["default"].isCoordinateTypeChart(chartType) || _predicate2["default"].isPieChart(chartType) || _predicate2["default"].isPieDonutComboChart(chartType, seriesTypes)) {
                factory = _simpleEventDetector2["default"];
              } else {
                factory = _areaTypeEventDetector2["default"];
              }
              params.chartType = chartType;
              params.chartTypes = seriesTypes;
              params.zoomable = zoomable;
              params.allowSelect = seriesAllowSelect;
              params.pointOnColumn = !!pointOnColumn;
              return factory(params);
            }
            mouseEventDetectorFactory.componentType = "mouseEventDetector";
          },
          /* 102 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = areaTypeEventDetectorFactory;
            var _mouseEventDetectorBase = __webpack_require__(98);
            var _mouseEventDetectorBase2 = _interopRequireDefault(_mouseEventDetectorBase);
            var _zoomMixer = __webpack_require__(103);
            var _zoomMixer2 = _interopRequireDefault(_zoomMixer);
            var _areaTypeDataModel = __webpack_require__(104);
            var _areaTypeDataModel2 = _interopRequireDefault(_areaTypeDataModel);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var AreaTypeEventDetector = function(_MouseEventDetectorBa) {
              _inherits(AreaTypeEventDetector2, _MouseEventDetectorBa);
              function AreaTypeEventDetector2(params) {
                _classCallCheck(this, AreaTypeEventDetector2);
                var _this = _possibleConstructorReturn(this, _MouseEventDetectorBa.call(this, params));
                _this.prevFoundData = null;
                _this.prevClientPosition = null;
                _this.zoomable = params.zoomable;
                if (_this.zoomable) {
                  Object.assign(_this, _zoomMixer2["default"]);
                  _this._initForZoom(params.zoomable);
                }
                return _this;
              }
              AreaTypeEventDetector2.prototype.animateForAddingData = function animateForAddingData() {
                if (!this.prevClientPosition) {
                  return;
                }
                var foundData = this._findData(this.prevClientPosition.x, this.prevClientPosition.y);
                if (foundData) {
                  var isMatchedIndex = this.prevFoundData.indexes.groupIndex === foundData.indexes.groupIndex;
                  var isMoving = this.prevFoundData && isMatchedIndex;
                  this._showTooltip(foundData, isMoving);
                }
                this.prevFoundData = foundData;
              };
              AreaTypeEventDetector2.prototype.onReceiveSeriesData = function onReceiveSeriesData(seriesItemBoundsDatum) {
                var seriesCount = this.seriesCount;
                if (this.seriesItemBoundsData.length === seriesCount) {
                  this.seriesItemBoundsData = [];
                }
                this.seriesItemBoundsData.push(seriesItemBoundsDatum);
                if (this.seriesItemBoundsData.length === seriesCount) {
                  this.dataModel = new _areaTypeDataModel2["default"](this.seriesItemBoundsData);
                }
                if (this.zoomable) {
                  this._showTooltipAfterZoom();
                }
              };
              AreaTypeEventDetector2.prototype._findData = function _findData(clientX, clientY) {
                var layerPosition = this._calculateLayerPosition(clientX, clientY);
                var selectLegendIndex = this.dataProcessor.selectLegendIndex;
                var isCoordinateTypeChart = this.dataProcessor.isCoordinateType();
                return this.dataModel.findData(layerPosition, selectLegendIndex, {
                  distanceLimit: this.dataModel.leftStepLength,
                  isCoordinateTypeChart
                });
              };
              AreaTypeEventDetector2.prototype._findDataForZoomable = function _findDataForZoomable(clientX, clientY) {
                var layerPosition = this._calculateLayerPosition(clientX, clientY);
                return this.dataModel.findData(layerPosition);
              };
              AreaTypeEventDetector2.prototype._getFirstData = function _getFirstData(index) {
                return this.dataModel.getFirstData(index);
              };
              AreaTypeEventDetector2.prototype._getLastData = function _getLastData(index) {
                return this.dataModel.getLastData(index);
              };
              AreaTypeEventDetector2.prototype._showTooltip = function _showTooltip(foundData) {
                this.eventBus.fire("showTooltip", foundData);
                this.prevFoundData = foundData;
              };
              AreaTypeEventDetector2.prototype._hideTooltip = function _hideTooltip(options) {
                this.eventBus.fire("hideTooltip", this.prevFoundData, options);
                this.prevFoundData = null;
              };
              AreaTypeEventDetector2.prototype._onMousemove = function _onMousemove(e) {
                var dragMouseupResult = void 0;
                this._setPrevClientPosition(e);
                var foundData = this._findData(e.clientX, e.clientY);
                if (this.zoomable) {
                  dragMouseupResult = this._isAfterDragMouseup();
                }
                if (dragMouseupResult || !this._isChangedSelectData(this.prevFoundData, foundData)) {
                  return;
                }
                if (foundData) {
                  this._showTooltip(foundData);
                } else if (this.prevFoundData) {
                  this._hideTooltip();
                }
                this.prevFoundData = foundData;
              };
              AreaTypeEventDetector2.prototype._onMouseout = function _onMouseout() {
                if (this.prevFoundData) {
                  this._hideTooltip();
                }
                this.prevClientPosition = null;
                this.prevFoundData = null;
              };
              AreaTypeEventDetector2.prototype.findDataByIndexes = function findDataByIndexes(indexes) {
                return this.dataModel.findDataByIndexes(indexes);
              };
              AreaTypeEventDetector2.prototype._setPrevClientPosition = function _setPrevClientPosition(event) {
                if (!event) {
                  this.prevClientPosition = null;
                } else {
                  this.prevClientPosition = {
                    x: event.clientX,
                    y: event.clientY
                  };
                }
              };
              return AreaTypeEventDetector2;
            }(_mouseEventDetectorBase2["default"]);
            function areaTypeEventDetectorFactory(params) {
              return new AreaTypeEventDetector(params);
            }
            areaTypeEventDetectorFactory.componentType = "mouseEventDetector";
          },
          /* 103 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _mouseEventDetectorBase = __webpack_require__(98);
            var _mouseEventDetectorBase2 = _interopRequireDefault(_mouseEventDetectorBase);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _domHandler = __webpack_require__(24);
            var _domHandler2 = _interopRequireDefault(_domHandler);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _eventListener = __webpack_require__(80);
            var _eventListener2 = _interopRequireDefault(_eventListener);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            exports2["default"] = {
              /**
               * Initialize for zoom.
               * @param {boolean} zoomable - whether zoomable or not
               * @private
               */
              _initForZoom: function _initForZoom(zoomable) {
                this.zoomable = zoomable;
                this.dragStartIndexes = null;
                this.startClientPosition = null;
                this.startLayerX = null;
                this.dragSelectionElement = null;
                this.containerBound = null;
                this.isShowTooltipAfterZoom = false;
                this.afterMouseup = false;
                this.prevDistanceOfRange = null;
                this.reverseMove = null;
                this.resetZoomBtn = null;
              },
              /**
               * preset zoom data before rerender.
               */
              presetBeforeRerender: function presetBeforeRerender() {
                if (this.resetZoomBtn) {
                  this.mouseEventDetectorContainer.removeChild(this.resetZoomBtn);
                  this.resetZoomBtn = null;
                }
                this._hideTooltip();
                this.prevDistanceOfRange = null;
              },
              /**
               * Show tooltip after zoom.
               * @private
               */
              _showTooltipAfterZoom: function _showTooltipAfterZoom() {
                var isShowTooltipAfterZoom = this.isShowTooltipAfterZoom;
                var lastDataBeforeZoom = void 0;
                this.isShowTooltipAfterZoom = false;
                if (!isShowTooltipAfterZoom || !this.dragStartIndexes) {
                  return;
                }
                if (this.reverseMove) {
                  lastDataBeforeZoom = this._getFirstData(this.dragStartIndexes.index);
                } else {
                  lastDataBeforeZoom = this._getLastData(this.dragEndIndexes.index);
                }
                if (lastDataBeforeZoom) {
                  this._showTooltip(lastDataBeforeZoom);
                }
              },
              /**
               * Update dimension for drag selection element.
               * @param {HTMLElement} selectionElement - drag selection element
               * @private
               */
              _updateDimensionForDragSelection: function _updateDimensionForDragSelection(selectionElement) {
                _renderUtil2["default"].renderDimension(selectionElement, {
                  height: this.layout.dimension.height
                });
              },
              /**
               * Render drag selection.
               * @returns {HTMLElement}
               * @private
               */
              _renderDragSelection: function _renderDragSelection() {
                var selectionElement = _domHandler2["default"].create("DIV", "tui-chart-drag-selection");
                this._updateDimensionForDragSelection(selectionElement);
                return selectionElement;
              },
              /**
               * Render.
               * @param {object} data - data for rendering
               * @returns {HTMLElement}
               * @override
               */
              render: function render(data) {
                var container = _mouseEventDetectorBase2["default"].prototype.render.call(this, data);
                var selectionElement = this._renderDragSelection();
                _domHandler2["default"].append(container, selectionElement);
                this.dragSelectionElement = selectionElement;
                return container;
              },
              /**
               * Resize.
               * @param {{tickCount: number}} data - data for resizing
               * @override
               */
              resize: function resize(data) {
                this.containerBound = null;
                _mouseEventDetectorBase2["default"].prototype.resize.call(this, data);
                this._updateDimensionForDragSelection(this.dragSelectionElement);
              },
              /**
               * On click
               * @private
               * @override
               */
              _onClick: function _onClick() {
              },
              /**
               * Whether after drag mouseup or not.
               * @returns {boolean}
               * @private
               */
              _isAfterDragMouseup: function _isAfterDragMouseup() {
                var afterMouseup = this.afterMouseup;
                if (afterMouseup) {
                  this.afterMouseup = false;
                }
                return afterMouseup;
              },
              /**
               * Bind drag event for zoom.
               * @param {HTMLElement} target - target element
               * @private
               */
              _bindDragEvent: function _bindDragEvent(target) {
                if (target.setCapture) {
                  target.setCapture();
                }
                _eventListener2["default"].on(document, "mousemove", this._onDrag, this);
                _eventListener2["default"].off(this.mouseEventDetectorContainer, "mouseup", this._onMouseup, this);
                _eventListener2["default"].on(document, "mouseup", this._onMouseupAfterDrag, this);
              },
              /**
               * Unbind drag event for zoom.
               * @private
               */
              _unbindDragEvent: function _unbindDragEvent() {
                if (this.downTarget && this.downTarget.releaseCapture) {
                  this.downTarget.releaseCapture();
                }
                _eventListener2["default"].off(document, "mousemove", this._onDrag, this);
                _eventListener2["default"].off(document, "mouseup", this._onMouseupAfterDrag, this);
                _eventListener2["default"].on(this.mouseEventDetectorContainer, "mouseup", this._onMouseup, this);
              },
              /**
               * On mouse down.
               * @param {MouseEvent} e - mouse event
               * @private
               * @override
               */
              _onMousedown: function _onMousedown(e) {
                if (!this.zoomable) {
                  return;
                }
                var target = e.target || e.srcElement;
                this.startClientPosition = {
                  x: e.clientX,
                  y: e.clientY
                };
                this.startLayerX = this._calculateLayerPosition(e.clientX).x;
                this.downTarget = target;
                this._bindDragEvent(target);
              },
              /**
               * Show drag selection.
               * @param {number} clientX - clientX
               * @private
               */
              _showDragSelection: function _showDragSelection(clientX) {
                var _mouseEventDetectorCo = this.mouseEventDetectorContainer.getBoundingClientRect(), eventContainerLeft = _mouseEventDetectorCo.left;
                var layerX = this._calculateLayerPosition(clientX).x;
                var clientPos = this.startClientPosition;
                var diffArea = eventContainerLeft - (clientPos.x - this.startLayerX);
                var left = Math.min(layerX, this.startLayerX) - diffArea;
                var width = Math.abs(layerX - this.startLayerX);
                var element = this.dragSelectionElement;
                element.style.left = left + "px";
                element.style.width = width + "px";
                _domHandler2["default"].addClass(element, "show");
              },
              /**
               * Hide drag selection.
               * @private
               */
              _hideDragSelection: function _hideDragSelection() {
                _domHandler2["default"].removeClass(this.dragSelectionElement, "show");
              },
              /**
               * On mouse drag.
               * @param {MouseEvent} e - mouse event
               * @private
               */
              _onDrag: function _onDrag(e) {
                var clientPos = this.startClientPosition;
                var target = e.target || e.srcElement;
                if (clientPos) {
                  var dataForZoomable = this._findDataForZoomable(clientPos.x, clientPos.y);
                  if (!_domHandler2["default"].hasClass(target, _const2["default"].CLASS_NAME_RESET_ZOOM_BTN)) {
                    if ((0, _isNull2["default"])(this.dragStartIndexes)) {
                      this.dragStartIndexes = dataForZoomable ? dataForZoomable.indexes : {};
                    } else {
                      this._showDragSelection(e.clientX);
                    }
                  }
                }
              },
              /**
               * Adjust index range for ensure three indexes.
               * @param {Array.<{startIndex: number, endIndex: number}>} indexRange - index range
               * @returns {object} startIndex, endIndex
               * @private
               */
              _changeIndexToHaveMinimumIndexes: function _changeIndexToHaveMinimumIndexes(_ref) {
                var _ref2 = _slicedToArray(_ref, 2), startIndex = _ref2[0], endIndex = _ref2[1];
                var distanceOfRange = endIndex - startIndex;
                if (distanceOfRange === 0) {
                  if (startIndex === 0) {
                    endIndex += 2;
                  } else {
                    startIndex -= 1;
                    endIndex += 1;
                  }
                } else if (distanceOfRange === 1) {
                  if (startIndex === 0) {
                    endIndex += 1;
                  } else {
                    startIndex -= 1;
                  }
                }
                return {
                  startIndex,
                  endIndex
                };
              },
              /**
               * Adjust index range for ensure three indexes.
               * @param {number} startIndex - start index
               * @param {number} endIndex - end index
               * @returns {Array.<number>}
               * @private
               */
              _adjustIndexRange: function _adjustIndexRange(startIndex, endIndex) {
                var indexRange = [startIndex, endIndex].sort(function(a, b) {
                  return a - b;
                });
                return this._changeIndexToHaveMinimumIndexes(indexRange);
              },
              /**
               * Fire zoom mouse event detector.
               * @private
               */
              _fireZoom: function _fireZoom() {
                if (this.dataProcessor.isLineCoordinateType()) {
                  this._fireZoomUsingValue(this.dragStartIndexes, this.dragEndIndexes);
                } else {
                  this._fireZoomUsingIndex(this.dragStartIndexes.groupIndex, this.dragEndIndexes.groupIndex);
                }
              },
              /**
               * Fire zoom mouse event detector using Index.
               * @param {number} startIndex - start index
               * @param {number} endIndex - end index
               * @private
               */
              _fireZoomUsingIndex: function _fireZoomUsingIndex(startIndex, endIndex) {
                var reverseMove = startIndex > endIndex;
                var _adjustIndexRange2 = this._adjustIndexRange(startIndex, endIndex), adjustedStartIndex = _adjustIndexRange2.startIndex, adjustedEndIndex = _adjustIndexRange2.endIndex;
                var distanceOfRange = adjustedEndIndex - adjustedStartIndex;
                if (this.prevDistanceOfRange === distanceOfRange) {
                  return;
                }
                this.prevDistanceOfRange = distanceOfRange;
                this.reverseMove = reverseMove;
                this.eventBus.fire("zoom", [adjustedStartIndex, adjustedEndIndex]);
              },
              /**
               * Adjust value range for ensure three indexes.
               * @param {number} startValue - start index
               * @param {number} endValue - end index
               * @returns {Array.<number>}
               * @private
               */
              _adjustValueRange: function _adjustValueRange(startValue, endValue) {
                var startValueIndex = void 0, endValueIndex = void 0;
                var _dataProcessor = this.dataProcessor, integratedXAxisData = _dataProcessor.integratedXAxisData, xAxisOptions = _dataProcessor.options.xAxis;
                var isDatetime = _predicate2["default"].isDatetimeType(xAxisOptions.type);
                if (isDatetime) {
                  startValueIndex = _arrayUtil2["default"].findIndexFromDateTypeArray(integratedXAxisData, new Date(startValue));
                  endValueIndex = _arrayUtil2["default"].findIndexFromDateTypeArray(integratedXAxisData, new Date(endValue));
                } else {
                  startValueIndex = integratedXAxisData.indexOf(startValue);
                  endValueIndex = integratedXAxisData.indexOf(endValue);
                }
                var indexRange = [startValueIndex, endValueIndex].sort(function(a, b) {
                  return a - b;
                });
                var _changeIndexToHaveMin = this._changeIndexToHaveMinimumIndexes(indexRange), startIndex = _changeIndexToHaveMin.startIndex, endIndex = _changeIndexToHaveMin.endIndex;
                return [integratedXAxisData[startIndex], integratedXAxisData[endIndex]];
              },
              /**
               * Fire zoom mouse event detector for coordinateChart.
               * @param {object} startIndexes - start index
               * @param {object} endIndexes - end index
               * @private
               */
              _fireZoomUsingValue: function _fireZoomUsingValue(startIndexes, endIndexes) {
                var startIndex = startIndexes.index, startGroupIndex = startIndexes.groupIndex;
                var endIndex = endIndexes.index, endGroupIndex = endIndexes.groupIndex;
                var seriesData = this.dataProcessor.rawData.series.line;
                var _seriesData$startInde = _slicedToArray(seriesData[startIndex].data[startGroupIndex], 1), startValue = _seriesData$startInde[0];
                var _seriesData$endIndex$ = _slicedToArray(seriesData[endIndex].data[endGroupIndex], 1), endValue = _seriesData$endIndex$[0];
                var valueRange = this._adjustValueRange(startValue, endValue);
                this.eventBus.fire("zoom", valueRange);
              },
              /**
               * Set flag about whether show tooltip after zoom or not.
               * @param {number} clientX - clientX of mouse event
               * @param {number} clientY - clientY of mouse event
               * @private
               */
              _setIsShowTooltipAfterZoomFlag: function _setIsShowTooltipAfterZoomFlag(clientX, clientY) {
                var layerX = this._calculateLayerPosition(clientX, clientY, false).x;
                var limitLayerX = this._calculateLayerPosition(clientX, clientY).x;
                this.isShowTooltipAfterZoom = layerX === limitLayerX;
              },
              /**
               * On mouseup after drag event.
               * @param {MouseEvent} e - mouse event
               * @private
               */
              _onMouseupAfterDrag: function _onMouseupAfterDrag(e) {
                var foundedDragEndData = this._findDataForZoomable(e.clientX, e.clientY);
                this._unbindDragEvent();
                if ((0, _isNull2["default"])(this.dragStartIndexes)) {
                  var target = e.target || e.srcElement;
                  if (_domHandler2["default"].hasClass(target, _const2["default"].CLASS_NAME_RESET_ZOOM_BTN)) {
                    this._hideTooltip();
                    this.prevDistanceOfRange = null;
                    this.eventBus.fire("resetZoom");
                  } else {
                    _mouseEventDetectorBase2["default"].prototype._onClick.call(this, e);
                  }
                } else if (this.dragStartIndexes && foundedDragEndData) {
                  this.dragEndIndexes = foundedDragEndData.indexes;
                  this._setIsShowTooltipAfterZoomFlag(e.clientX, e.clientY);
                  this._hideDragSelection();
                  this._fireZoom();
                } else {
                  this._setIsShowTooltipAfterZoomFlag(e.clientX, e.clientY);
                  this._hideDragSelection();
                }
                this.startClientPosition = null;
                this.dragStartIndexes = null;
                this.startLayerX = null;
                this.afterMouseup = true;
              },
              /**
               * Render reset zoom button element.
               * @returns {HTMLElement}
               * @private
               */
              _renderResetZoomBtn: function _renderResetZoomBtn() {
                var resetBtn = _domHandler2["default"].create("DIV", _const2["default"].CLASS_NAME_RESET_ZOOM_BTN);
                return resetBtn;
              },
              /**
               * Zoom.
               * @param {object} data - data for rendering
               */
              zoom: function zoom(data) {
                this.prevFoundData = null;
                this.rerender(data);
                this._updateDimensionForDragSelection(this.dragSelectionElement);
                if (!this.resetZoomBtn) {
                  this.resetZoomBtn = this._renderResetZoomBtn();
                  _domHandler2["default"].append(this.mouseEventDetectorContainer, this.resetZoomBtn);
                } else if (data.isResetZoom) {
                  this.mouseEventDetectorContainer.removeChild(this.resetZoomBtn);
                  this.resetZoomBtn = null;
                }
              }
            };
          },
          /* 104 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _toConsumableArray(arr) {
              if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              } else {
                return Array.from(arr);
              }
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var AreaTypeDataModel = function() {
              function AreaTypeDataModel2(seriesItemBoundsData) {
                _classCallCheck(this, AreaTypeDataModel2);
                this.data = this._makeData(seriesItemBoundsData);
                this.lastGroupIndex = 0;
              }
              AreaTypeDataModel2.prototype._makeData = function _makeData(seriesItemBoundsData) {
                var _this = this, _ref, _ref2;
                var seriesItemBoundsLength = seriesItemBoundsData.length;
                var lastGroupIndex = 0;
                var data = seriesItemBoundsData.map(function(seriesDatum, seriesIndex) {
                  var chartType = seriesDatum.chartType, dotumData = seriesDatum.data;
                  var groupPositions = dotumData.groupPositions || dotumData.groupBounds;
                  if (_predicate2["default"].isLineTypeChart(chartType) || _predicate2["default"].isRadialChart(chartType)) {
                    groupPositions = _arrayUtil2["default"].pivot(groupPositions);
                  }
                  lastGroupIndex = Math.max(groupPositions.length - 1, lastGroupIndex);
                  var hasGroupPosition = groupPositions.length > 1 && groupPositions[1][0] && groupPositions[0][0];
                  _this.leftStepLength = hasGroupPosition ? groupPositions[1][0].left - groupPositions[0][0].left : 0;
                  return groupPositions.map(function(positions, groupIndex) {
                    return positions.map(function(position, index) {
                      var datum = null;
                      if (position) {
                        datum = {
                          chartType,
                          indexes: {
                            groupIndex,
                            index
                          },
                          bound: position
                        };
                      }
                      if (seriesItemBoundsLength > 1) {
                        datum.indexes.legendIndex = seriesIndex;
                      }
                      return datum;
                    });
                  });
                });
                data = (_ref = []).concat.apply(_ref, _toConsumableArray(data));
                this.lastGroupIndex = lastGroupIndex;
                return (_ref2 = []).concat.apply(_ref2, _toConsumableArray(data)).filter(function(datum) {
                  return !!datum;
                });
              };
              AreaTypeDataModel2.prototype.findData = function findData(layerPosition, selectLegendIndex) {
                var _ref3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, distanceLimit = _ref3.distanceLimit, isCoordinateTypeChart = _ref3.isCoordinateTypeChart;
                var isLooseDistancePosition = distanceLimit && distanceLimit < this.leftStepLength;
                var useCoordinateDistanceSearch = isCoordinateTypeChart || isLooseDistancePosition;
                if (useCoordinateDistanceSearch) {
                  return this._findDataForCoordinateDistance(layerPosition, distanceLimit, selectLegendIndex);
                }
                return this._findDataForFirstXPosition(layerPosition, selectLegendIndex);
              };
              AreaTypeDataModel2.prototype._findDataForFirstXPosition = function _findDataForFirstXPosition(layerPosition, selectLegendIndex) {
                var _data$reduce = this.data.reduce(function(findMinObj, datum) {
                  var xDiff = Math.abs(layerPosition.x - datum.bound.left);
                  if (xDiff <= findMinObj.xMin) {
                    findMinObj.xMin = xDiff;
                    findMinObj.xMinValue = datum.bound.left;
                  }
                  return findMinObj;
                }, {
                  xMin: Number.MAX_VALUE,
                  xMinValue: 0
                }), xMinValue = _data$reduce.xMinValue;
                var _data$reduce2 = this.data.reduce(function(findResultObj, datum) {
                  var yDiff = Math.abs(layerPosition.y - datum.bound.top);
                  var remakeFindObj = {};
                  if (datum.bound.left !== xMinValue) {
                    remakeFindObj = findResultObj;
                  } else if (!(0, _isNull2["default"])(selectLegendIndex) && selectLegendIndex === datum.indexes.index) {
                    remakeFindObj.yMin = Number.MIN_VALUE;
                    remakeFindObj.findFound = datum;
                  } else if (yDiff <= findResultObj.yMin) {
                    remakeFindObj.yMin = yDiff;
                    remakeFindObj.findFound = datum;
                  } else {
                    remakeFindObj = findResultObj;
                  }
                  return remakeFindObj;
                }, {
                  yMin: Number.MAX_VALUE,
                  findFound: null
                }), findFound = _data$reduce2.findFound;
                return findFound;
              };
              AreaTypeDataModel2.prototype._findDataForCoordinateDistance = function _findDataForCoordinateDistance(layerPosition, distanceLimit, selectLegendIndex) {
                var min = 1e5;
                var findFound = void 0;
                distanceLimit = distanceLimit || Number.MAX_VALUE;
                this.data.forEach(function(datum) {
                  var xDiff = layerPosition.x - datum.bound.left;
                  var yDiff = layerPosition.y - datum.bound.top;
                  var distance = Math.sqrt(Math.pow(xDiff, 2) + Math.pow(yDiff, 2));
                  if (distance > distanceLimit) {
                    return;
                  }
                  if (!(0, _isNull2["default"])(selectLegendIndex) && selectLegendIndex !== datum.indexes.index) {
                    return;
                  }
                  if (distance <= min) {
                    min = distance;
                    findFound = datum;
                  }
                });
                return findFound;
              };
              AreaTypeDataModel2.prototype.findDataByIndexes = function findDataByIndexes(_ref4) {
                var index = _ref4.index, seriesIndex = _ref4.seriesIndex;
                var foundData = null;
                this.data.forEach(function(datum) {
                  if (datum.indexes.groupIndex === index && datum.indexes.index === seriesIndex) {
                    foundData = datum;
                  }
                  return !foundData;
                });
                return foundData;
              };
              AreaTypeDataModel2.prototype.getFirstData = function getFirstData(index) {
                var indexes = {
                  index: 0,
                  seriesIndex: index
                };
                return this.findDataByIndexes(indexes);
              };
              AreaTypeDataModel2.prototype.getLastData = function getLastData(index) {
                var indexes = {
                  index: this.lastGroupIndex,
                  seriesIndex: index
                };
                return this.findDataByIndexes(indexes);
              };
              return AreaTypeDataModel2;
            }();
            exports2["default"] = AreaTypeDataModel;
          },
          /* 105 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = simpleTypeEventDetectorFactory;
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _mouseEventDetectorBase = __webpack_require__(98);
            var _mouseEventDetectorBase2 = _interopRequireDefault(_mouseEventDetectorBase);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var SimpleEventDetector = function(_MouseEventDetectorBa) {
              _inherits(SimpleEventDetector2, _MouseEventDetectorBa);
              function SimpleEventDetector2(params) {
                _classCallCheck(this, SimpleEventDetector2);
                var _this = _possibleConstructorReturn(this, _MouseEventDetectorBa.call(this));
                _this.chartType = params.chartType;
                _this.drawingType = _const2["default"].COMPONENT_TYPE_DOM;
                _this.eventBus = params.eventBus;
                return _this;
              }
              SimpleEventDetector2.prototype._renderMouseEventDetectorArea = function _renderMouseEventDetectorArea(mouseEventDetectorContainer) {
                _renderUtil2["default"].renderDimension(mouseEventDetectorContainer, this.layout.dimension);
                _renderUtil2["default"].renderPosition(mouseEventDetectorContainer, this.layout.position);
              };
              SimpleEventDetector2.prototype.onReceiveSeriesData = function onReceiveSeriesData() {
              };
              SimpleEventDetector2.prototype._onClick = function _onClick(e) {
                this._onMouseEvent("click", e);
              };
              SimpleEventDetector2.prototype._onMousemove = function _onMousemove(e) {
                this._onMouseEvent("move", e);
              };
              SimpleEventDetector2.prototype._onMouseout = function _onMouseout(e) {
                this._onMouseEvent("move", e);
              };
              return SimpleEventDetector2;
            }(_mouseEventDetectorBase2["default"]);
            function simpleTypeEventDetectorFactory(params) {
              return new SimpleEventDetector(params);
            }
            simpleTypeEventDetectorFactory.componentType = "mouseEventDetector";
          },
          /* 106 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            exports2["default"] = groupTypeEventDetectorFactory;
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _mouseEventDetectorBase = __webpack_require__(98);
            var _mouseEventDetectorBase2 = _interopRequireDefault(_mouseEventDetectorBase);
            var _zoomMixer = __webpack_require__(103);
            var _zoomMixer2 = _interopRequireDefault(_zoomMixer);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var GroupTypeEventDetector = function(_EventDetectorBase) {
              _inherits(GroupTypeEventDetector2, _EventDetectorBase);
              function GroupTypeEventDetector2(params) {
                _classCallCheck(this, GroupTypeEventDetector2);
                var _this = _possibleConstructorReturn(this, _EventDetectorBase.call(this, params));
                _this.prevIndex = null;
                _this.zoomable = params.zoomable;
                _this.sizeType = _this.isVertical ? "height" : "width";
                _this.pointOnColumn = params.pointOnColumn;
                if (_this.zoomable) {
                  Object.assign(_this, _zoomMixer2["default"]);
                  _this._initForZoom(params.zoomable);
                }
                return _this;
              }
              GroupTypeEventDetector2.prototype.initMouseEventDetectorData = function initMouseEventDetectorData(seriesInfos) {
                _mouseEventDetectorBase2["default"].prototype.initMouseEventDetectorData.call(this, seriesInfos);
                if (this.zoomable) {
                  this._showTooltipAfterZoom();
                }
              };
              GroupTypeEventDetector2.prototype._findGroupData = function _findGroupData(clientX, clientY) {
                var layerPosition = this._calculateLayerPosition(clientX, clientY, true);
                var pointValue = void 0;
                if (this.isVertical) {
                  pointValue = layerPosition.x;
                } else {
                  pointValue = layerPosition.y;
                }
                return {
                  indexes: {
                    groupIndex: this.tickBaseCoordinateModel.findIndex(pointValue)
                  }
                };
              };
              GroupTypeEventDetector2.prototype._findDataForZoomable = function _findDataForZoomable(clientX, clientY) {
                return this._findGroupData(clientX, clientY);
              };
              GroupTypeEventDetector2.prototype._getFirstData = function _getFirstData() {
                return {
                  indexes: {
                    groupIndex: 0
                  }
                };
              };
              GroupTypeEventDetector2.prototype._getLastData = function _getLastData() {
                return {
                  indexes: {
                    groupIndex: this.tickBaseCoordinateModel.getLastIndex()
                  }
                };
              };
              GroupTypeEventDetector2.prototype._isOuterPosition = function _isOuterPosition(layerX, layerY) {
                var _dimension = this.dimension, width = _dimension.width, height = _dimension.height;
                var _layout$position = this.layout.position, top = _layout$position.top, left = _layout$position.left;
                return layerX < left || layerX > left + width || layerY < top || layerY > top + height;
              };
              GroupTypeEventDetector2.prototype._showTooltip = function _showTooltip(foundData, isMoving) {
                var index = foundData.indexes.groupIndex;
                var positionValue = (this.isVertical ? this.layout.position.left : this.layout.position.top) - _const2["default"].CHART_PADDING;
                var tickCoordinateModel = this.tickBaseCoordinateModel.data;
                var tickCoordsModelSize = tickCoordinateModel.length;
                var isValidShowTooltip = this.pointOnColumn ? tickCoordsModelSize - 1 > index : tickCoordsModelSize > index;
                if (isValidShowTooltip) {
                  var tickInterval = 0;
                  if (this.pointOnColumn) {
                    var _tickCoordinateModel = _slicedToArray(tickCoordinateModel, 1), _tickCoordinateModel$ = _tickCoordinateModel[0], min = _tickCoordinateModel$.min, max = _tickCoordinateModel$.max;
                    tickInterval = max - min;
                  }
                  this.eventBus.fire("showTooltip", {
                    index,
                    range: this.tickBaseCoordinateModel.makeRange(index, positionValue),
                    size: this.dimension[this.sizeType],
                    isVertical: this.isVertical,
                    isMoving,
                    silent: foundData.silent,
                    tickInterval
                  });
                  this.prevIndex = index;
                }
              };
              GroupTypeEventDetector2.prototype._hideTooltip = function _hideTooltip(options) {
                this.eventBus.fire("hideTooltip", this.prevIndex, options);
                this.prevIndex = null;
              };
              GroupTypeEventDetector2.prototype._onMousemove = function _onMousemove(e) {
                if (this.zoomable && this._isAfterDragMouseup()) {
                  return;
                }
                var foundData = this._findGroupData(e.clientX, e.clientY);
                var index = foundData.indexes.groupIndex;
                if (index === -1) {
                  this._onMouseout(e);
                } else if (this.prevIndex !== index) {
                  this._showTooltip(foundData);
                }
              };
              GroupTypeEventDetector2.prototype._onMouseout = function _onMouseout(e) {
                var _calculateLayerPositi = this._calculateLayerPosition(e.clientX, e.clientY, false), x = _calculateLayerPositi.x, y = _calculateLayerPositi.y;
                if (this._isOuterPosition(x, y) && !(0, _isNull2["default"])(this.prevIndex)) {
                  this._hideTooltip();
                }
              };
              return GroupTypeEventDetector2;
            }(_mouseEventDetectorBase2["default"]);
            function groupTypeEventDetectorFactory(params) {
              return new GroupTypeEventDetector(params);
            }
            groupTypeEventDetectorFactory.componentType = "mouseEventDetector";
          },
          /* 107 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = boundsTypeEventDetectorFactory;
            var _mouseEventDetectorBase = __webpack_require__(98);
            var _mouseEventDetectorBase2 = _interopRequireDefault(_mouseEventDetectorBase);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _domHandler = __webpack_require__(24);
            var _domHandler2 = _interopRequireDefault(_domHandler);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var BoundsTypeEventDetector = function(_EventDetectorBase) {
              _inherits(BoundsTypeEventDetector2, _EventDetectorBase);
              function BoundsTypeEventDetector2() {
                _classCallCheck(this, BoundsTypeEventDetector2);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                var _this = _possibleConstructorReturn(this, _EventDetectorBase.call.apply(_EventDetectorBase, [this].concat(args)));
                _this.prevFoundData = null;
                _this.zoomHistory = [-1];
                _this.historyBackBtn = null;
                return _this;
              }
              BoundsTypeEventDetector2.prototype._attachToEventBus = function _attachToEventBus() {
                _mouseEventDetectorBase2["default"].prototype._attachToEventBus.call(this);
                this.eventBus.on("afterZoom", this.onAfterZoom, this);
              };
              BoundsTypeEventDetector2.prototype._showTooltip = function _showTooltip(foundData) {
                this.eventBus.fire("showTooltip", foundData);
                this.prevFoundData = foundData;
              };
              BoundsTypeEventDetector2.prototype._hideTooltip = function _hideTooltip(options) {
                this.eventBus.fire("hideTooltip", this.prevFoundData, options);
                this.prevFoundData = null;
                this.styleCursor(false);
              };
              BoundsTypeEventDetector2.prototype.styleCursor = function styleCursor(hasChild) {
                var container = this.mouseEventDetectorContainer;
                if (hasChild) {
                  container.style.cursor = "pointer";
                } else {
                  container.style.cursor = "default";
                }
              };
              BoundsTypeEventDetector2.prototype._onMousemove = function _onMousemove(_ref) {
                var clientX = _ref.clientX, clientY = _ref.clientY;
                var layerPosition = this._calculateLayerPosition(clientX, clientY);
                var foundData = this._findDataFromBoundsCoordinateModel(layerPosition);
                if (!this._isChangedSelectData(this.prevFoundData, foundData)) {
                  return;
                }
                if (this.prevFoundData) {
                  this._hideTooltip();
                }
                this.prevFoundData = foundData;
                if (!foundData) {
                  return;
                }
                if (_predicate2["default"].isTreemapChart(this.chartType)) {
                  var seriesItem = this._getSeriesItemByIndexes(foundData.indexes);
                  this.styleCursor(seriesItem.hasChild);
                } else if (_predicate2["default"].isBulletChart(this.chartType)) {
                  foundData.mousePosition = {
                    left: clientX,
                    top: clientY
                  };
                }
                this._showTooltip(foundData);
              };
              BoundsTypeEventDetector2.prototype._zoomHistoryBack = function _zoomHistoryBack() {
                var index = this.zoomHistory[this.zoomHistory.length - 2];
                this.zoomHistory.pop();
                this.eventBus.fire("zoom", index);
                if (this.zoomHistory.length === 1) {
                  this.mouseEventDetectorContainer.removeChild(this.historyBackBtn);
                  this.historyBackBtn = null;
                }
              };
              BoundsTypeEventDetector2.prototype._getSeriesItemByIndexes = function _getSeriesItemByIndexes(indexes) {
                var seriesDataModel = this.dataProcessor.getSeriesDataModel(_const2["default"].CHART_TYPE_TREEMAP);
                return seriesDataModel.getSeriesItem(indexes.groupIndex, indexes.index, true);
              };
              BoundsTypeEventDetector2.prototype._onClick = function _onClick(e) {
                var target = e.target || e.srcElement;
                _mouseEventDetectorBase2["default"].prototype._onClick.call(this, e);
                if (!_predicate2["default"].isTreemapChart(this.chartType)) {
                  return;
                }
                if (_domHandler2["default"].hasClass(target, _const2["default"].CLASS_NAME_RESET_ZOOM_BTN)) {
                  this._hideTooltip();
                  this._zoomHistoryBack();
                  return;
                }
                var layerPosition = this._calculateLayerPosition(e.clientX, e.clientY);
                var foundData = this._findDataFromBoundsCoordinateModel(layerPosition);
                if (foundData) {
                  var seriesItem = this._getSeriesItemByIndexes(foundData.indexes);
                  if (!seriesItem.hasChild) {
                    return;
                  }
                  this._hideTooltip();
                  this.eventBus.fire("zoom", foundData.indexes.index);
                }
              };
              BoundsTypeEventDetector2.prototype._onMouseout = function _onMouseout(_ref2) {
                var clientX = _ref2.clientX, clientY = _ref2.clientY;
                var bound = this.mouseEventDetectorContainer.getBoundingClientRect();
                var left = bound.left, right = bound.right, top = bound.top, bottom = bound.bottom;
                if (left <= clientX && top <= clientY && right >= clientX && bottom >= clientY) {
                  return;
                }
                if (this.prevFoundData) {
                  this._hideTooltip();
                }
                this.prevFoundData = null;
              };
              BoundsTypeEventDetector2.prototype.onAfterZoom = function onAfterZoom(index) {
                if (!this.historyBackBtn) {
                  this.historyBackBtn = _domHandler2["default"].create("DIV", _const2["default"].CLASS_NAME_RESET_ZOOM_BTN);
                  _domHandler2["default"].append(this.mouseEventDetectorContainer, this.historyBackBtn);
                }
                if (this.zoomHistory[this.zoomHistory.length - 1] !== index) {
                  this.zoomHistory.push(index);
                }
              };
              BoundsTypeEventDetector2.prototype.findDataByIndexes = function findDataByIndexes(indexes) {
                return this.boundsBaseCoordinateModel.findDataByIndexes(indexes);
              };
              return BoundsTypeEventDetector2;
            }(_mouseEventDetectorBase2["default"]);
            function boundsTypeEventDetectorFactory(params) {
              return new BoundsTypeEventDetector(params);
            }
            boundsTypeEventDetectorFactory.componentType = "mouseEventDetector";
          },
          /* 108 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = barSeriesFactory;
            var _series = __webpack_require__(109);
            var _series2 = _interopRequireDefault(_series);
            var _barTypeSeriesBase = __webpack_require__(110);
            var _barTypeSeriesBase2 = _interopRequireDefault(_barTypeSeriesBase);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var OVERLAPPING_WIDTH = _const2["default"].OVERLAPPING_WIDTH, TEXT_PADDING = _const2["default"].TEXT_PADDING;
            var BarChartSeries = function(_Series) {
              _inherits(BarChartSeries2, _Series);
              function BarChartSeries2() {
                _classCallCheck(this, BarChartSeries2);
                return _possibleConstructorReturn(this, _Series.apply(this, arguments));
              }
              BarChartSeries2.prototype._makeBound = function _makeBound(width, height, top, startLeft, endLeft) {
                return {
                  start: {
                    top,
                    left: startLeft,
                    width: 0,
                    height
                  },
                  end: {
                    top,
                    left: endLeft,
                    width,
                    height
                  }
                };
              };
              BarChartSeries2.prototype._calculateAdditionalLeft = function _calculateAdditionalLeft(value) {
                var additionalLeft = 0;
                if (this.options.divided && value > 0) {
                  additionalLeft = this.dimensionMap.yAxis.width + OVERLAPPING_WIDTH;
                }
                return additionalLeft;
              };
              BarChartSeries2.prototype._makeBarChartBound = function _makeBarChartBound(baseData, iterationData, isStackType, seriesItem, index) {
                var baseBarSize = baseData.baseBarSize, basePosition = baseData.basePosition, barSize = baseData.barSize, itemCount = baseData.itemCount, groupSize = baseData.groupSize, pointInterval = baseData.pointInterval;
                var ratioDistance = seriesItem.ratioDistance, value = seriesItem.value, startRatio = seriesItem.startRatio, stack = seriesItem.stack;
                var barWidth = baseBarSize * ratioDistance;
                var additionalLeft = this._calculateAdditionalLeft(value);
                var barStartLeft = baseBarSize * startRatio;
                var startLeft = basePosition + barStartLeft + additionalLeft;
                var changedStack = stack !== iterationData.prevStack;
                var isOverLapBar = barSize * itemCount > groupSize;
                var barInterval = isOverLapBar ? pointInterval : barSize;
                var endLeft = void 0;
                if (!isStackType || !this.options.diverging && changedStack) {
                  var pointCount = isStackType ? this.dataProcessor.findStackIndex(stack) : index;
                  iterationData.top = iterationData.baseTop + barInterval * pointCount;
                  iterationData.plusLeft = 0;
                  iterationData.minusLeft = 0;
                }
                if (value >= 0) {
                  endLeft = startLeft + iterationData.plusLeft;
                  iterationData.plusLeft += barWidth;
                } else {
                  iterationData.minusLeft -= barWidth;
                  endLeft = startLeft + iterationData.minusLeft;
                }
                iterationData.prevStack = stack;
                var boundTop = iterationData.top + pointInterval - barSize / 2;
                if (!isOverLapBar) {
                  boundTop += (pointInterval - barSize) / 2 * (itemCount - 1);
                }
                return this._makeBound(barWidth, barSize, boundTop, startLeft, endLeft);
              };
              BarChartSeries2.prototype._makeBounds = function _makeBounds() {
                var _this2 = this;
                var seriesDataModel = this._getSeriesDataModel();
                var isStacked = _predicate2["default"].isValidStackOption(this.options.stack);
                var _layout = this.layout, _layout$dimension = _layout.dimension, width = _layout$dimension.width, height = _layout$dimension.height, top = _layout.position.top;
                var baseData = this._makeBaseDataForMakingBound(height, width);
                return seriesDataModel.map(function(seriesGroup, groupIndex) {
                  var baseTop = groupIndex * baseData.groupSize + top;
                  var iterationData = {
                    baseTop,
                    top: baseTop,
                    plusLeft: 0,
                    minusLeft: 0,
                    prevStack: null
                  };
                  var iteratee = _this2._makeBarChartBound.bind(_this2, baseData, iterationData, isStacked);
                  return seriesGroup.map(iteratee);
                });
              };
              BarChartSeries2.prototype._calculateTopPositionOfSumLabel = function _calculateTopPositionOfSumLabel(bound, labelHeight) {
                return bound.top + (bound.height - labelHeight + TEXT_PADDING) / 2;
              };
              return BarChartSeries2;
            }(_series2["default"]);
            _barTypeSeriesBase2["default"].mixin(BarChartSeries);
            function barSeriesFactory(params) {
              var chartTheme = params.chartTheme, libType = params.chartOptions.libType;
              params.libType = libType;
              params.chartType = "bar";
              params.chartBackground = chartTheme.chart.background;
              return new BarChartSeries(params);
            }
            barSeriesFactory.componentType = "series";
            barSeriesFactory.BarChartSeries = BarChartSeries;
          },
          /* 109 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isArray = __webpack_require__(9);
            var _isArray2 = _interopRequireDefault(_isArray);
            var _isEmpty = __webpack_require__(83);
            var _isEmpty2 = _interopRequireDefault(_isEmpty);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _domHandler = __webpack_require__(24);
            var _domHandler2 = _interopRequireDefault(_domHandler);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _pluginFactory = __webpack_require__(51);
            var _pluginFactory2 = _interopRequireDefault(_pluginFactory);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var COMPONENT_TYPE_RAPHAEL = _const2["default"].COMPONENT_TYPE_RAPHAEL, PUBLIC_EVENT_PREFIX = _const2["default"].PUBLIC_EVENT_PREFIX, CLASS_NAME_SERIES_LABEL = _const2["default"].CLASS_NAME_SERIES_LABEL;
            var Series = function() {
              function Series2(params) {
                _classCallCheck(this, Series2);
                var libType = params.libType;
                this.className = "tui-chart-series-area";
                this.chartType = params.chartType;
                this.seriesType = params.seriesType || params.chartType;
                this.componentType = params.componentType;
                this.dataProcessor = params.dataProcessor;
                this.eventBus = params.eventBus;
                this.chartBackground = params.chartBackground;
                this.options = params.options || {};
                this.orgTheme = this.theme = params.theme;
                this.graphRenderer = _pluginFactory2["default"].get(libType, params.chartType);
                this.seriesContainer = null;
                this.seriesLabelContainer = null;
                this.seriesData = {};
                this.selectedLegendIndex = null;
                this.labelShowEffector = null;
                this.paper = null;
                this.limit = null;
                this.aligned = null;
                this.layout = null;
                this.dimensionMap = null;
                this.positionMap = null;
                this.axisDataMap = null;
                this.beforeAxisDataMap = null;
                this.drawingType = COMPONENT_TYPE_RAPHAEL;
                this.supportSeriesLable = true;
                this._attachToEventBus();
              }
              Series2.prototype.decorateLabel = function decorateLabel(targetLabel) {
                var _options = this.options, _options$labelPrefix = _options.labelPrefix, labelPrefix = _options$labelPrefix === void 0 ? "" : _options$labelPrefix, _options$labelSuffix = _options.labelSuffix, labelSuffix = _options$labelSuffix === void 0 ? "" : _options$labelSuffix;
                var addPrefixSuffix = _renderUtil2["default"].addPrefixSuffix, addPrefixSuffixItem = _renderUtil2["default"].addPrefixSuffixItem;
                var decorateFunc = ((0, _isArray2["default"])(targetLabel) ? addPrefixSuffix : addPrefixSuffixItem).bind(_renderUtil2["default"]);
                return decorateFunc(targetLabel, labelPrefix, labelSuffix);
              };
              Series2.prototype.presetForChangeData = function presetForChangeData() {
                var theme = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.orgTheme;
                this.orgTheme = theme;
                this.theme = theme;
                if (this.chartType === "treemap") {
                  this.boundMap = null;
                }
              };
              Series2.prototype._attachToEventBus = function _attachToEventBus() {
                var firstRenderCheck = function() {
                  this.isInitRenderCompleted = true;
                  this.eventBus.off("load", firstRenderCheck);
                }.bind(this);
                this.eventBus.on(PUBLIC_EVENT_PREFIX + "load", firstRenderCheck);
                this.eventBus.on({
                  selectLegend: this.onSelectLegend,
                  selectSeries: this.onSelectSeries,
                  unselectSeries: this.onUnselectSeries,
                  hoverSeries: this.onHoverSeries,
                  hoverOffSeries: this.onHoverOffSeries,
                  showGroupAnimation: this.onShowGroupAnimation,
                  hideGroupAnimation: this.onHideGroupAnimation
                }, this);
                if (this.onShowTooltip) {
                  this.eventBus.on("showTooltip", this.onShowTooltip, this);
                }
                if (this.onShowGroupTooltipLine) {
                  this.eventBus.on({
                    showGroupTooltipLine: this.onShowGroupTooltipLine,
                    hideGroupTooltipLine: this.onHideGroupTooltipLine
                  }, this);
                }
                if (this.onClickSeries) {
                  this.eventBus.on({
                    clickSeries: this.onClickSeries,
                    moveSeries: this.onMoveSeries
                  }, this);
                }
              };
              Series2.prototype._getSeriesDataModel = function _getSeriesDataModel() {
                return this.dataProcessor.getSeriesDataModel(this.seriesType);
              };
              Series2.prototype._makeSeriesData = function _makeSeriesData() {
              };
              Series2.prototype.getSeriesData = function getSeriesData() {
                return this.seriesData;
              };
              Series2.prototype._renderSeriesLabel = function _renderSeriesLabel() {
              };
              Series2.prototype._renderConnector = function _renderConnector() {
              };
              Series2.prototype._renderSeriesLabelArea = function _renderSeriesLabelArea(paper) {
                return this._renderSeriesLabel(paper);
              };
              Series2.prototype._sendBoundsToMouseEventDetector = function _sendBoundsToMouseEventDetector(seriesData) {
                this.eventBus.fire("receiveSeriesData", {
                  chartType: this.chartType,
                  data: seriesData
                });
              };
              Series2.prototype._renderSeriesArea = function _renderSeriesArea(paper, funcRenderGraph) {
                var dimension = this.dimensionMap.extendedSeries;
                var seriesData = this.seriesData = this._makeSeriesData();
                this._sendBoundsToMouseEventDetector(seriesData);
                if (this.hasDataForRendering(seriesData) || this.chartType === "map") {
                  if (funcRenderGraph) {
                    this.seriesSet = funcRenderGraph(dimension, seriesData, paper);
                  }
                  if (_predicate2["default"].isShowLabel(this.options) && this.supportSeriesLable) {
                    this.labelSet = this._renderSeriesLabelArea(paper);
                  }
                  if (_predicate2["default"].isBarTypeChart(this.chartType) && _predicate2["default"].isValidStackOption(this.options.stack) && _predicate2["default"].isRenderConnector(this.options.stack.connector)) {
                    this.connectorSet = this._renderConnector(paper, seriesData, this.options.stack);
                  }
                }
              };
              Series2.prototype._makeParamsForGraphRendering = function _makeParamsForGraphRendering(dimension, seriesData) {
                return Object.assign({
                  dimension,
                  position: this.layout.position,
                  chartType: this.seriesType,
                  theme: this.theme,
                  options: this.options
                }, seriesData);
              };
              Series2.prototype._renderGraph = function _renderGraph(dimension, seriesData, paper) {
                var params = this._makeParamsForGraphRendering(dimension, seriesData);
                return this.graphRenderer.render(paper, params);
              };
              Series2.prototype._setDataForRendering = function _setDataForRendering(data) {
                this.paper = data.paper;
                this.limit = data.limitMap[this.chartType];
                if (data.axisDataMap && data.axisDataMap.xAxis) {
                  this.aligned = data.axisDataMap.xAxis.aligned;
                }
                this.layout = data.layout;
                this.dimensionMap = data.dimensionMap;
                this.positionMap = data.positionMap;
                this.axisDataMap = data.axisDataMap;
              };
              Series2.prototype.render = function render(data) {
                this.paper = data.paper;
                this._setDataForRendering(data);
                this._clearSeriesContainer();
                this.beforeAxisDataMap = this.axisDataMap;
                if (data.checkedLegends) {
                  var checkedLegends = data.checkedLegends[this.seriesType];
                  if (!this.options.colorByPoint) {
                    this.theme = this._getCheckedSeriesTheme(this.orgTheme, checkedLegends);
                  }
                }
                this._renderSeriesArea(data.paper, this._renderGraph.bind(this));
                if (this.paper.pushDownBackgroundToBottom) {
                  this.paper.pushDownBackgroundToBottom();
                }
              };
              Series2.prototype._getCheckedSeriesTheme = function _getCheckedSeriesTheme(theme, checkedLegends) {
                if (!checkedLegends.length) {
                  return theme;
                }
                var cloneTheme = JSON.parse(JSON.stringify(theme));
                cloneTheme.colors = cloneTheme.colors.filter(function(color, index) {
                  return checkedLegends[index];
                });
                return cloneTheme;
              };
              Series2.prototype._clearSeriesContainer = function _clearSeriesContainer() {
                if (this.seriesSet && this.seriesSet.remove) {
                  this.seriesSet.forEach(function(series) {
                    series.remove();
                  }, this);
                  this.seriesSet.remove();
                }
                if (this.labelSet && this.labelSet.remove) {
                  this.labelSet.forEach(function(label) {
                    label.remove();
                  }, this);
                  this.labelSet.remove();
                }
                if (this.connectorSet && this.connectorSet.remove) {
                  this.connectorSet.forEach(function(label) {
                    label.remove();
                  }, this);
                  this.connectorSet.remove();
                }
                this.seriesData = {};
              };
              Series2.prototype.rerender = function rerender(data) {
                var checkedLegends = void 0;
                if (this.seriesType === "map" || this.dataProcessor.getGroupCount(this.seriesType)) {
                  if (data.checkedLegends) {
                    checkedLegends = data.checkedLegends[this.seriesType];
                    this.theme = this._getCheckedSeriesTheme(this.orgTheme, checkedLegends);
                  }
                  this._setDataForRendering(data);
                  this._clearSeriesContainer();
                  this._renderSeriesArea(data.paper, this._renderGraph.bind(this));
                  if (this.labelShowEffector) {
                    clearInterval(this.labelShowEffector.timerId);
                  }
                  if (checkedLegends || !this.isInitRenderCompleted) {
                    this.animateComponent(true);
                  }
                  if (!(0, _isNull2["default"])(this.selectedLegendIndex)) {
                    this.graphRenderer.selectLegend(this.selectedLegendIndex);
                  }
                } else {
                  this._clearSeriesContainer();
                }
              };
              Series2.prototype._isLabelVisible = function _isLabelVisible() {
                return !!(this.options.showLabel || this.options.showLegend);
              };
              Series2.prototype._resizeGraph = function _resizeGraph(dimension, seriesData) {
                this.graphRenderer.resize(Object.assign({
                  dimension: this.dimensionMap.chart
                }, seriesData));
                return this.seriesSet;
              };
              Series2.prototype.resize = function resize(data) {
                this._clearSeriesContainer();
                this._setDataForRendering(data);
                this._renderSeriesArea(data.paper, this._resizeGraph.bind(this));
                this.rerender(data);
              };
              Series2.prototype._renderPosition = function _renderPosition(el, position) {
                var hiddenWidth = _renderUtil2["default"].isOldBrowser() ? 1 : 0;
                _renderUtil2["default"].renderPosition(el, {
                  top: position.top - hiddenWidth,
                  left: position.left - hiddenWidth * 2
                });
              };
              Series2.prototype._getLimitDistanceFromZeroPoint = function _getLimitDistanceFromZeroPoint(size, limit) {
                var min = limit.min, max = limit.max;
                var distance = max - min;
                var toMax = 0;
                var toMin = 0;
                if (min <= 0 && max >= 0) {
                  toMax = (distance + min) / distance * size;
                  toMin = (distance - max) / distance * size;
                } else if (min > 0) {
                  toMax = size;
                }
                return {
                  toMax,
                  toMin
                };
              };
              Series2.prototype._findLabelElement = function _findLabelElement(elTarget) {
                if (_domHandler2["default"].hasClass(elTarget, CLASS_NAME_SERIES_LABEL)) {
                  return elTarget;
                }
                return _domHandler2["default"].findParentByClass(elTarget, CLASS_NAME_SERIES_LABEL);
              };
              Series2.prototype.onHoverSeries = function onHoverSeries(data, chartType) {
                if (chartType !== this.chartType) {
                  return;
                }
                if (!this.graphRenderer.showAnimation) {
                  return;
                }
                this.graphRenderer.showAnimation(data);
              };
              Series2.prototype.onHoverOffSeries = function onHoverOffSeries(data, chartType) {
                if (chartType !== this.chartType) {
                  return;
                }
                if (!this.graphRenderer.hideAnimation || !data) {
                  return;
                }
                this.graphRenderer.hideAnimation(data);
              };
              Series2.prototype.onShowGroupAnimation = function onShowGroupAnimation(index) {
                if (!this.graphRenderer.showGroupAnimation) {
                  return;
                }
                this.graphRenderer.showGroupAnimation(index);
              };
              Series2.prototype.onHideGroupAnimation = function onHideGroupAnimation(index) {
                if (!this.graphRenderer.hideGroupAnimation) {
                  return;
                }
                this.graphRenderer.hideGroupAnimation(index);
              };
              Series2.prototype.animateComponent = function animateComponent(isRerendering) {
                var _this = this;
                if (this.graphRenderer.animate) {
                  if (this.seriesSet) {
                    this.graphRenderer.animate(this.animateSeriesLabelArea.bind(this, isRerendering), this.seriesSet);
                  }
                  if (this.connectorSet) {
                    this.graphRenderer.animate(this.animateSeriesConnector.bind(this, isRerendering), this.connectorSet);
                  }
                } else {
                  this.animateSeriesLabelArea(isRerendering);
                  this.animateSeriesConnector();
                }
                setTimeout(function() {
                  _this.options.animationDuration = _raphaelRenderUtil2["default"].getDefaultAnimationDuration(_this.chartType);
                });
              };
              Series2.prototype._fireLoadEvent = function _fireLoadEvent(isRerendering) {
                if (!isRerendering) {
                  this.eventBus.fire(PUBLIC_EVENT_PREFIX + "load");
                }
              };
              Series2.prototype.animateSeriesLabelArea = function animateSeriesLabelArea(isRerendering) {
                if (!this._isLabelVisible()) {
                  this._fireLoadEvent(isRerendering);
                  return;
                }
                if (this.labelSet && this.labelSet.length) {
                  _raphaelRenderUtil2["default"].animateOpacity(this.labelSet, 0, 1, this.options.animationDuration);
                }
              };
              Series2.prototype.animateSeriesConnector = function animateSeriesConnector() {
                if (this.connectorSet && this.connectorSet.length) {
                  _raphaelRenderUtil2["default"].animateOpacity(this.connectorSet, 0, 1, this.options.animationDuration);
                }
              };
              Series2.prototype._makeExportationSeriesData = function _makeExportationSeriesData(seriesData) {
                var indexes = seriesData.indexes;
                var legendIndex = (0, _isExisty2["default"])(indexes.legendIndex) ? indexes.legendIndex : indexes.index;
                var legendData = this.dataProcessor.getLegendItem(legendIndex);
                var index = (0, _isExisty2["default"])(indexes.groupIndex) ? indexes.groupIndex : 0;
                var seriesItem = this._getSeriesDataModel().getSeriesItem(index, indexes.index);
                var result = void 0;
                if ((0, _isExisty2["default"])(seriesItem)) {
                  result = {
                    chartType: legendData.chartType,
                    legend: legendData.label,
                    legendIndex
                  };
                  result.index = seriesItem.index;
                }
                return result;
              };
              Series2.prototype._executeGraphRenderer = function _executeGraphRenderer(position, funcName) {
                var isShowLabel = false;
                this.eventBus.fire("hideTooltipContainer");
                if (this.seriesLabelContainer && _domHandler2["default"].hasClass(this.seriesLabelContainer, "show")) {
                  _domHandler2["default"].removeClass(this.seriesLabelContainer, "show");
                  isShowLabel = true;
                }
                var result = this.graphRenderer[funcName](position);
                if (isShowLabel) {
                  _domHandler2["default"].addClass(this.seriesLabelContainer, "show");
                }
                this.eventBus.fire("showTooltipContainer");
                return result;
              };
              Series2.prototype.onSelectSeries = function onSelectSeries(seriesData, shouldSelect) {
                if (seriesData.chartType !== this.chartType) {
                  return;
                }
                var eventName = PUBLIC_EVENT_PREFIX + "selectSeries";
                this.eventBus.fire(eventName, this._makeExportationSeriesData(seriesData));
                shouldSelect = (0, _isEmpty2["default"])(shouldSelect) ? true : shouldSelect;
                if (this.options.allowSelect && this.graphRenderer.selectSeries && shouldSelect) {
                  this.graphRenderer.selectSeries(seriesData.indexes);
                }
              };
              Series2.prototype.onUnselectSeries = function onUnselectSeries(seriesData) {
                if (seriesData.chartType !== this.chartType) {
                  return;
                }
                var eventName = PUBLIC_EVENT_PREFIX + "unselectSeries";
                this.eventBus.fire(eventName, this._makeExportationSeriesData(seriesData));
                if (this.options.allowSelect && this.graphRenderer.unselectSeries) {
                  this.graphRenderer.unselectSeries(seriesData.indexes);
                }
              };
              Series2.prototype.onSelectLegend = function onSelectLegend(seriesType, legendIndex) {
                if (this.seriesType !== seriesType && !(0, _isNull2["default"])(legendIndex)) {
                  legendIndex = -1;
                }
                this.selectedLegendIndex = legendIndex;
                if (this._getSeriesDataModel().getGroupCount()) {
                  this.graphRenderer.selectLegend(legendIndex);
                }
              };
              Series2.prototype.showLabel = function showLabel() {
                this.options.showLabel = true;
                if (!this.seriesLabelContainer && this.supportSeriesLable) {
                  this._renderSeriesLabelArea(this.paper);
                }
              };
              Series2.prototype.hideLabel = function hideLabel() {
                this.options.showLabel = false;
                if (this.seriesLabelContainer) {
                  _domHandler2["default"].removeClass(this.seriesLabelContainer, "show");
                  _domHandler2["default"].removeClass(this.seriesLabelContainer, "opacity");
                }
              };
              Series2.prototype.isAvailableSeriesData = function isAvailableSeriesData() {
                return !!(this.seriesData && this.seriesData.isAvailable && this.seriesData.isAvailable());
              };
              Series2.prototype.hasDataForRendering = function hasDataForRendering(seriesData) {
                return !!(seriesData && seriesData.isAvailable());
              };
              return Series2;
            }();
            exports2["default"] = Series;
          },
          /* 110 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _renderingLabelHelper = __webpack_require__(111);
            var _renderingLabelHelper2 = _interopRequireDefault(_renderingLabelHelper);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var CHART_PADDING = _const2["default"].CHART_PADDING, LEGEND_LABEL_LEFT_PADDING = _const2["default"].LEGEND_LABEL_LEFT_PADDING;
            var DEFAULT_BAR_SIZE_RATIO_BY_POINT_INTERVAL = 0.85;
            var BarTypeSeriesBase = function() {
              function BarTypeSeriesBase2() {
                _classCallCheck(this, BarTypeSeriesBase2);
              }
              BarTypeSeriesBase2.prototype._makeSeriesData = function _makeSeriesData() {
                var groupBounds = this._makeBounds(this.layout.dimension);
                this.groupBounds = groupBounds;
                return {
                  groupBounds,
                  seriesDataModel: this._getSeriesDataModel(),
                  isAvailable: function isAvailable() {
                    return groupBounds && groupBounds.length > 0;
                  }
                };
              };
              BarTypeSeriesBase2.prototype._getBarWidthOptionSize = function _getBarWidthOptionSize(pointInterval, optionBarWidth) {
                var optionsSize = 0;
                if (optionBarWidth) {
                  if (optionBarWidth / 2 >= pointInterval) {
                    optionBarWidth = pointInterval * 2;
                  } else if (optionBarWidth < 0) {
                    optionBarWidth = 0;
                  }
                  optionsSize = optionBarWidth;
                }
                return optionsSize;
              };
              BarTypeSeriesBase2.prototype._calculateAdditionalPosition = function _calculateAdditionalPosition(barSize, optionSize, itemCount) {
                var additionalPosition = 0;
                if (optionSize && optionSize < barSize) {
                  additionalPosition = barSize / 2 + (barSize - optionSize) * itemCount / 2;
                }
                return additionalPosition;
              };
              BarTypeSeriesBase2.prototype._makeBaseDataForMakingBound = function _makeBaseDataForMakingBound(baseGroupSize, baseBarSize) {
                var isStackType = _predicate2["default"].isValidStackOption(this.options.stack);
                var seriesDataModel = this._getSeriesDataModel();
                var groupSize = baseGroupSize / seriesDataModel.getGroupCount();
                var columnTopOffset = -this.layout.position.top + CHART_PADDING;
                var zeroToMin = this._getLimitDistanceFromZeroPoint(baseBarSize, this.limit).toMin;
                var positionValue = void 0, baseBounds = void 0;
                if (_predicate2["default"].isColumnChart(this.chartType)) {
                  positionValue = columnTopOffset;
                } else if (_predicate2["default"].isBoxplotChart(this.chartType)) {
                  positionValue = this.layout.position.top - CHART_PADDING;
                } else {
                  positionValue = this.layout.position.left;
                }
                if (seriesDataModel.rawSeriesData.length > 0) {
                  var itemCount = void 0;
                  if (!isStackType) {
                    itemCount = seriesDataModel.getFirstSeriesGroup().getSeriesItemCount();
                  } else {
                    itemCount = this.options.diverging ? 1 : this.dataProcessor.getStackCount(this.seriesType);
                  }
                  var pointInterval = groupSize / (itemCount + 1);
                  var optionSize = this.options.barWidth || this.options.pointWidth;
                  var barSize = pointInterval * DEFAULT_BAR_SIZE_RATIO_BY_POINT_INTERVAL;
                  var basePosition = zeroToMin + positionValue;
                  barSize = this._getBarWidthOptionSize(pointInterval, optionSize) || barSize;
                  if (_predicate2["default"].isColumnChart(this.chartType)) {
                    basePosition = baseBarSize - basePosition;
                  }
                  if (_predicate2["default"].isBoxplotChart(this.chartType) && zeroToMin) {
                    basePosition -= zeroToMin * 2;
                  }
                  baseBounds = {
                    baseBarSize,
                    groupSize,
                    barSize,
                    pointInterval,
                    basePosition,
                    itemCount,
                    firstAdditionalPosition: pointInterval
                  };
                }
                return baseBounds;
              };
              BarTypeSeriesBase2.prototype._renderConnector = function _renderConnector(paper, seriesData, stack) {
                return this.graphRenderer.renderConnector(paper, seriesData, stack);
              };
              BarTypeSeriesBase2.prototype._renderNormalSeriesLabel = function _renderNormalSeriesLabel(paper) {
                var _this = this;
                var graphRenderer = this.graphRenderer;
                var seriesDataModel = this._getSeriesDataModel();
                var boundsSet = this.seriesData.groupBounds;
                var labelTheme = this.theme.label;
                var selectedIndex = this.selectedLegendIndex;
                var groupLabels = seriesDataModel.map(function(seriesGroup) {
                  return seriesGroup.map(function(_ref) {
                    var start = _ref.start, startLabel = _ref.startLabel, endLabel = _ref.endLabel;
                    var label = {
                      end: _this.decorateLabel(endLabel)
                    };
                    if ((0, _isExisty2["default"])(start)) {
                      label.start = _this.decorateLabel(startLabel);
                    }
                    return label;
                  });
                });
                var positionsSet = void 0;
                if (_predicate2["default"].isBarChart(this.chartType)) {
                  positionsSet = _renderingLabelHelper2["default"].boundsToLabelPositionsForBarChart(seriesDataModel, boundsSet, labelTheme);
                } else {
                  positionsSet = _renderingLabelHelper2["default"].boundsToLabelPositionsForColumnChart(seriesDataModel, boundsSet, labelTheme);
                }
                return graphRenderer.renderSeriesLabel(paper, positionsSet, groupLabels, labelTheme, selectedIndex);
              };
              BarTypeSeriesBase2.prototype._makeSumValues = function _makeSumValues(values) {
                return _renderUtil2["default"].formatValue({
                  value: _calculator2["default"].sum(values),
                  formatFunctions: this.dataProcessor.getFormatFunctions(),
                  chartType: this.chartType,
                  areaType: "series"
                });
              };
              BarTypeSeriesBase2.prototype._makeStackedLabelPosition = function _makeStackedLabelPosition(_ref2) {
                var top = _ref2.top, left = _ref2.left, width = _ref2.width, height = _ref2.height;
                return {
                  left: left + width / 2,
                  top: top + height / 2
                };
              };
              BarTypeSeriesBase2.prototype._makeStackedLabelPositions = function _makeStackedLabelPositions(params) {
                var _this2 = this;
                var seriesGroup = params.seriesGroup;
                var positions = seriesGroup.map(function(seriesItem, index) {
                  var bound = params.bounds[index];
                  var position = void 0;
                  if (bound && seriesItem) {
                    position = _this2._makeStackedLabelPosition(bound.end);
                  }
                  return {
                    end: position
                  };
                });
                return positions;
              };
              BarTypeSeriesBase2.prototype.getGroupLabels = function getGroupLabels(seriesDataModel, sumPlusValues, sumMinusValues) {
                var _this3 = this;
                var isNormalStack = _predicate2["default"].isNormalStack(this.options.stack);
                return seriesDataModel.map(function(seriesGroup) {
                  var labels = seriesGroup.map(function(seriesDatum) {
                    return {
                      end: _this3.decorateLabel(seriesDatum.endLabel)
                    };
                  });
                  if (isNormalStack) {
                    sumPlusValues.push(_calculator2["default"].sumPlusValues(seriesGroup.pluck("value")));
                    var minusSum = _calculator2["default"].sumMinusValues(seriesGroup.pluck("value"));
                    if (minusSum < 0) {
                      sumMinusValues.push(minusSum);
                    }
                  }
                  return labels;
                });
              };
              BarTypeSeriesBase2.prototype.getGroupPositions = function getGroupPositions(seriesDataModel, groupBounds) {
                var _this4 = this;
                return seriesDataModel.map(function(seriesGroup, index) {
                  return _this4._makeStackedLabelPositions({
                    seriesGroup,
                    bounds: groupBounds[index]
                  });
                });
              };
              BarTypeSeriesBase2.prototype._renderStackedSeriesLabel = function _renderStackedSeriesLabel(paper) {
                var _this5 = this;
                var sumPlusValues = [];
                var sumMinusValues = [];
                var labelTheme = this.theme.label;
                var groupBounds = this.seriesData.groupBounds;
                var seriesDataModel = this._getSeriesDataModel();
                var groupPositions = this.getGroupPositions(seriesDataModel, groupBounds);
                var groupLabels = this.getGroupLabels(seriesDataModel, sumPlusValues, sumMinusValues);
                var isStacked = true;
                var isNormalStack = _predicate2["default"].isNormalStack(this.options.stack);
                var isBarChart = _predicate2["default"].isBarChart(this.chartType);
                var dimensionType = isBarChart ? "width" : "height";
                var positionType = isBarChart ? "left" : "top";
                var direction = isBarChart ? 1 : -1;
                if (isNormalStack) {
                  groupLabels.forEach(function(labels, index) {
                    var plusSumValue = sumPlusValues[index];
                    var minusSumValue = sumMinusValues[index];
                    if (minusSumValue < 0 && _this5.options.diverging) {
                      minusSumValue *= -1;
                    }
                    labels.push({
                      end: _this5.decorateLabel(_renderUtil2["default"].formatToComma(plusSumValue))
                    });
                    if (sumMinusValues.length) {
                      labels.push({
                        end: _this5.decorateLabel(_renderUtil2["default"].formatToComma(minusSumValue))
                      });
                    }
                  });
                  groupPositions.forEach(function(positions, index) {
                    var bounds = groupBounds[index];
                    var lastBound = bounds[bounds.length - 1].end;
                    var firstBound = bounds[Math.max(parseInt(bounds.length / 2, 10), 1) - 1].end;
                    var plusEnd = _this5._makeStackedLabelPosition(lastBound);
                    var minusEnd = _this5._makeStackedLabelPosition(firstBound);
                    var plusLabel = sumPlusValues[index];
                    var minusLabel = sumMinusValues[index];
                    var plusLabelSize = _raphaelRenderUtil2["default"].getRenderedTextSize(plusLabel, labelTheme.fontSize, labelTheme.fontFamily);
                    var minusLabelSize = _raphaelRenderUtil2["default"].getRenderedTextSize(minusLabel, labelTheme.fontSize, labelTheme.fontFamily);
                    var lastBoundEndPosition = (lastBound[dimensionType] + plusLabelSize[dimensionType]) / 2;
                    var firstBoundStartPosition = (firstBound[dimensionType] + minusLabelSize[dimensionType]) / 2;
                    plusEnd[positionType] += (lastBoundEndPosition + LEGEND_LABEL_LEFT_PADDING) * direction;
                    minusEnd[positionType] -= (firstBoundStartPosition + LEGEND_LABEL_LEFT_PADDING) * direction;
                    positions.push({
                      end: plusEnd
                    });
                    if (sumMinusValues.length) {
                      positions.push({
                        end: minusEnd
                      });
                    }
                  });
                }
                return this.graphRenderer.renderSeriesLabel(paper, groupPositions, groupLabels, labelTheme, isStacked);
              };
              BarTypeSeriesBase2.prototype._renderSeriesLabel = function _renderSeriesLabel(paper) {
                if (this.options.stack) {
                  return this._renderStackedSeriesLabel(paper);
                }
                return this._renderNormalSeriesLabel(paper);
              };
              return BarTypeSeriesBase2;
            }();
            BarTypeSeriesBase.mixin = function(func) {
              Object.assign(func.prototype, BarTypeSeriesBase.prototype);
            };
            exports2["default"] = BarTypeSeriesBase;
          },
          /* 111 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var MAX_HEIGHT_WORD = _const2["default"].MAX_HEIGHT_WORD, SERIES_LABEL_PADDING = _const2["default"].SERIES_LABEL_PADDING;
            exports2["default"] = {
              /**
               * Calculate left position for center align of series label.
               * @param {{left: number, top: number, width:number, height: number}} bound - bound
               * @returns {number}
               * @private
               */
              _calculateLeftPositionForCenterAlign: function _calculateLeftPositionForCenterAlign(bound) {
                return bound.left + bound.width / 2;
              },
              /**
               * Calculate top position for middle align of series label.
               * @param {{left: number, top: number, width:number, height: number}} bound - bound
               * @returns {number}
               * @private
               */
              _calculateTopPositionForMiddleAlign: function _calculateTopPositionForMiddleAlign(bound) {
                return bound.top + bound.height / 2;
              },
              /**
               * Make position for type of bound for rendering label.
               * @param {{left: number, top: number, width:number, height: number}} bound - bound
               * @returns {{left: number, top: number}}
               * @private
               */
              _makePositionForBoundType: function _makePositionForBoundType(bound) {
                return {
                  left: this._calculateLeftPositionForCenterAlign(bound),
                  top: this._calculateTopPositionForMiddleAlign(bound)
                };
              },
              /**
               * Make position map for rendering label.
               * @param {SeriesItem} seriesItem - series item
               * @param {{left: number, top: number, width: number, height: number}} bound - bound
               * @param {number} labelHeight - label height
               * @param {object} theme - theme for series label
               * @param {function} makePosition - function for making position of label
               * @returns {{end: *}}
               * @private
               */
              _makePositionMap: function _makePositionMap(seriesItem, bound, labelHeight, theme, makePosition) {
                var value = seriesItem.value;
                var isOppositeSide = value >= 0;
                var positionMap = {
                  end: makePosition(bound, labelHeight, seriesItem.endLabel || seriesItem.label, theme, isOppositeSide)
                };
                if (seriesItem.isRange) {
                  isOppositeSide = value < 0;
                  positionMap.start = makePosition(bound, labelHeight, seriesItem.startLabel, theme, isOppositeSide);
                }
                return positionMap;
              },
              /**
               * Bounds to label positions.
               * @param {SeriesDataModel} seriesDataModel - series data model
               * @param {Array.<Array.<{left: number, top: number, width: number, height: number}>>} boundsSet - bounds set
               * @param {object} theme - theme for series label
               * @param {function} [makePosition] - function for making position of label
               * @param {boolean} [isPivot] - whether pivot or not
               * @returns {Array.<Object>}
               */
              boundsToLabelPositions: function boundsToLabelPositions(seriesDataModel, boundsSet, theme, makePosition, isPivot) {
                var _this = this;
                var labelHeight = _renderUtil2["default"].getRenderedLabelHeight(MAX_HEIGHT_WORD, theme);
                makePosition = makePosition || this._makePositionForBoundType.bind(this);
                isPivot = !!isPivot;
                return seriesDataModel.map(function(seriesGroup, groupIndex) {
                  var bounds = boundsSet[groupIndex];
                  return seriesGroup.map(function(seriesItem, index) {
                    var bound = bounds[index].end;
                    return _this._makePositionMap(seriesItem, bound, labelHeight, theme, makePosition);
                  });
                }, isPivot);
              },
              /**
               * Make label position for bar chart.
               * @param {{left: number, top: number, width:number, height: number}} bound - bound
               * @param {number} labelHeight - label height
               * @param {string} label - label
               * @param {object} theme - theme for series label
               * @param {boolean} isOppositeSide - whether opossite side or not
               * @returns {{left: number, top: number}}
               * @private
               */
              _makePositionForBarChart: function _makePositionForBarChart(bound, labelHeight, label, theme, isOppositeSide) {
                var labelWidth = _renderUtil2["default"].getRenderedLabelWidth(label, theme);
                var left = bound.left;
                if (isOppositeSide) {
                  left += bound.width + SERIES_LABEL_PADDING;
                } else {
                  left -= labelWidth + SERIES_LABEL_PADDING;
                }
                return {
                  left,
                  top: this._calculateTopPositionForMiddleAlign(bound)
                };
              },
              /**
               * Bounds to label positions for bar chart.
               * @param {SeriesDataModel} seriesDataModel - series data model
               * @param {Array.<Array.<{left: number, top: number, width: number, height: number}>>} boundsSet - bounds set
               * @param {object} theme - theme for series label
               * @returns {*|Array.<Object>|Array}
               */
              boundsToLabelPositionsForBarChart: function boundsToLabelPositionsForBarChart(seriesDataModel, boundsSet, theme) {
                var makePositionFunction = this._makePositionForBarChart.bind(this);
                return this.boundsToLabelPositions(seriesDataModel, boundsSet, theme, makePositionFunction);
              },
              /**
               * Make label position for column chart.
               * @param {{left: number, top: number, width:number, height: number}} bound - bound
               * @param {number} labelHeight - label height
               * @param {string} label - label
               * @param {object} theme - theme for series label
               * @param {boolean} isOppositeSide - whether opposite side or not
               * @returns {{left: number, top: number}}
               * @private
               */
              _makePositionForColumnChart: function _makePositionForColumnChart(bound, labelHeight, label, theme, isOppositeSide) {
                var top = bound.top;
                if (isOppositeSide) {
                  top -= labelHeight + SERIES_LABEL_PADDING;
                } else {
                  top += bound.height + SERIES_LABEL_PADDING;
                }
                return {
                  left: this._calculateLeftPositionForCenterAlign(bound),
                  top
                };
              },
              /**
               * Bounds to label positions for column chart.
               * @param {SeriesDataModel} seriesDataModel - series data model
               * @param {Array.<Array.<{left: number, top: number, width: number, height: number}>>} boundsSet - bounds set
               * @param {object} theme - theme for series label
               * @returns {*|Array.<Object>|Array}
               */
              boundsToLabelPositionsForColumnChart: function boundsToLabelPositionsForColumnChart(seriesDataModel, boundsSet, theme) {
                var makePositionFunction = this._makePositionForColumnChart.bind(this);
                return this.boundsToLabelPositions(seriesDataModel, boundsSet, theme, makePositionFunction);
              },
              /**
               * Make labels html for treemap chart.
               * @param {Array.<SeriesItem>} seriesItems - seriesItems
               * @param {object.<string, {left: number, top: number, width: number, height: number}>} boundMap - bound map
               * @returns {string}
               */
              boundsToLabelPostionsForTreemap: function boundsToLabelPostionsForTreemap(seriesItems, boundMap) {
                var _this2 = this;
                var positions = seriesItems.map(function(seriesItem) {
                  var bound = boundMap[seriesItem.id];
                  var position = void 0;
                  if (bound) {
                    position = _this2._makePositionForBoundType(bound);
                  }
                  return position;
                });
                return positions;
              }
            };
          },
          /* 112 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = columnSeriesFactory;
            var _series = __webpack_require__(109);
            var _series2 = _interopRequireDefault(_series);
            var _barTypeSeriesBase = __webpack_require__(110);
            var _barTypeSeriesBase2 = _interopRequireDefault(_barTypeSeriesBase);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var ColumnChartSeries = function(_Series) {
              _inherits(ColumnChartSeries2, _Series);
              function ColumnChartSeries2() {
                _classCallCheck(this, ColumnChartSeries2);
                return _possibleConstructorReturn(this, _Series.apply(this, arguments));
              }
              ColumnChartSeries2.prototype._makeBound = function _makeBound(width, height, left, startTop, endTop) {
                return {
                  start: {
                    top: startTop,
                    left,
                    width,
                    height: 0
                  },
                  end: {
                    top: endTop,
                    left,
                    width,
                    height
                  }
                };
              };
              ColumnChartSeries2.prototype._makeColumnChartBound = function _makeColumnChartBound(baseData, iterationData, isStackType, seriesItem, index) {
                var baseBarSize = baseData.baseBarSize, basePosition = baseData.basePosition, barSize = baseData.barSize, itemCount = baseData.itemCount, groupSize = baseData.groupSize, pointInterval = baseData.pointInterval;
                var barHeight = Math.abs(baseBarSize * seriesItem.ratioDistance);
                var barStartTop = baseBarSize * seriesItem.startRatio;
                var startTop = basePosition + barStartTop + _const2["default"].SERIES_EXPAND_SIZE;
                var changedStack = seriesItem.stack !== iterationData.prevStack;
                var isOverLapBar = barSize * itemCount > groupSize;
                var columnInterval = isOverLapBar ? pointInterval : barSize;
                var endTop = void 0, boundLeft = void 0;
                if (!isStackType || !this.options.diverging && changedStack) {
                  var pointCount = isStackType ? this.dataProcessor.findStackIndex(seriesItem.stack) : index;
                  iterationData.left = iterationData.baseLeft + columnInterval * pointCount;
                  iterationData.plusTop = 0;
                  iterationData.minusTop = 0;
                }
                if (seriesItem.value >= 0) {
                  iterationData.plusTop -= barHeight;
                  endTop = startTop + iterationData.plusTop;
                } else {
                  endTop = startTop + iterationData.minusTop;
                  iterationData.minusTop += barHeight;
                }
                iterationData.prevStack = seriesItem.stack;
                if (isOverLapBar) {
                  boundLeft = iterationData.left + pointInterval - barSize / 2;
                } else {
                  boundLeft = iterationData.left + pointInterval - barSize / 2 + (pointInterval - barSize) / 2 * (itemCount - 1);
                }
                return this._makeBound(barSize, barHeight, boundLeft, startTop, endTop);
              };
              ColumnChartSeries2.prototype._makeBounds = function _makeBounds() {
                var _this2 = this;
                var seriesDataModel = this._getSeriesDataModel();
                var isStackType = _predicate2["default"].isValidStackOption(this.options.stack);
                var _layout$dimension = this.layout.dimension, width = _layout$dimension.width, height = _layout$dimension.height;
                var baseData = this._makeBaseDataForMakingBound(width, height);
                return seriesDataModel.map(function(seriesGroup, groupIndex) {
                  var baseLeft = groupIndex * baseData.groupSize + _this2.layout.position.left;
                  var iterationData = {
                    baseLeft,
                    left: baseLeft,
                    plusTop: 0,
                    minusTop: 0,
                    prevStack: null
                  };
                  var iteratee = _this2._makeColumnChartBound.bind(_this2, baseData, iterationData, isStackType);
                  return seriesGroup.map(iteratee);
                });
              };
              ColumnChartSeries2.prototype._calculateLeftPositionOfSumLabel = function _calculateLeftPositionOfSumLabel(_ref, formattedSum) {
                var left = _ref.left, width = _ref.width;
                var labelWidth = _renderUtil2["default"].getRenderedLabelWidth(formattedSum, this.theme.label);
                return left + (width - labelWidth + _const2["default"].TEXT_PADDING) / 2;
              };
              return ColumnChartSeries2;
            }(_series2["default"]);
            _barTypeSeriesBase2["default"].mixin(ColumnChartSeries);
            function columnSeriesFactory(params) {
              params.libType = params.chartOptions.libType;
              params.chartType = "column";
              params.chartBackground = params.chartTheme.chart.background;
              return new ColumnChartSeries(params);
            }
            columnSeriesFactory.componentType = "series";
            columnSeriesFactory.ColumnChartSeries = ColumnChartSeries;
          },
          /* 113 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = lineSeriesFactory;
            var _series = __webpack_require__(109);
            var _series2 = _interopRequireDefault(_series);
            var _lineTypeSeriesBase = __webpack_require__(114);
            var _lineTypeSeriesBase2 = _interopRequireDefault(_lineTypeSeriesBase);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var LineChartSeries = function(_Series) {
              _inherits(LineChartSeries2, _Series);
              function LineChartSeries2() {
                _classCallCheck(this, LineChartSeries2);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                var _this = _possibleConstructorReturn(this, _Series.call.apply(_Series, [this].concat(args)));
                _this.movingAnimation = null;
                return _this;
              }
              LineChartSeries2.prototype._makePositions = function _makePositions(seriesWidth) {
                return this._makeBasicPositions(seriesWidth);
              };
              LineChartSeries2.prototype._makeSeriesData = function _makeSeriesData() {
                var groupPositions = this._makePositions();
                return {
                  chartBackground: this.chartBackground,
                  groupPositions,
                  isAvailable: function isAvailable() {
                    return groupPositions && groupPositions.length > 0;
                  }
                };
              };
              LineChartSeries2.prototype.rerender = function rerender(data) {
                this._cancelMovingAnimation();
                return _series2["default"].prototype.rerender.call(this, data);
              };
              return LineChartSeries2;
            }(_series2["default"]);
            _lineTypeSeriesBase2["default"].mixin(LineChartSeries);
            function lineSeriesFactory(params) {
              params.libType = params.chartOptions.libType;
              params.chartType = "line";
              params.chartBackground = params.chartTheme.chart.background;
              return new LineChartSeries(params);
            }
            lineSeriesFactory.componentType = "series";
          },
          /* 114 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var SERIES_EXPAND_SIZE = _const2["default"].SERIES_EXPAND_SIZE, SERIES_LABEL_PADDING = _const2["default"].SERIES_LABEL_PADDING, MAX_HEIGHT_WORD = _const2["default"].MAX_HEIGHT_WORD, ADDING_DATA_ANIMATION_DURATION = _const2["default"].ADDING_DATA_ANIMATION_DURATION;
            var LineTypeSeriesBase = function() {
              function LineTypeSeriesBase2() {
                _classCallCheck(this, LineTypeSeriesBase2);
              }
              LineTypeSeriesBase2.prototype._makePositionsForDefaultType = function _makePositionsForDefaultType(seriesWidth) {
                var _layout$dimension = this.layout.dimension, height = _layout$dimension.height, dimensionWidth = _layout$dimension.width;
                var seriesDataModel = this._getSeriesDataModel();
                var width = seriesWidth || dimensionWidth || 0;
                var len = seriesDataModel.getGroupCount();
                var baseTop = this.layout.position.top;
                var baseLeft = this.layout.position.left;
                var step = void 0;
                if (this.aligned) {
                  step = width / (len > 1 ? len - 1 : len);
                } else {
                  step = width / len;
                  baseLeft += step / 2;
                }
                return seriesDataModel.map(function(seriesGroup) {
                  return seriesGroup.map(function(seriesItem, index) {
                    var position = void 0;
                    if (!(0, _isNull2["default"])(seriesItem.end)) {
                      position = {
                        left: baseLeft + step * index,
                        top: baseTop + height - seriesItem.ratio * height
                      };
                      if ((0, _isExisty2["default"])(seriesItem.startRatio)) {
                        position.startTop = baseTop + height - seriesItem.startRatio * height;
                      }
                    }
                    return position;
                  });
                }, true);
              };
              LineTypeSeriesBase2.prototype._makePositionForCoordinateType = function _makePositionForCoordinateType(seriesWidth) {
                var dimension = this.layout.dimension;
                var seriesDataModel = this._getSeriesDataModel();
                var height = dimension.height;
                var xAxis = this.axisDataMap.xAxis;
                var baseTop = this.layout.position.top;
                var baseLeft = this.layout.position.left;
                var width = seriesWidth || dimension.width || 0;
                var additionalLeft = 0;
                if (xAxis.sizeRatio) {
                  additionalLeft = _calculator2["default"].multiply(width, xAxis.positionRatio);
                  width = _calculator2["default"].multiply(width, xAxis.sizeRatio);
                }
                return seriesDataModel.map(function(seriesGroup) {
                  return seriesGroup.map(function(seriesItem) {
                    var position = void 0;
                    if (!(0, _isNull2["default"])(seriesItem.end)) {
                      position = {
                        left: baseLeft + seriesItem.ratioMap.x * width + additionalLeft,
                        top: baseTop + height - seriesItem.ratioMap.y * height
                      };
                      if ((0, _isExisty2["default"])(seriesItem.ratioMap.start)) {
                        position.startTop = height - seriesItem.ratioMap.start * height + _const2["default"].SERIES_EXPAND_SIZE;
                      }
                    }
                    return position;
                  });
                }, true);
              };
              LineTypeSeriesBase2.prototype._makeBasicPositions = function _makeBasicPositions(seriesWidth) {
                if (this.dataProcessor.isCoordinateType()) {
                  return this._makePositionForCoordinateType(seriesWidth);
                }
                return this._makePositionsForDefaultType(seriesWidth);
              };
              LineTypeSeriesBase2.prototype._calculateLabelPositionTop = function _calculateLabelPositionTop(basePosition, value, labelHeight, isStart) {
                var baseTop = basePosition.top;
                var top = void 0;
                if (_predicate2["default"].isValidStackOption(this.options.stack)) {
                  top = (basePosition.startTop + baseTop - labelHeight) / 2 + 1;
                } else if (value >= 0 && !isStart || value < 0 && isStart) {
                  top = baseTop - labelHeight - SERIES_LABEL_PADDING;
                } else {
                  top = baseTop + SERIES_LABEL_PADDING;
                }
                return top;
              };
              LineTypeSeriesBase2.prototype._makeLabelPosition = function _makeLabelPosition(basePosition, labelHeight, label, value, isStart) {
                return {
                  left: basePosition.left,
                  top: this._calculateLabelPositionTop(basePosition, value, labelHeight / 2, isStart)
                };
              };
              LineTypeSeriesBase2.prototype._getLabelPositions = function _getLabelPositions(seriesDataModel, theme) {
                var _this = this;
                var basePositions = _arrayUtil2["default"].pivot(this.seriesData.groupPositions);
                var labelHeight = _renderUtil2["default"].getRenderedLabelHeight(MAX_HEIGHT_WORD, theme);
                return seriesDataModel.map(function(seriesGroup, groupIndex) {
                  return seriesGroup.map(function(seriesItem, index) {
                    var basePosition = basePositions[groupIndex][index];
                    if (!basePosition) {
                      return {
                        end: 0,
                        start: 0
                      };
                    }
                    var end = _this._makeLabelPosition(basePosition, labelHeight, seriesItem.endLabel, seriesItem.end);
                    var position = {
                      end
                    };
                    if (seriesItem.isRange) {
                      basePosition.top = basePosition.startTop;
                      position.start = _this._makeLabelPosition(basePosition, labelHeight, seriesItem.startLabel, seriesItem.start);
                    }
                    return position;
                  });
                });
              };
              LineTypeSeriesBase2.prototype._getLabelTexts = function _getLabelTexts(seriesDataModel) {
                var _this2 = this;
                return seriesDataModel.map(function(seriesGroup) {
                  return seriesGroup.map(function(_ref) {
                    var endLabel = _ref.endLabel, isRange = _ref.isRange, startLabel = _ref.startLabel;
                    var label = {
                      end: _this2.decorateLabel(endLabel)
                    };
                    if (isRange) {
                      label.start = _this2.decorateLabel(startLabel);
                    }
                    return label;
                  });
                });
              };
              LineTypeSeriesBase2.prototype._renderSeriesLabel = function _renderSeriesLabel(paper) {
                var theme = this.theme.label;
                var seriesDataModel = this._getSeriesDataModel();
                var groupLabels = this._getLabelTexts(seriesDataModel);
                var positionsSet = this._getLabelPositions(seriesDataModel, theme);
                return this.graphRenderer.renderSeriesLabel(paper, positionsSet, groupLabels, theme);
              };
              LineTypeSeriesBase2.prototype.onShowGroupTooltipLine = function onShowGroupTooltipLine(bound) {
                if (!this.graphRenderer.showGroupTooltipLine) {
                  return;
                }
                this.graphRenderer.showGroupTooltipLine(bound, this.layout);
              };
              LineTypeSeriesBase2.prototype.onHideGroupTooltipLine = function onHideGroupTooltipLine() {
                if (!this.isAvailableSeriesData() || !this.graphRenderer.hideGroupTooltipLine) {
                  return;
                }
                this.graphRenderer.hideGroupTooltipLine();
              };
              LineTypeSeriesBase2.prototype.zoom = function zoom(data) {
                this._cancelMovingAnimation();
                this._clearSeriesContainer(data.paper);
                this._setDataForRendering(data);
                this._renderSeriesArea(data.paper, this._renderGraph.bind(this));
                if (!(0, _isNull2["default"])(this.selectedLegendIndex)) {
                  this.graphRenderer.selectLegend(this.selectedLegendIndex);
                }
              };
              LineTypeSeriesBase2.prototype._isChangedLimit = function _isChangedLimit(before, after) {
                return before.min !== after.min || before.max !== after.max;
              };
              LineTypeSeriesBase2.prototype._isChangedAxisLimit = function _isChangedAxisLimit() {
                var beforeAxisDataMap = this.beforeAxisDataMap, axisDataMap = this.axisDataMap;
                var changed = true;
                if (beforeAxisDataMap) {
                  changed = this._isChangedLimit(beforeAxisDataMap.yAxis.limit, axisDataMap.yAxis.limit);
                  if (axisDataMap.xAxis.limit) {
                    changed = changed || this._isChangedLimit(beforeAxisDataMap.xAxis.limit, axisDataMap.xAxis.limit);
                  }
                }
                this.beforeAxisDataMap = axisDataMap;
                return changed;
              };
              LineTypeSeriesBase2.prototype._animate = function _animate(callback) {
                var _this3 = this;
                var duration = ADDING_DATA_ANIMATION_DURATION;
                var changedLimit = this._isChangedAxisLimit();
                if (changedLimit && this.seriesLabelContainer) {
                  this.seriesLabelContainer.innerHTML = "";
                }
                if (!callback) {
                  return;
                }
                this.movingAnimation = _renderUtil2["default"].startAnimation(duration, callback, function() {
                  _this3.movingAnimation = null;
                });
              };
              LineTypeSeriesBase2.prototype._makeZeroTopForAddingData = function _makeZeroTopForAddingData() {
                var seriesHeight = this.layout.dimension.height;
                var limit = this.axisDataMap.yAxis.limit;
                return this._getLimitDistanceFromZeroPoint(seriesHeight, limit).toMax + SERIES_EXPAND_SIZE;
              };
              LineTypeSeriesBase2.prototype.animateForAddingData = function animateForAddingData(_ref2) {
                var tickSize = _ref2.tickSize, limitMap = _ref2.limitMap, axisDataMap = _ref2.axisDataMap;
                var dimension = this.dimensionMap.extendedSeries;
                var shiftingOption = this.options.shifting;
                var seriesWidth = this.layout.dimension.width;
                this.limit = limitMap[this.chartType];
                this.axisDataMap = axisDataMap;
                var seriesData = this._makeSeriesData();
                var paramsForRendering = this._makeParamsForGraphRendering(dimension, seriesData);
                if (shiftingOption) {
                  seriesWidth += tickSize;
                }
                var groupPositions = this._makePositions(seriesWidth);
                var zeroTop = this._makeZeroTopForAddingData();
                this.graphRenderer.animateForAddingData(paramsForRendering, tickSize, groupPositions, shiftingOption, zeroTop);
              };
              LineTypeSeriesBase2.prototype._cancelMovingAnimation = function _cancelMovingAnimation() {
                if (this.movingAnimation) {
                  cancelAnimationFrame(this.movingAnimation.id);
                  this.movingAnimation = null;
                }
              };
              return LineTypeSeriesBase2;
            }();
            LineTypeSeriesBase.mixin = function(func) {
              Object.assign(func.prototype, LineTypeSeriesBase.prototype);
            };
            exports2["default"] = LineTypeSeriesBase;
          },
          /* 115 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = radialSeriesFactory;
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _series = __webpack_require__(109);
            var _series2 = _interopRequireDefault(_series);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            var _geometric = __webpack_require__(74);
            var _geometric2 = _interopRequireDefault(_geometric);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var COMPONENT_TYPE_RAPHAEL = _const2["default"].COMPONENT_TYPE_RAPHAEL, RADIAL_PLOT_PADDING = _const2["default"].RADIAL_PLOT_PADDING, RADIAL_MARGIN_FOR_CATEGORY = _const2["default"].RADIAL_MARGIN_FOR_CATEGORY;
            var RadialChartSeries = function(_Series) {
              _inherits(RadialChartSeries2, _Series);
              function RadialChartSeries2() {
                _classCallCheck(this, RadialChartSeries2);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                var _this = _possibleConstructorReturn(this, _Series.call.apply(_Series, [this].concat(args)));
                _this.options = Object.assign({
                  showDot: false,
                  showArea: false
                }, _this.options);
                _this.movingAnimation = null;
                _this.drawingType = COMPONENT_TYPE_RAPHAEL;
                return _this;
              }
              RadialChartSeries2.prototype._makePositionsForRadial = function _makePositionsForRadial(seriesGroups, groupCount) {
                var _layout = this.layout, dimension = _layout.dimension, _layout$position = _layout.position, top = _layout$position.top, left = _layout$position.left;
                var width = dimension.width - RADIAL_PLOT_PADDING - RADIAL_MARGIN_FOR_CATEGORY;
                var height = dimension.height - RADIAL_PLOT_PADDING - RADIAL_MARGIN_FOR_CATEGORY;
                var centerX = _calculator2["default"].sum([width / 2, RADIAL_PLOT_PADDING / 2, RADIAL_MARGIN_FOR_CATEGORY / 2, left]);
                var centerY = _calculator2["default"].sum([height / 2, -(RADIAL_PLOT_PADDING / 2), -(RADIAL_MARGIN_FOR_CATEGORY / 2), -top]);
                var stepAngle = 360 / groupCount;
                var radius = Math.min(width, height) / 2;
                return seriesGroups.map(function(seriesGroup) {
                  var positions = seriesGroup.map(function(seriesItem, index) {
                    var position = void 0;
                    if (!(0, _isNull2["default"])(seriesItem.end)) {
                      var valueSize = seriesItem.ratio * radius;
                      var y = centerY + valueSize;
                      var angle = 360 - stepAngle * index;
                      var point = _geometric2["default"].rotatePointAroundOrigin(centerX, centerY, centerX, y, angle);
                      position = {
                        left: point.x,
                        top: height - point.y
                        // convert y coordinate to top
                      };
                    }
                    return position;
                  });
                  positions.push(positions[0]);
                  return positions;
                });
              };
              RadialChartSeries2.prototype._getSeriesGroups = function _getSeriesGroups() {
                var seriesDataModel = this._getSeriesDataModel();
                return seriesDataModel.map(function(group) {
                  return group.map(function(item) {
                    return item;
                  });
                }, true);
              };
              RadialChartSeries2.prototype._makeSeriesData = function _makeSeriesData() {
                var groups = this._getSeriesGroups();
                var groupPositions = this._makePositionsForRadial(groups, this._getSeriesDataModel().getGroupCount());
                return {
                  groupPositions,
                  isAvailable: function isAvailable() {
                    return groupPositions && groupPositions.length > 0;
                  }
                };
              };
              RadialChartSeries2.prototype.rerender = function rerender(data) {
                return _series2["default"].prototype.rerender.call(this, data);
              };
              return RadialChartSeries2;
            }(_series2["default"]);
            function radialSeriesFactory(params) {
              params.libType = params.chartOptions.libType;
              params.chartType = params.chartOptions.chartType;
              params.chartBackground = params.chartTheme.background;
              return new RadialChartSeries(params);
            }
            radialSeriesFactory.componentType = "series";
            radialSeriesFactory.RadialChartSeries = RadialChartSeries;
          },
          /* 116 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = areaSeriesFactory;
            var _series = __webpack_require__(109);
            var _series2 = _interopRequireDefault(_series);
            var _lineTypeSeriesBase = __webpack_require__(114);
            var _lineTypeSeriesBase2 = _interopRequireDefault(_lineTypeSeriesBase);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var AreaChartSeries = function(_Series) {
              _inherits(AreaChartSeries2, _Series);
              function AreaChartSeries2() {
                _classCallCheck(this, AreaChartSeries2);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                var _this = _possibleConstructorReturn(this, _Series.call.apply(_Series, [this].concat(args)));
                _this.movingAnimation = null;
                return _this;
              }
              AreaChartSeries2.prototype._makePositionTopOfZeroPoint = function _makePositionTopOfZeroPoint() {
                var _layout = this.layout, height = _layout.dimension.height, baseTop = _layout.position.top;
                var limit = this.axisDataMap.yAxis.limit;
                var top = this._getLimitDistanceFromZeroPoint(height, limit).toMax + baseTop;
                if (limit.min >= 0 && !top) {
                  top = height;
                }
                return top;
              };
              AreaChartSeries2.prototype._makeStackedPositions = function _makeStackedPositions(groupPositions) {
                var _layout2 = this.layout, height = _layout2.dimension.height, baseTop = _layout2.position.top;
                var firstStartTop = this._makePositionTopOfZeroPoint();
                var prevPositionTops = [];
                return groupPositions.map(function(positions) {
                  return positions.map(function(position, index) {
                    var prevTop = prevPositionTops[index] || firstStartTop;
                    var positionTop = position ? position.top : 0;
                    var stackedHeight = height - positionTop + baseTop;
                    var top = position ? prevTop - stackedHeight : prevTop;
                    if (position) {
                      position.startTop = prevTop;
                      position.top = top;
                    }
                    prevPositionTops[index] = top;
                    return position;
                  });
                });
              };
              AreaChartSeries2.prototype._makePositions = function _makePositions(seriesWidth) {
                var groupPositions = this._makeBasicPositions(seriesWidth);
                if (_predicate2["default"].isValidStackOption(this.options.stack)) {
                  groupPositions = this._makeStackedPositions(groupPositions);
                }
                return groupPositions;
              };
              AreaChartSeries2.prototype._makeSeriesData = function _makeSeriesData() {
                var _layout3 = this.layout, height = _layout3.dimension.height, baseTop = _layout3.position.top;
                var zeroTop = this._getLimitDistanceFromZeroPoint(height, this.limit).toMax + baseTop;
                var groupPositions = this._makePositions();
                return {
                  chartBackground: this.chartBackground,
                  groupPositions,
                  hasRangeData: this._getSeriesDataModel().hasRangeData(),
                  zeroTop,
                  isAvailable: function isAvailable() {
                    return groupPositions && groupPositions.length > 0;
                  }
                };
              };
              AreaChartSeries2.prototype.rerender = function rerender(data) {
                this._cancelMovingAnimation();
                return _series2["default"].prototype.rerender.call(this, data);
              };
              return AreaChartSeries2;
            }(_series2["default"]);
            _lineTypeSeriesBase2["default"].mixin(AreaChartSeries);
            function areaSeriesFactory(params) {
              var chartTheme = params.chartTheme, libType = params.chartOptions.libType;
              params.libType = libType;
              params.chartType = "area";
              params.chartBackground = chartTheme.chart.background;
              return new AreaChartSeries(params);
            }
            areaSeriesFactory.componentType = "series";
            areaSeriesFactory.AreaChartSeries = AreaChartSeries;
          },
          /* 117 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = bubbleSeriesFactory;
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _series = __webpack_require__(109);
            var _series2 = _interopRequireDefault(_series);
            var _coordinateTypeSeriesBase = __webpack_require__(118);
            var _coordinateTypeSeriesBase2 = _interopRequireDefault(_coordinateTypeSeriesBase);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var BubbleChartSeries = function(_Series) {
              _inherits(BubbleChartSeries2, _Series);
              function BubbleChartSeries2() {
                _classCallCheck(this, BubbleChartSeries2);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                var _this = _possibleConstructorReturn(this, _Series.call.apply(_Series, [this].concat(args)));
                _this.prevClickedIndex = null;
                _this.maxRadius = null;
                _this.drawingType = _const2["default"].COMPONENT_TYPE_RAPHAEL;
                return _this;
              }
              BubbleChartSeries2.prototype._calculateStep = function _calculateStep() {
                var hasVerticalCategory = this.dataProcessor.isXCountGreaterThanYCount(this.chartType);
                var step = 0;
                if (this.dataProcessor.hasCategories(hasVerticalCategory)) {
                  var dimension = this.layout.dimension;
                  var len = this.dataProcessor.getCategoryCount(hasVerticalCategory);
                  var size = void 0;
                  if (hasVerticalCategory) {
                    size = dimension.height;
                  } else {
                    size = dimension.width;
                  }
                  step = size / len;
                }
                return step;
              };
              BubbleChartSeries2.prototype._makeBound = function _makeBound(ratioMap, positionByStep, maxRadius) {
                var _layout = this.layout, _layout$dimension = _layout.dimension, width = _layout$dimension.width, height = _layout$dimension.height, position = _layout.position;
                var left = (0, _isExisty2["default"])(ratioMap.x) ? ratioMap.x * width : positionByStep;
                var top = (0, _isExisty2["default"])(ratioMap.y) ? ratioMap.y * height : positionByStep;
                return {
                  left: position.left + left,
                  top: position.top + height - top,
                  radius: Math.max(maxRadius * ratioMap.r, 2)
                };
              };
              BubbleChartSeries2.prototype._makeBounds = function _makeBounds() {
                var _this2 = this;
                var seriesDataModel = this._getSeriesDataModel();
                var maxRadius = this.maxRadius;
                var step = this._calculateStep();
                var start = step ? step / 2 : 0;
                return seriesDataModel.map(function(seriesGroup, index) {
                  var positionByStep = start + step * index;
                  return seriesGroup.map(function(seriesItem) {
                    var hasRationMap = seriesItem && seriesItem.ratioMap;
                    return hasRationMap ? _this2._makeBound(seriesItem.ratioMap, positionByStep, maxRadius) : null;
                  });
                });
              };
              BubbleChartSeries2.prototype._setDataForRendering = function _setDataForRendering(data) {
                this.maxRadius = data.maxRadius;
                _series2["default"].prototype._setDataForRendering.call(this, data);
              };
              return BubbleChartSeries2;
            }(_series2["default"]);
            _coordinateTypeSeriesBase2["default"].mixin(BubbleChartSeries);
            function bubbleSeriesFactory(params) {
              var libType = params.chartOptions.libType, chartTheme = params.chartTheme;
              params.libType = libType;
              params.chartType = "bubble";
              params.chartBackground = chartTheme.chart.background;
              return new BubbleChartSeries(params);
            }
            bubbleSeriesFactory.componentType = "series";
            bubbleSeriesFactory.BubbleChartSeries = BubbleChartSeries;
          },
          /* 118 */
          /***/
          function(module2, exports2) {
            "use strict";
            exports2.__esModule = true;
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var CoordinateTypeSeriesBase = function() {
              function CoordinateTypeSeriesBase2() {
                _classCallCheck(this, CoordinateTypeSeriesBase2);
              }
              CoordinateTypeSeriesBase2.prototype._makeSeriesData = function _makeSeriesData() {
                var groupBounds = this._makeBounds();
                return {
                  groupBounds,
                  seriesDataModel: this._getSeriesDataModel(),
                  isAvailable: function isAvailable() {
                    return groupBounds && groupBounds.length > 0;
                  }
                };
              };
              CoordinateTypeSeriesBase2.prototype.showTooltip = function showTooltip(params, bound, groupIndex, index, mousePosition) {
                this.eventBus.fire("showTooltip", Object.assign({
                  indexes: {
                    groupIndex,
                    index
                  },
                  mousePosition
                }, params));
              };
              CoordinateTypeSeriesBase2.prototype.hideTooltip = function hideTooltip() {
                this.eventBus.fire("hideTooltip");
              };
              CoordinateTypeSeriesBase2.prototype._renderGraph = function _renderGraph(dimension, seriesData, paper) {
                var showTooltip = this.showTooltip.bind(this, {
                  chartType: this.chartType
                });
                var callbacks = {
                  showTooltip,
                  hideTooltip: this.hideTooltip.bind(this)
                };
                var params = this._makeParamsForGraphRendering(dimension, seriesData);
                return this.graphRenderer.render(paper, params, callbacks);
              };
              CoordinateTypeSeriesBase2.prototype.onClickSeries = function onClickSeries(position) {
                var indexes = this._executeGraphRenderer(position, "findIndexes");
                var prevIndexes = this.prevClickedIndexes;
                var allowSelect = this.options.allowSelect, chartType = this.chartType;
                if (indexes && prevIndexes) {
                  this.onUnselectSeries({
                    chartType,
                    indexes: prevIndexes
                  });
                  this.prevClickedIndexes = null;
                }
                if (!indexes) {
                  return;
                }
                var shouldSelect = !prevIndexes || indexes.index !== prevIndexes.index || indexes.groupIndex !== prevIndexes.groupIndex;
                if (allowSelect && shouldSelect) {
                  this.onSelectSeries({
                    chartType,
                    indexes
                  }, shouldSelect);
                  this.prevClickedIndexes = indexes;
                }
              };
              CoordinateTypeSeriesBase2.prototype.onMoveSeries = function onMoveSeries(position) {
                this._executeGraphRenderer(position, "moveMouseOnSeries");
              };
              return CoordinateTypeSeriesBase2;
            }();
            CoordinateTypeSeriesBase.mixin = function(func) {
              Object.assign(func.prototype, CoordinateTypeSeriesBase.prototype);
            };
            exports2["default"] = CoordinateTypeSeriesBase;
          },
          /* 119 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = scatterSeriesFactory;
            var _series = __webpack_require__(109);
            var _series2 = _interopRequireDefault(_series);
            var _coordinateTypeSeriesBase = __webpack_require__(118);
            var _coordinateTypeSeriesBase2 = _interopRequireDefault(_coordinateTypeSeriesBase);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var ScatterChartSeries = function(_Series) {
              _inherits(ScatterChartSeries2, _Series);
              function ScatterChartSeries2() {
                _classCallCheck(this, ScatterChartSeries2);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                var _this = _possibleConstructorReturn(this, _Series.call.apply(_Series, [this].concat(args)));
                _this.prevClickedIndex = null;
                return _this;
              }
              ScatterChartSeries2.prototype._makeBound = function _makeBound(ratioMap) {
                var _layout = this.layout, dimension = _layout.dimension, basePosition = _layout.position;
                return {
                  left: basePosition.left + ratioMap.x * dimension.width,
                  top: dimension.height - ratioMap.y * dimension.height + basePosition.top,
                  radius: _const2["default"].SCATTER_RADIUS
                };
              };
              ScatterChartSeries2.prototype._makeBounds = function _makeBounds() {
                var _this2 = this;
                var seriesDataModel = this._getSeriesDataModel();
                return seriesDataModel.map(function(seriesGroup) {
                  return seriesGroup.map(function(seriesItem) {
                    var hasRatioMap = seriesItem && seriesItem.ratioMap;
                    return hasRatioMap ? _this2._makeBound(seriesItem.ratioMap) : null;
                  });
                });
              };
              return ScatterChartSeries2;
            }(_series2["default"]);
            _coordinateTypeSeriesBase2["default"].mixin(ScatterChartSeries);
            function scatterSeriesFactory(params) {
              params.libType = params.chartOptions.libType;
              params.chartType = "scatter";
              params.chartBackground = params.chartTheme.chart.background;
              return new ScatterChartSeries(params);
            }
            scatterSeriesFactory.componentType = "series";
            scatterSeriesFactory.ScatterChartSeries = ScatterChartSeries;
          },
          /* 120 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = mapSeriesFactory;
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _browser = __webpack_require__(22);
            var _browser2 = _interopRequireDefault(_browser);
            var _series = __webpack_require__(109);
            var _series2 = _interopRequireDefault(_series);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var IS_LTE_IE8 = _browser2["default"].msie && _browser2["default"].version <= 8;
            var TOOLTIP_GAP = _const2["default"].TOOLTIP_GAP, PUBLIC_EVENT_PREFIX = _const2["default"].PUBLIC_EVENT_PREFIX;
            var MapChartSeries = function(_Series) {
              _inherits(MapChartSeries2, _Series);
              function MapChartSeries2(params) {
                _classCallCheck(this, MapChartSeries2);
                var _this = _possibleConstructorReturn(this, _Series.call(this, params));
                _this.basePosition = {
                  left: 0,
                  top: 0
                };
                _this.zoomMagn = 1;
                _this.mapRatio = 1;
                _this.graphDimension = {};
                _this.limitPosition = {};
                _this.mapModel = params.mapModel;
                _this.colorSpectrum = params.colorSpectrum;
                _this.prevPosition = null;
                _this.prevMovedIndex = null;
                _this.isDrag = false;
                _this.startPosition = null;
                return _this;
              }
              MapChartSeries2.prototype._attachToEventBus = function _attachToEventBus() {
                _series2["default"].prototype._attachToEventBus.call(this);
                if (!IS_LTE_IE8) {
                  this.eventBus.on({
                    dragStartMapSeries: this.onDragStartMapSeries,
                    dragMapSeries: this.onDragMapSeries,
                    dragEndMapSeries: this.onDragEndMapSeries,
                    zoomMap: this.onZoomMap
                  }, this);
                }
              };
              MapChartSeries2.prototype._setMapRatio = function _setMapRatio(graphDimension) {
                var seriesDimension = this.layout.dimension;
                var mapDimension = graphDimension || this.mapModel.getMapDimension();
                var widthRatio = seriesDimension.width / mapDimension.width;
                var heightRatio = seriesDimension.height / mapDimension.height;
                this.mapRatio = Math.min(widthRatio, heightRatio);
              };
              MapChartSeries2.prototype._setGraphDimension = function _setGraphDimension() {
                var _layout$dimension = this.layout.dimension, width = _layout$dimension.width, height = _layout$dimension.height;
                this.graphDimension = {
                  width: width * this.zoomMagn,
                  height: height * this.zoomMagn
                };
              };
              MapChartSeries2.prototype.render = function render(data) {
                _series2["default"].prototype.render.call(this, data);
                this.seriesSet = this.graphRenderer.sectorSet;
                this._setMapRatio();
              };
              MapChartSeries2.prototype.rerender = function rerender(data) {
                _series2["default"].prototype.rerender.call(this, data);
                this.seriesSet = this.graphRenderer.sectorSet;
                this._setMapRatio();
              };
              MapChartSeries2.prototype.resize = function resize(data) {
                this.rerender(data);
              };
              MapChartSeries2.prototype._setLimitPositionToMoveMap = function _setLimitPositionToMoveMap() {
                var seriesDimension = this.layout.dimension;
                var graphDimension = this.graphDimension;
                this.limitPosition = {
                  left: seriesDimension.width - graphDimension.width,
                  top: seriesDimension.height - graphDimension.height
                };
              };
              MapChartSeries2.prototype._renderGraph = function _renderGraph() {
                this._setGraphDimension();
                this._setLimitPositionToMoveMap();
                this.graphRenderer.render(this.paper, {
                  colorSpectrum: this.colorSpectrum,
                  mapModel: this.mapModel,
                  layout: this.layout,
                  theme: this.theme
                });
              };
              MapChartSeries2.prototype._renderSeriesLabel = function _renderSeriesLabel() {
                var labelData = this.mapModel.getLabelData(this.zoomMagn * this.mapRatio);
                return this.graphRenderer.renderSeriesLabels(this.paper, labelData, this.theme.label);
              };
              MapChartSeries2.prototype._renderSeriesArea = function _renderSeriesArea(seriesContainer, data, funcRenderGraph) {
                _series2["default"].prototype._renderSeriesArea.call(this, seriesContainer, data, funcRenderGraph);
              };
              MapChartSeries2.prototype._adjustMapPosition = function _adjustMapPosition(targetPosition) {
                return {
                  left: Math.max(Math.min(targetPosition.left, 0), this.limitPosition.left),
                  top: Math.max(Math.min(targetPosition.top, 0), this.limitPosition.top)
                };
              };
              MapChartSeries2.prototype._updateBasePositionForZoom = function _updateBasePositionForZoom(prevDimension, prevLimitPosition, changedRatio) {
                var prevBasePosition = this.basePosition;
                var prevLeft = prevBasePosition.left - prevLimitPosition.left / 2;
                var prevTop = prevBasePosition.top - prevLimitPosition.top / 2;
                var newBasePosition = {
                  left: prevLeft * changedRatio + this.limitPosition.left / 2,
                  top: prevTop * changedRatio + this.limitPosition.top / 2
                };
                this.basePosition = this._adjustMapPosition(newBasePosition);
              };
              MapChartSeries2.prototype._zoom = function _zoom(changedRatio, position) {
                var prevDimension = this.graphDimension;
                var prevLimitPosition = this.limitPosition;
                this._setGraphDimension();
                this._setLimitPositionToMoveMap();
                this._updateBasePositionForZoom(prevDimension, prevLimitPosition, changedRatio);
                this._setMapRatio(this.graphDimension);
                this.graphRenderer.scaleMapPaths(changedRatio, position, this.mapRatio, prevDimension, prevDimension);
              };
              MapChartSeries2.prototype._updatePositionsToResize = function _updatePositionsToResize(prevMapRatio) {
                var changedRatio = this.mapRatio / prevMapRatio;
                this.basePosition.left *= changedRatio;
                this.basePosition.top *= changedRatio;
                this.limitPosition.left *= changedRatio;
                this.limitPosition.top *= changedRatio;
              };
              MapChartSeries2.prototype.onClickSeries = function onClickSeries(position) {
                var foundIndex = this._executeGraphRenderer(position, "findSectorIndex");
                if (!(0, _isNull2["default"])(foundIndex)) {
                  this.eventBus.fire("selectSeries", {
                    chartType: this.chartType,
                    index: foundIndex,
                    code: this.mapModel.getDatum(foundIndex).code
                  });
                }
              };
              MapChartSeries2.prototype._isChangedPosition = function _isChangedPosition(prevPosition, position) {
                return !prevPosition || prevPosition.left !== position.left || prevPosition.top !== position.top;
              };
              MapChartSeries2.prototype._showWedge = function _showWedge(index) {
                var _mapModel$getDatum = this.mapModel.getDatum(index), ratio = _mapModel$getDatum.ratio, label = _mapModel$getDatum.label;
                if (!(0, _isUndefined2["default"])(ratio)) {
                  this.eventBus.fire("showWedge", ratio, label);
                }
              };
              MapChartSeries2.prototype._showTooltip = function _showTooltip(index, _ref) {
                var left = _ref.left, top = _ref.top;
                this.eventBus.fire("showTooltip", {
                  chartType: this.chartType,
                  indexes: {
                    index
                  },
                  mousePosition: {
                    left,
                    top: top - TOOLTIP_GAP
                  }
                });
              };
              MapChartSeries2.prototype.onMoveSeries = function onMoveSeries(position) {
                var foundIndex = this._executeGraphRenderer(position, "findSectorIndex");
                if (!(0, _isNull2["default"])(foundIndex)) {
                  if (this.prevMovedIndex !== foundIndex) {
                    if (!(0, _isNull2["default"])(this.prevMovedIndex)) {
                      this.graphRenderer.restoreColor(this.prevMovedIndex);
                      this.eventBus.fire("hideTooltip");
                    }
                    this.graphRenderer.changeColor(foundIndex);
                  }
                  if (this._isChangedPosition(this.prevPosition, position)) {
                    this._showTooltip(foundIndex, {
                      left: position.left,
                      top: position.top
                    });
                    this.prevMovedIndex = foundIndex;
                  }
                  this._showWedge(foundIndex);
                } else if (!(0, _isNull2["default"])(this.prevMovedIndex)) {
                  this.graphRenderer.restoreColor(this.prevMovedIndex);
                  this.eventBus.fire("hideTooltip");
                  this.prevMovedIndex = null;
                }
                this.prevPosition = position;
              };
              MapChartSeries2.prototype.onDragStartMapSeries = function onDragStartMapSeries(position) {
                this.startPosition = {
                  left: position.left,
                  top: position.top
                };
              };
              MapChartSeries2.prototype._movePosition = function _movePosition(startPosition, endPosition) {
                var movementPosition = {
                  x: (endPosition.left - startPosition.left) * this.mapRatio,
                  y: (endPosition.top - startPosition.top) * this.mapRatio
                };
                this.graphRenderer.moveMapPaths(movementPosition, this.graphDimension);
              };
              MapChartSeries2.prototype.onDragMapSeries = function onDragMapSeries(position) {
                this._movePosition(this.startPosition, position);
                this.startPosition = position;
                if (!this.isDrag) {
                  this.isDrag = true;
                  this.eventBus.fire("hideTooltip");
                }
              };
              MapChartSeries2.prototype.onDragEndMapSeries = function onDragEndMapSeries() {
                this.isDrag = false;
              };
              MapChartSeries2.prototype.onZoomMap = function onZoomMap(newMagn, position) {
                var changedRatio = newMagn / this.zoomMagn;
                var _layout = this.layout, _layout$position = _layout.position, top = _layout$position.top, left = _layout$position.left, _layout$dimension2 = _layout.dimension, width = _layout$dimension2.width, height = _layout$dimension2.height;
                var layerPosition = position ? position : {
                  left: width / 2,
                  top: height / 2
                };
                this.zoomMagn = newMagn;
                this._zoom(changedRatio, {
                  left: layerPosition.left - left,
                  top: layerPosition.top - top
                });
                this.eventBus.fire(PUBLIC_EVENT_PREFIX + "zoom", newMagn);
              };
              MapChartSeries2.prototype._makeExportationSeriesData = function _makeExportationSeriesData(seriesData) {
                return seriesData;
              };
              return MapChartSeries2;
            }(_series2["default"]);
            function mapSeriesFactory(params) {
              params.libType = params.chartOptions.libType;
              params.chartType = "map";
              return new MapChartSeries(params);
            }
            mapSeriesFactory.componentType = "series";
            mapSeriesFactory.MapChartSeries = MapChartSeries;
          },
          /* 121 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            exports2["default"] = pieSeriesFactory;
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isString = __webpack_require__(25);
            var _isString2 = _interopRequireDefault(_isString);
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _series = __webpack_require__(109);
            var _series2 = _interopRequireDefault(_series);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var COMPONENT_TYPE_RAPHAEL = _const2["default"].COMPONENT_TYPE_RAPHAEL, ANGLE_360 = _const2["default"].ANGLE_360, PIE_GRAPH_LEGEND_LABEL_INTERVAL = _const2["default"].PIE_GRAPH_LEGEND_LABEL_INTERVAL, ANGLE_90 = _const2["default"].ANGLE_90, PIE_GRAPH_SMALL_RATIO = _const2["default"].PIE_GRAPH_SMALL_RATIO, PIE_GRAPH_DEFAULT_RATIO = _const2["default"].PIE_GRAPH_DEFAULT_RATIO, RAD = _const2["default"].RAD, PIE_GRAPH_LEGEND_LABEL_SIZE = _const2["default"].PIE_GRAPH_LEGEND_LABEL_SIZE, SERIES_OUTER_LABEL_PADDING = _const2["default"].SERIES_OUTER_LABEL_PADDING, SERIES_LABEL_PADDING = _const2["default"].SERIES_LABEL_PADDING;
            var COMBO_PIE1 = "pie1";
            var PieChartSeries = function(_Series) {
              _inherits(PieChartSeries2, _Series);
              function PieChartSeries2(params) {
                _classCallCheck(this, PieChartSeries2);
                var _this = _possibleConstructorReturn(this, _Series.call(this, params));
                _this.isCombo = !!params.isCombo;
                _this.isShowOuterLabel = _predicate2["default"].isShowOuterLabel(_this.options);
                _this.isLabelAlignOuter = _predicate2["default"].isLabelAlignOuter(_this.options.labelAlign);
                _this.legendMaxWidth = params.legendMaxWidth;
                _this.drawingType = COMPONENT_TYPE_RAPHAEL;
                _this.quadrantRange = null;
                _this.prevClickedIndex = null;
                _this.legendLabels = [];
                _this.valueLabels = [];
                _this.ratioValues = [];
                _this.legendLongestWidth = 0;
                _this.labelTheme = _this.theme.label;
                _this._setDefaultOptions();
                return _this;
              }
              PieChartSeries2.prototype._getLegendLabels = function _getLegendLabels() {
                var _this2 = this;
                var legendLabels = this.dataProcessor.getLegendLabels(this.seriesType);
                return legendLabels.map(function(legendName) {
                  return _raphaelRenderUtil2["default"].getEllipsisText(legendName, _this2.legendMaxWidth, _this2.labelTheme);
                });
              };
              PieChartSeries2.prototype._makeValidAngle = function _makeValidAngle(angle, defaultAngle) {
                if ((0, _isUndefined2["default"])(angle)) {
                  angle = defaultAngle;
                } else if (angle < 0) {
                  angle = ANGLE_360 - Math.abs(angle) % ANGLE_360;
                } else if (angle > 0) {
                  angle = angle % ANGLE_360;
                }
                return angle;
              };
              PieChartSeries2.prototype._transformRadiusRange = function _transformRadiusRange() {
                var radiusRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ["0%", "100%"];
                return radiusRange.map(function(percent) {
                  var ratio = parseInt(percent, 10) * 0.01;
                  return Math.max(Math.min(ratio, 1), 0);
                });
              };
              PieChartSeries2.prototype._setDefaultOptions = function _setDefaultOptions() {
                var options = this.options;
                options.startAngle = this._makeValidAngle(options.startAngle, 0);
                options.endAngle = this._makeValidAngle(options.endAngle, options.startAngle);
                options.radiusRange = this._transformRadiusRange(options.radiusRange);
                if (options.radiusRange.length === 1) {
                  options.radiusRange.unshift(0);
                }
              };
              PieChartSeries2.prototype._calculateAngleForRendering = function _calculateAngleForRendering() {
                var _options = this.options, startAngle = _options.startAngle, endAngle = _options.endAngle;
                var renderingAngle = void 0;
                if (startAngle < endAngle) {
                  renderingAngle = endAngle - startAngle;
                } else if (startAngle > endAngle) {
                  renderingAngle = ANGLE_360 - (startAngle - endAngle);
                } else {
                  renderingAngle = ANGLE_360;
                }
                return renderingAngle;
              };
              PieChartSeries2.prototype._makeSectorData = function _makeSectorData(circleBound) {
                var _this3 = this;
                var cx = circleBound.cx, r = circleBound.r, cy = circleBound.cy;
                var _options$radiusRange = _slicedToArray(this.options.radiusRange, 1), holeRatio = _options$radiusRange[0];
                var angleForRendering = this._calculateAngleForRendering();
                var seriesGroup = this._getSeriesDataModel().getFirstSeriesGroup();
                var angle = this.options.startAngle;
                var centerR = r * 0.5;
                if (holeRatio) {
                  centerR += centerR * holeRatio;
                }
                if (!seriesGroup) {
                  return null;
                }
                var paths = seriesGroup.map(function(seriesItem) {
                  var ratio = seriesItem ? seriesItem.ratio : 0;
                  var currentAngle = angleForRendering * ratio;
                  var endAngle = angle + currentAngle;
                  var popupAngle = angle + currentAngle / 2;
                  var angles = {
                    start: {
                      startAngle: angle,
                      endAngle: angle
                    },
                    end: {
                      startAngle: angle,
                      endAngle
                    }
                  };
                  var positionData = {
                    cx,
                    cy,
                    angle: popupAngle
                  };
                  angle = endAngle;
                  return {
                    ratio,
                    angles,
                    centerPosition: _this3._getArcPosition(Object.assign({
                      r: centerR
                    }, positionData)),
                    outerPosition: _this3._getArcPosition(Object.assign({
                      r: r + _this3.legendLongestWidth / 2 + PIE_GRAPH_LEGEND_LABEL_INTERVAL
                    }, positionData))
                  };
                });
                return paths;
              };
              PieChartSeries2.prototype._makeValueLabel = function _makeValueLabel() {
                var seriesGroup = this._getSeriesDataModel().getFirstSeriesGroup();
                return seriesGroup.map(function(seriesItem) {
                  return seriesItem.label;
                });
              };
              PieChartSeries2.prototype._makeRatioValues = function _makeRatioValues() {
                var seriesGroup = this._getSeriesDataModel().getFirstSeriesGroup();
                return seriesGroup.map(function(seriesItem) {
                  return seriesItem.ratio;
                });
              };
              PieChartSeries2.prototype._makeSeriesData = function _makeSeriesData() {
                this.valueLabels = this._makeValueLabel();
                this.legendLabels = this._getLegendLabels();
                this.legendLongestWidth = this._getMaxLengthLegendWidth();
                this.ratioValues = this._makeRatioValues();
                var circleBound = this._makeCircleBound();
                var sectorData = this._makeSectorData(circleBound);
                return {
                  chartBackground: this.chartBackground,
                  circleBound,
                  sectorData,
                  isAvailable: function isAvailable() {
                    return sectorData && sectorData.length > 0;
                  }
                };
              };
              PieChartSeries2.prototype._getQuadrantFromAngle = function _getQuadrantFromAngle(angle, isEnd) {
                var quadrant = parseInt(angle / ANGLE_90, 10) + 1;
                if (isEnd && angle % ANGLE_90 === 0) {
                  quadrant += quadrant === 1 ? 3 : -1;
                }
                return quadrant;
              };
              PieChartSeries2.prototype._getRangeForQuadrant = function _getRangeForQuadrant() {
                if (!this.quadrantRange) {
                  this.quadrantRange = {
                    start: this._getQuadrantFromAngle(this.options.startAngle),
                    end: this._getQuadrantFromAngle(this.options.endAngle, true)
                  };
                }
                return this.quadrantRange;
              };
              PieChartSeries2.prototype._isInQuadrantRange = function _isInQuadrantRange(start, end) {
                var quadrantRange = this._getRangeForQuadrant();
                return quadrantRange.start === start && quadrantRange.end === end;
              };
              PieChartSeries2.prototype._calculateBaseSize = function _calculateBaseSize() {
                var dimension = this.layout.dimension;
                var width = dimension.width, height = dimension.height;
                if (!this.isCombo) {
                  var quadrantRange = this._getRangeForQuadrant();
                  if (this._isInQuadrantRange(2, 3) || this._isInQuadrantRange(4, 1)) {
                    height *= 2;
                  } else if (this._isInQuadrantRange(1, 2) || this._isInQuadrantRange(3, 4)) {
                    width *= 2;
                  } else if (quadrantRange.start === quadrantRange.end) {
                    width *= 2;
                    height *= 2;
                  }
                }
                return Math.min(width, height);
              };
              PieChartSeries2.prototype._calculateRadius = function _calculateRadius() {
                var isComboPie1 = this.isCombo && this.seriesType === COMBO_PIE1;
                var baseSize = this._calculateBaseSize();
                var radiusRatio = 0;
                var isShowOuterLabel = this.isShowOuterLabel;
                if (isComboPie1) {
                  isShowOuterLabel = this.dataProcessor.isComboDonutShowOuterLabel();
                }
                radiusRatio = isShowOuterLabel ? PIE_GRAPH_SMALL_RATIO : PIE_GRAPH_DEFAULT_RATIO;
                return baseSize * radiusRatio * this.options.radiusRange[1] / 2;
              };
              PieChartSeries2.prototype._calculateCenterXY = function _calculateCenterXY(radius) {
                var _layout = this.layout, _layout$dimension = _layout.dimension, width = _layout$dimension.width, height = _layout$dimension.height, _layout$position = _layout.position, top = _layout$position.top, left = _layout$position.left;
                var halfRadius = radius / 2;
                var cx = width / 2 + left;
                var cy = height / 2 + top;
                if (!this.isCombo) {
                  if (this._isInQuadrantRange(1, 1)) {
                    cx -= halfRadius;
                    cy += halfRadius;
                  } else if (this._isInQuadrantRange(1, 2)) {
                    cx -= halfRadius;
                  } else if (this._isInQuadrantRange(2, 2)) {
                    cx -= halfRadius;
                    cy -= halfRadius;
                  } else if (this._isInQuadrantRange(2, 3)) {
                    cy -= halfRadius;
                  } else if (this._isInQuadrantRange(3, 3)) {
                    cx += halfRadius;
                    cy -= halfRadius;
                  } else if (this._isInQuadrantRange(3, 4)) {
                    cx += halfRadius;
                  } else if (this._isInQuadrantRange(4, 1)) {
                    cy += halfRadius;
                  } else if (this._isInQuadrantRange(4, 4)) {
                    cx += halfRadius;
                    cy += halfRadius;
                  }
                }
                return {
                  cx,
                  cy
                };
              };
              PieChartSeries2.prototype._makeCircleBound = function _makeCircleBound() {
                var radius = this._calculateRadius();
                var centerXY = this._calculateCenterXY(radius);
                return Object.assign({
                  r: radius
                }, centerXY);
              };
              PieChartSeries2.prototype._getArcPosition = function _getArcPosition(params) {
                return {
                  left: params.cx + params.r * Math.sin(params.angle * RAD),
                  top: params.cy - params.r * Math.cos(params.angle * RAD)
                };
              };
              PieChartSeries2.prototype._renderGraph = function _renderGraph(dimension, seriesData, paper) {
                var showTooltip = this.showTooltip.bind(this, {
                  allowNegativeTooltip: !!this.allowNegativeTooltip,
                  seriesType: this.seriesType,
                  chartType: this.chartType
                });
                var callbacks = {
                  showTooltip,
                  hideTooltip: this.hideTooltip.bind(this)
                };
                var params = this._makeParamsForGraphRendering(dimension, seriesData);
                var currentSeriesName = this.seriesType;
                var seriesDataModelMap = this.dataProcessor.seriesDataModelMap;
                var pastSeriesNames = [];
                var pastIndex = 0;
                (this.dataProcessor.seriesTypes || []).forEach(function(seriesType) {
                  var needNext = true;
                  if (seriesType !== currentSeriesName) {
                    pastSeriesNames.push(seriesType);
                  } else {
                    needNext = false;
                  }
                  return needNext;
                });
                pastSeriesNames.forEach(function(seriesType) {
                  pastIndex += seriesDataModelMap[seriesType].baseGroups.length;
                });
                params.additionalIndex = pastIndex;
                return this.graphRenderer.render(paper, params, callbacks);
              };
              PieChartSeries2.prototype.showTooltip = function showTooltip(params, bound, groupIndex, index, mousePosition) {
                this.eventBus.fire("showTooltip", Object.assign({
                  indexes: {
                    groupIndex,
                    index
                  },
                  mousePosition
                }, params));
              };
              PieChartSeries2.prototype.hideTooltip = function hideTooltip() {
                this.eventBus.fire("hideTooltip");
              };
              PieChartSeries2.prototype._getMaxLengthLegendWidth = function _getMaxLengthLegendWidth() {
                var _this4 = this;
                var lableWidths = this.legendLabels.map(function(label) {
                  return _raphaelRenderUtil2["default"].getRenderedTextSize(label, _this4.labelTheme.fontSize, _this4.labelTheme.fontFamily).width;
                });
                lableWidths.sort(function(prev, next) {
                  return prev - next;
                });
                return lableWidths[lableWidths.length - 1];
              };
              PieChartSeries2.prototype._makeSeriesDataBySelection = function _makeSeriesDataBySelection(index) {
                return {
                  indexes: {
                    index,
                    groupIndex: index
                  }
                };
              };
              PieChartSeries2.prototype._pickPositionsFromSectorData = function _pickPositionsFromSectorData(positionType, dataType) {
                var _this5 = this;
                var _options2 = this.options, showLegend = _options2.showLegend, showLabel = _options2.showLabel;
                var legendLabelHeight = _raphaelRenderUtil2["default"].getRenderedTextSize(this.legendLabels[0], this.labelTheme.fontSize, this.labelTheme.fontFamily).height;
                var valueLabelHeight = _raphaelRenderUtil2["default"].getRenderedTextSize(this.valueLabels[0], PIE_GRAPH_LEGEND_LABEL_SIZE, this.labelTheme.fontFamily).height;
                return (this.seriesData.sectorData || []).map(function(datum) {
                  var position = datum.ratio ? Object.assign({}, datum[positionType]) : null;
                  var isReCalculatePosition = position && showLegend && showLabel && !_this5.isLabelAlignOuter;
                  if (isReCalculatePosition) {
                    if (dataType === "value") {
                      position.top -= valueLabelHeight / 2;
                    } else if (dataType === "legend") {
                      position.top += legendLabelHeight / 2;
                    }
                  }
                  return position;
                });
              };
              PieChartSeries2.prototype._addEndPosition = function _addEndPosition(centerLeft, positions) {
                positions.forEach(function(position) {
                  if (!position) {
                    return;
                  }
                  var end = Object.assign({}, position.middle);
                  if (end.left < centerLeft) {
                    end.left -= SERIES_OUTER_LABEL_PADDING;
                  } else {
                    end.left += SERIES_OUTER_LABEL_PADDING;
                  }
                  position.end = end;
                });
              };
              PieChartSeries2.prototype._moveToOuterPosition = function _moveToOuterPosition(centerLeft, position, label) {
                var positionEnd = position.end;
                var left = positionEnd.left, top = positionEnd.top;
                var OffsetX = this.graphRenderer.getRenderedLabelWidth(label, this.labelTheme) / 2 + SERIES_LABEL_PADDING;
                return {
                  left: left < centerLeft ? left - OffsetX : left + OffsetX,
                  top
                };
              };
              PieChartSeries2.prototype._setSeriesPosition = function _setSeriesPosition(params, labels) {
                var positions = [];
                if (params.funcMoveToPosition) {
                  positions = params.positions.map(function(position, index) {
                    if (position) {
                      return params.funcMoveToPosition(position, labels[index]);
                    }
                    return null;
                  });
                } else {
                  positions = params.positions;
                }
                return positions;
              };
              PieChartSeries2.prototype._renderSeriesLabel = function _renderSeriesLabel(paper) {
                var positions = [];
                var renderOption = {};
                var labelSet = paper.set();
                var graphRenderLabel = function(dataType, labels) {
                  var colors = void 0;
                  var theme = Object.assign({}, this.theme.label);
                  var ratioValues = this.ratioValues;
                  if (this.isLabelAlignOuter && dataType === "legend") {
                    colors = this.theme.colors;
                    theme.fontWeight = "bold";
                  }
                  theme.fontSize = dataType === "value" ? 16 : theme.fontSize;
                  positions = this._setSeriesPosition(renderOption, labels);
                  this.graphRenderer.renderLabels({
                    dataType,
                    paper,
                    labelSet,
                    positions,
                    labels,
                    ratioValues,
                    theme,
                    colors,
                    seriesNames: this.legendLabels,
                    labelFilter: this.options.labelFilter
                  });
                }.bind(this);
                if (this.options.showLabel) {
                  renderOption.positions = this._pickPositionsFromSectorData("centerPosition", "value");
                  graphRenderLabel("value", this.decorateLabel(this.valueLabels));
                }
                if (this.options.showLegend) {
                  var legendLabelPosition = this.isLabelAlignOuter ? "outerPosition" : "centerPosition";
                  renderOption.positions = this._pickPositionsFromSectorData(legendLabelPosition, "legend");
                  graphRenderLabel("legend", this.legendLabels);
                }
                return labelSet;
              };
              PieChartSeries2.prototype._isDetectedLabel = function _isDetectedLabel(position) {
                var labelElement = document.elementFromPoint(position.left, position.top);
                return (0, _isString2["default"])(labelElement.className);
              };
              PieChartSeries2.prototype.onClickSeries = function onClickSeries(position) {
                var sectorInfo = this._executeGraphRenderer(position, "findSectorInfo");
                var prevIndex = this.prevClickedIndex;
                var allowSelect = this.options.allowSelect;
                if ((sectorInfo || this._isDetectedLabel(position)) && (0, _isExisty2["default"])(prevIndex) && allowSelect) {
                  this.onUnselectSeries({
                    indexes: {
                      index: prevIndex
                    }
                  });
                  this.prevClickedIndex = null;
                }
                if (!sectorInfo || sectorInfo.chartType !== this.seriesType) {
                  return;
                }
                var foundIndex = sectorInfo.index;
                var shouldSelect = foundIndex > -1 && foundIndex !== prevIndex;
                if (allowSelect && !shouldSelect) {
                  return;
                }
                this.onSelectSeries({
                  chartType: this.chartType,
                  indexes: {
                    index: foundIndex,
                    legendIndex: sectorInfo.legendIndex
                  }
                }, shouldSelect);
                if (allowSelect && foundIndex > -1) {
                  this.prevClickedIndex = foundIndex;
                }
              };
              PieChartSeries2.prototype.onMoveSeries = function onMoveSeries(position) {
                this._executeGraphRenderer(position, "moveMouseOnSeries");
              };
              return PieChartSeries2;
            }(_series2["default"]);
            function pieSeriesFactory(params) {
              var _params$chartOptions = params.chartOptions, libType = _params$chartOptions.libType, chartType = _params$chartOptions.chartType, legendOption = _params$chartOptions.legend;
              var chartTheme = params.chartTheme;
              params.libType = libType;
              params.chartType = "pie";
              if (chartType === "combo") {
                var _params$name$split = params.name.split("Series");
                var _params$name$split2 = _slicedToArray(_params$name$split, 1);
                params.seriesType = _params$name$split2[0];
                params.isCombo = true;
              }
              if (legendOption) {
                params.legendMaxWidth = legendOption.maxWidth;
              }
              params.chartBackground = chartTheme.chart.background;
              return new PieChartSeries(params);
            }
            pieSeriesFactory.componentType = "series";
            pieSeriesFactory.PieChartSeries = PieChartSeries;
          },
          /* 122 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = heatmapChartSeriesFactory;
            var _series = __webpack_require__(109);
            var _series2 = _interopRequireDefault(_series);
            var _renderingLabelHelper = __webpack_require__(111);
            var _renderingLabelHelper2 = _interopRequireDefault(_renderingLabelHelper);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var HeatmapChartSeries = function(_Series) {
              _inherits(HeatmapChartSeries2, _Series);
              function HeatmapChartSeries2(params) {
                _classCallCheck(this, HeatmapChartSeries2);
                var _this = _possibleConstructorReturn(this, _Series.call(this, params));
                _this.colorSpectrum = params.colorSpectrum;
                return _this;
              }
              HeatmapChartSeries2.prototype._makeSeriesData = function _makeSeriesData() {
                var groupBounds = this._makeBounds();
                var seriesDataModel = this._getSeriesDataModel();
                return {
                  colorSpectrum: this.colorSpectrum,
                  groupBounds,
                  seriesDataModel,
                  isAvailable: function isAvailable() {
                    return groupBounds && groupBounds.length > 0;
                  }
                };
              };
              HeatmapChartSeries2.prototype._makeBound = function _makeBound(blockWidth, blockHeight, x, y) {
                var _layout = this.layout, height = _layout.dimension.height, _layout$position = _layout.position, top = _layout$position.top, left = _layout$position.left;
                return {
                  end: {
                    left: left + blockWidth * x,
                    top: top + height - blockHeight * (y + 1),
                    width: blockWidth,
                    height: blockHeight
                  }
                };
              };
              HeatmapChartSeries2.prototype._makeBounds = function _makeBounds() {
                var _this2 = this;
                var seriesDataModel = this._getSeriesDataModel();
                var _layout$dimension = this.layout.dimension, width = _layout$dimension.width, height = _layout$dimension.height;
                var blockWidth = width / this.dataProcessor.getCategoryCount(false);
                var blockHeight = height / this.dataProcessor.getCategoryCount(true);
                return seriesDataModel.map(function(seriesGroup, x) {
                  return seriesGroup.map(function(seriesItem, y) {
                    return _this2._makeBound(blockWidth, blockHeight, x, y);
                  });
                });
              };
              HeatmapChartSeries2.prototype.onShowTooltip = function onShowTooltip(_ref) {
                var indexes = _ref.indexes;
                var seriesDataModel = this._getSeriesDataModel();
                var _seriesDataModel$getS = seriesDataModel.getSeriesItem(indexes.groupIndex, indexes.index), ratio = _seriesDataModel$getS.ratio, label = _seriesDataModel$getS.label;
                this.eventBus.fire("showWedge", ratio, label);
              };
              HeatmapChartSeries2.prototype._renderSeriesLabel = function _renderSeriesLabel(paper) {
                var _this3 = this;
                var sdm = this._getSeriesDataModel();
                var boundsSet = this.seriesData.groupBounds;
                var labelTheme = this.theme.label;
                var selectedIndex = this.selectedLegendIndex;
                var positionsSet = _renderingLabelHelper2["default"].boundsToLabelPositions(sdm, boundsSet, labelTheme);
                var labels = sdm.map(function(datum) {
                  return _this3.decorateLabel(datum.valuesMap.value);
                });
                return this.graphRenderer.renderSeriesLabel(paper, positionsSet, labels, labelTheme, selectedIndex);
              };
              HeatmapChartSeries2.prototype.resize = function resize() {
                this.boundMap = null;
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _series2["default"].prototype.resize.apply(this, args);
              };
              HeatmapChartSeries2.prototype._makeExportationSeriesData = function _makeExportationSeriesData(_ref2) {
                var indexes = _ref2.indexes;
                return {
                  x: indexes.groupIndex,
                  y: indexes.index
                };
              };
              return HeatmapChartSeries2;
            }(_series2["default"]);
            function heatmapChartSeriesFactory(params) {
              params.libType = params.chartOptions.libType;
              params.chartType = "heatmap";
              return new HeatmapChartSeries(params);
            }
            heatmapChartSeriesFactory.componentType = "series";
            heatmapChartSeriesFactory.HeatmapChartSeries = HeatmapChartSeries;
          },
          /* 123 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = treemapChartSeriesFactory;
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _series = __webpack_require__(109);
            var _series2 = _interopRequireDefault(_series);
            var _squarifier = __webpack_require__(124);
            var _squarifier2 = _interopRequireDefault(_squarifier);
            var _renderingLabelHelper = __webpack_require__(111);
            var _renderingLabelHelper2 = _interopRequireDefault(_renderingLabelHelper);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var TreemapChartSeries = function(_Series) {
              _inherits(TreemapChartSeries2, _Series);
              function TreemapChartSeries2(params) {
                _classCallCheck(this, TreemapChartSeries2);
                var _this = _possibleConstructorReturn(this, _Series.call(this, params));
                _this.theme.borderColor = _this.theme.borderColor || _const2["default"].TREEMAP_DEFAULT_BORDER;
                _this.theme.label.color = _this.options.useColorValue ? "#000" : "#fff";
                _this.rootId = _const2["default"].TREEMAP_ROOT_ID;
                _this.startDepth = 1;
                _this.selectedGroup = null;
                _this.boundMap = null;
                _this.colorSpectrum = params.colorSpectrum;
                _this._initOptions();
                return _this;
              }
              TreemapChartSeries2.prototype._initOptions = function _initOptions() {
                this.options.useColorValue = !!this.options.useColorValue;
                if ((0, _isUndefined2["default"])(this.options.zoomable)) {
                  this.options.zoomable = !this.options.useColorValue;
                }
                if ((0, _isUndefined2["default"])(this.options.useLeafLabel)) {
                  this.options.useLeafLabel = !this.options.zoomable;
                }
              };
              TreemapChartSeries2.prototype._makeSeriesData = function _makeSeriesData() {
                var boundMap = this._getBoundMap();
                var groupBounds = this._makeBounds(boundMap);
                return {
                  boundMap,
                  groupBounds,
                  seriesDataModel: this._getSeriesDataModel(),
                  startDepth: this.startDepth,
                  isPivot: true,
                  colorSpectrum: this.options.useColorValue ? this.colorSpectrum : null,
                  chartBackground: this.chartBackground,
                  zoomable: this.options.zoomable,
                  isAvailable: function isAvailable() {
                    return groupBounds && groupBounds.length > 0;
                  }
                };
              };
              TreemapChartSeries2.prototype._makeBoundMap = function _makeBoundMap(parent, boundMap, layout) {
                var _this2 = this;
                var seriesDataModel = this._getSeriesDataModel();
                var defaultLayout = Object.assign({}, this.layout.dimension, this.layout.position);
                var seriesItems = seriesDataModel.findSeriesItemsByParent(parent);
                layout = layout || defaultLayout;
                boundMap = Object.assign(boundMap || {}, _squarifier2["default"].squarify(layout, seriesItems));
                seriesItems.forEach(function(seriesItem) {
                  boundMap = _this2._makeBoundMap(seriesItem.id, boundMap, boundMap[seriesItem.id]);
                });
                return boundMap;
              };
              TreemapChartSeries2.prototype._makeBounds = function _makeBounds(boundMap) {
                var startDepth = this.startDepth;
                var seriesDataModel = this._getSeriesDataModel();
                var isValid = void 0;
                if (this.options.zoomable) {
                  isValid = function isValid2(seriesItem) {
                    return seriesItem.depth === startDepth;
                  };
                } else {
                  isValid = function isValid2(seriesItem) {
                    return !seriesItem.hasChild;
                  };
                }
                return seriesDataModel.map(function(seriesGroup) {
                  return seriesGroup.map(function(seriesItem) {
                    var bound = boundMap[seriesItem.id];
                    var result = null;
                    if (bound && isValid(seriesItem)) {
                      result = {
                        end: bound
                      };
                    }
                    return result;
                  }, true);
                }, true);
              };
              TreemapChartSeries2.prototype._getBoundMap = function _getBoundMap() {
                if (!this.boundMap) {
                  this.boundMap = this._makeBoundMap(this.rootId);
                }
                return this.boundMap;
              };
              TreemapChartSeries2.prototype._shouldDimmed = function _shouldDimmed(seriesDataModel, hoverSeriesItem, seriesItem) {
                var shouldTransparent = false;
                if (hoverSeriesItem && seriesItem.id !== hoverSeriesItem.id && seriesItem.group === hoverSeriesItem.group) {
                  var parent = seriesDataModel.findParentByDepth(seriesItem.id, hoverSeriesItem.depth + 1);
                  if (parent && parent.parent === hoverSeriesItem.id) {
                    shouldTransparent = true;
                  }
                }
                return shouldTransparent;
              };
              TreemapChartSeries2.prototype._renderSeriesLabel = function _renderSeriesLabel(paper) {
                var _this3 = this;
                var seriesDataModel = this._getSeriesDataModel();
                var boundMap = this._getBoundMap();
                var labelTheme = this.theme.label;
                var labelTemplate = this.options.labelTemplate;
                var seriesItems = void 0;
                if (this.options.useLeafLabel) {
                  seriesItems = seriesDataModel.findLeafSeriesItems(this.selectedGroup);
                } else {
                  seriesItems = seriesDataModel.findSeriesItemsByDepth(this.startDepth, this.selectedGroup);
                }
                var labels = seriesItems.map(function(seriesItem) {
                  var labelText = labelTemplate ? labelTemplate(seriesItem.pickLabelTemplateData()) : seriesItem.label;
                  return _this3.decorateLabel(labelText);
                });
                var positions = _renderingLabelHelper2["default"].boundsToLabelPostionsForTreemap(seriesItems, boundMap, labelTheme);
                return this.graphRenderer.renderSeriesLabelForTreemap(paper, positions, labels, labelTheme);
              };
              TreemapChartSeries2.prototype.resize = function resize() {
                this.boundMap = null;
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _series2["default"].prototype.resize.apply(this, args);
              };
              TreemapChartSeries2.prototype._zoom = function _zoom(rootId, startDepth, group) {
                this._clearSeriesContainer();
                this.boundMap = null;
                this.rootId = rootId;
                this.startDepth = startDepth;
                this.selectedGroup = group;
                this._renderSeriesArea(this.paper, this._renderGraph.bind(this));
                this.animateComponent(true);
              };
              TreemapChartSeries2.prototype.zoom = function zoom(data) {
                var detectedIndex = data.index;
                this.labelSet.remove();
                if (detectedIndex === -1) {
                  this._zoom(_const2["default"].TREEMAP_ROOT_ID, 1, null);
                  return;
                }
                var seriesDataModel = this._getSeriesDataModel();
                var seriesItem = seriesDataModel.getSeriesItem(0, detectedIndex, true);
                if (!seriesItem || !seriesItem.hasChild) {
                  return;
                }
                this._zoom(seriesItem.id, seriesItem.depth + 1, seriesItem.group);
                this.eventBus.fire("afterZoom", detectedIndex);
              };
              TreemapChartSeries2.prototype._makeExportationSeriesData = function _makeExportationSeriesData(seriesData) {
                var indexes = seriesData.indexes;
                var seriesItem = this._getSeriesDataModel().getSeriesItem(indexes.groupIndex, indexes.index, true);
                return Object.assign({
                  chartType: this.chartType,
                  indexes: seriesItem.indexes
                });
              };
              TreemapChartSeries2.prototype.onHoverSeries = function onHoverSeries(indexes) {
                if (!_predicate2["default"].isShowLabel(this.options)) {
                  return;
                }
                var item = this._getSeriesDataModel().getSeriesItem(indexes.groupIndex, indexes.index, true);
                var ratio = item.colorRatio;
                this.graphRenderer.showAnimation(indexes, this.options.useColorValue, 0.6);
                if (ratio > -1) {
                  this.eventBus.fire("showWedge", ratio, item.colorValue);
                }
              };
              TreemapChartSeries2.prototype.onHoverOffSeries = function onHoverOffSeries(indexes) {
                if (!_predicate2["default"].isShowLabel(this.options) || !indexes) {
                  return;
                }
                this.graphRenderer.hideAnimation(indexes, this.options.useColorValue);
              };
              return TreemapChartSeries2;
            }(_series2["default"]);
            function treemapChartSeriesFactory(params) {
              params.libType = params.chartOptions.libType;
              params.chartType = "treemap";
              params.chartBackground = params.chartTheme.chart.background;
              return new TreemapChartSeries(params);
            }
            treemapChartSeriesFactory.componentType = "series";
            treemapChartSeriesFactory.TreemapChartSeries = TreemapChartSeries;
          },
          /* 124 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _pluck = __webpack_require__(58);
            var _pluck2 = _interopRequireDefault(_pluck);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            exports2["default"] = {
              /**
               * bound map
               * @type {object.<string, {width: number, height: number, left: number, top: number}>}
               */
              boundMap: {},
              /**
                 * Make base bound for calculating bounds.
                  * @param {{width: number, height: number, left: number, top: number}} layout - layout
                 * @returns {{width: number, height: number, left: number, top: number}}
                 * @private
                 */
              _makeBaseBound: function _makeBaseBound(layout) {
                return Object.assign({}, layout);
              },
              /**
               * Calculate scale for calculating weight.
               * @param {Array.<number>} values - values
               * @param {number} width - width of series area
               * @param {number} height - height of series area
               * @returns {number}
               * @private
               */
              _calculateScale: function _calculateScale(values, width, height) {
                return width * height / _calculator2["default"].sum(values);
              },
              /**
               * Make base data for creating squarified bounds.
               * @param {Array.<SeriesItem>} seriesItems - SeriesItems
               * @param {number} width - width of series area
               * @param {number} height - height of series area
               * @returns {Array.<{itme: SeriesItem, weight: number}>}
               * @private
               */
              _makeBaseData: function _makeBaseData(seriesItems, width, height) {
                var scale = this._calculateScale((0, _pluck2["default"])(seriesItems, "value"), width, height);
                var data = seriesItems.map(function(seriesItem) {
                  return {
                    id: seriesItem.id,
                    weight: seriesItem.value * scale
                  };
                }).sort(function(a, b) {
                  return b.weight - a.weight;
                });
                return data;
              },
              /**
               * Calculate worst aspect ratio.
               * Referred function worst() in https://www.win.tue.nl/~vanwijk/stm.pdf
               * @param {number} sum - sum for weights
               * @param {number} min - minimum weight
               * @param {number} max - maximum weight
               * @param {number} baseSize - base size (width or height)
               * @returns {number}
               * @private
               */
              _worst: function _worst(sum, min, max, baseSize) {
                var sumSquare = sum * sum;
                var sizeSquare = baseSize * baseSize;
                return Math.max(sizeSquare * max / sumSquare, sumSquare / (sizeSquare * min));
              },
              /**
               * Whether changed stack direction or not.
               * @param {number} sum - sum for weights
               * @param {Array.<number>} weights - weights
               * @param {number} baseSize - base size
               * @param {number} newWeight - new weight
               * @returns {boolean}
               * @private
               */
              _changedStackDirection: function _changedStackDirection(sum, weights, baseSize, newWeight) {
                var min = _arrayUtil2["default"].min(weights);
                var max = _arrayUtil2["default"].max(weights);
                var beforeWorst = this._worst(sum, min, max, baseSize);
                var newWorst = this._worst(sum + newWeight, Math.min(min, newWeight), Math.max(max, newWeight), baseSize);
                return newWorst >= beforeWorst;
              },
              /**
               * Whether type of vertical stack or not.
               * @param {{width: number, height: number}} baseBound - base bound
               * @returns {boolean}
               * @private
               */
              _isVerticalStack: function _isVerticalStack(baseBound) {
                return baseBound.height < baseBound.width;
              },
              /**
               * Select base size from baseBound.
               * @param {{width: number, height: number}} baseBound - base bound
               * @returns {number}
               * @private
               */
              _selectBaseSize: function _selectBaseSize(baseBound) {
                return this._isVerticalStack(baseBound) ? baseBound.height : baseBound.width;
              },
              /**
               * Calculate fixed size.
               * @param {number} baseSize - base size
               * @param {number} sum - sum for weights
               * @param {Array.<{weight: number}>} row - row
               * @returns {number}
               * @private
               */
              _calculateFixedSize: function _calculateFixedSize(baseSize, sum, row) {
                if (!sum) {
                  var weights = (0, _pluck2["default"])(row, "weight");
                  sum = _calculator2["default"].sum(weights);
                }
                return sum / baseSize;
              },
              /**
               * Add bounds.
               * @param {number} startPosition - start position
               * @param {Array.<{weight: number}>} row - row
               * @param {number} fixedSize - fixed size
               * @param {function} callback - callback function
               * @private
               */
              _addBounds: function _addBounds(startPosition, row, fixedSize, callback) {
                [startPosition].concat(row).reduce(function(storedPosition, rowDatum) {
                  var dynamicSize = rowDatum.weight / fixedSize;
                  callback(dynamicSize, storedPosition, rowDatum.id);
                  return storedPosition + dynamicSize;
                });
              },
              /**
               * Add bound.
               * @param {number} left - left position
               * @param {number} top - top position
               * @param {number} width - width
               * @param {number} height - height
               * @param {string | number} id - id of seriesItem
               * @private
               */
              _addBound: function _addBound(left, top, width, height, id) {
                this.boundMap[id] = {
                  left,
                  top,
                  width,
                  height
                };
              },
              /**
               * Add bounds for type of vertical stack.
               * @param {Array.<{weight: number}>} row - row
               * @param {{left: number, top: number, width: number, height: number}} baseBound - base bound
               * @param {number} baseSize - base size
               * @param {number} sum - sum for weights of row
               * @private
               */
              _addBoundsForVerticalStack: function _addBoundsForVerticalStack(row, baseBound, baseSize, sum) {
                var _this = this;
                var fixedWidth = this._calculateFixedSize(baseSize, sum, row);
                this._addBounds(baseBound.top, row, fixedWidth, function(dynamicHeight, storedTop, id) {
                  _this._addBound(baseBound.left, storedTop, fixedWidth, dynamicHeight, id);
                });
                baseBound.left += fixedWidth;
                baseBound.width -= fixedWidth;
              },
              /**
               * Add bounds for type of horizontal stack.
               * @param {Array.<{weight: number}>} row - row
               * @param {{left: number, top: number, width: number, height: number}} baseBound - base bound
               * @param {number} baseSize - base size
               * @param {number} sum - sum for weights of row
               * @private
               */
              _addBoundsForHorizontalStack: function _addBoundsForHorizontalStack(row, baseBound, baseSize, sum) {
                var _this2 = this;
                var fixedHeight = this._calculateFixedSize(baseSize, sum, row);
                this._addBounds(baseBound.left, row, fixedHeight, function(dynamicWidth, storedLeft, id) {
                  _this2._addBound(storedLeft, baseBound.top, dynamicWidth, fixedHeight, id);
                });
                baseBound.top += fixedHeight;
                baseBound.height -= fixedHeight;
              },
              /**
               * Get adding bounds function.
               * @param {{width: number, height: number}} baseBound - base bound
               * @returns {*}
               * @private
               */
              _getAddingBoundsFunction: function _getAddingBoundsFunction(baseBound) {
                if (this._isVerticalStack(baseBound)) {
                  return this._addBoundsForVerticalStack.bind(this);
                }
                return this._addBoundsForHorizontalStack.bind(this);
              },
              /**
               * Create squarified bound map for graph rendering.
               * @param {object} layout - series area layout
               * @param {Array.<SeriesItem>} seriesItems - seriesItems
               * @returns {object.<string, {width: number, height: number, left: number, top: number}>}
               */
              squarify: function squarify(layout, seriesItems) {
                var _this3 = this;
                var baseBound = this._makeBaseBound(layout);
                var baseData = this._makeBaseData(seriesItems, baseBound.width, baseBound.height);
                var row = [];
                var baseSize = void 0, addBounds = void 0;
                this.boundMap = {};
                baseData.forEach(function(datum) {
                  var weights = (0, _pluck2["default"])(row, "weight");
                  var sum = _calculator2["default"].sum(weights);
                  if (row.length && _this3._changedStackDirection(sum, weights, baseSize, datum.weight)) {
                    addBounds(row, baseBound, baseSize, sum);
                    row = [];
                  }
                  if (!row.length) {
                    baseSize = _this3._selectBaseSize(baseBound);
                    addBounds = _this3._getAddingBoundsFunction(baseBound);
                  }
                  row.push(datum);
                });
                if (row.length) {
                  addBounds(row, baseBound, baseSize);
                }
                return this.boundMap;
              }
            };
          },
          /* 125 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = boxplotSeriesFactory;
            var _series = __webpack_require__(109);
            var _series2 = _interopRequireDefault(_series);
            var _barTypeSeriesBase = __webpack_require__(110);
            var _barTypeSeriesBase2 = _interopRequireDefault(_barTypeSeriesBase);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var SERIES_EXPAND_SIZE = _const2["default"].SERIES_EXPAND_SIZE, TEXT_PADDING = _const2["default"].TEXT_PADDING;
            var BoxplotChartSeries = function(_Series) {
              _inherits(BoxplotChartSeries2, _Series);
              function BoxplotChartSeries2() {
                _classCallCheck(this, BoxplotChartSeries2);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                var _this = _possibleConstructorReturn(this, _Series.call.apply(_Series, [this].concat(args)));
                _this.supportSeriesLable = false;
                return _this;
              }
              BoxplotChartSeries2.prototype._makeBoxplotChartBound = function _makeBoxplotChartBound(baseData, iterationData, isStackType, seriesItem, index) {
                var pointInterval = baseData.pointInterval, barSize = baseData.barSize, baseBarSize = baseData.baseBarSize, basePosition = baseData.basePosition;
                var boxHeight = Math.abs(baseBarSize * seriesItem.ratioDistance);
                var boxStartTop = baseBarSize * (1 - seriesItem.lqRatio);
                var startTop = basePosition + boxStartTop + SERIES_EXPAND_SIZE;
                var baseTopPosition = basePosition + SERIES_EXPAND_SIZE;
                var pointCount = index;
                var endTop = void 0;
                iterationData.left = iterationData.baseLeft + pointInterval * pointCount;
                iterationData.plusTop = 0;
                iterationData.minusTop = 0;
                if (seriesItem.value >= 0) {
                  iterationData.plusTop -= boxHeight;
                  endTop = startTop + iterationData.plusTop;
                } else {
                  endTop = startTop + iterationData.minusTop;
                  iterationData.minusTop += boxHeight;
                }
                var boundLeft = iterationData.left + pointInterval - barSize / 2;
                var outliers = (seriesItem.outliers || []).map(function(outlier) {
                  return {
                    top: baseBarSize * (1 - outlier.ratio) + baseTopPosition,
                    left: boundLeft + barSize / 2
                  };
                });
                return {
                  start: {
                    top: startTop,
                    left: boundLeft,
                    width: barSize,
                    height: 0
                  },
                  end: {
                    top: endTop,
                    left: boundLeft,
                    width: barSize,
                    height: boxHeight
                  },
                  min: {
                    top: baseBarSize * (1 - seriesItem.minRatio) + baseTopPosition,
                    left: boundLeft,
                    width: barSize,
                    height: 0
                  },
                  max: {
                    top: baseBarSize * (1 - seriesItem.maxRatio) + baseTopPosition,
                    left: boundLeft,
                    width: barSize,
                    height: 0
                  },
                  median: {
                    top: baseBarSize * (1 - seriesItem.medianRatio) + baseTopPosition,
                    left: boundLeft,
                    width: barSize,
                    height: 0
                  },
                  outliers
                };
              };
              BoxplotChartSeries2.prototype._makeBounds = function _makeBounds() {
                var _this2 = this;
                var seriesDataModel = this._getSeriesDataModel();
                var isStackType = _predicate2["default"].isValidStackOption(this.options.stack);
                var _layout$dimension = this.layout.dimension, width = _layout$dimension.width, height = _layout$dimension.height;
                var baseData = this._makeBaseDataForMakingBound(width, height);
                return seriesDataModel.map(function(seriesGroup, groupIndex) {
                  var baseLeft = groupIndex * baseData.groupSize + _this2.layout.position.left;
                  var iterationData = {
                    baseLeft,
                    left: baseLeft,
                    plusTop: 0,
                    minusTop: 0,
                    prevStack: null
                  };
                  var iteratee = _this2._makeBoxplotChartBound.bind(_this2, baseData, iterationData, isStackType);
                  return seriesGroup.map(iteratee);
                });
              };
              BoxplotChartSeries2.prototype._calculateLeftPositionOfSumLabel = function _calculateLeftPositionOfSumLabel(_ref, formattedSum) {
                var left = _ref.left, width = _ref.width;
                var labelWidth = _renderUtil2["default"].getRenderedLabelWidth(formattedSum, this.theme.label);
                return left + (width - labelWidth + TEXT_PADDING) / 2;
              };
              return BoxplotChartSeries2;
            }(_series2["default"]);
            _barTypeSeriesBase2["default"].mixin(BoxplotChartSeries);
            function boxplotSeriesFactory(params) {
              var libType = params.chartOptions.libType, chartTheme = params.chartTheme;
              params.libType = libType;
              params.chartType = "boxplot";
              params.chartBackground = chartTheme.chart.background;
              return new BoxplotChartSeries(params);
            }
            boxplotSeriesFactory.componentType = "series";
            boxplotSeriesFactory.BoxplotChartSeries = BoxplotChartSeries;
          },
          /* 126 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = bulletSeriesFactory;
            var _series = __webpack_require__(109);
            var _series2 = _interopRequireDefault(_series);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var BULLET_TYPE_ACTUAL = _const2["default"].BULLET_TYPE_ACTUAL, BULLET_ACTUAL_HEIGHT_RATIO = _const2["default"].BULLET_ACTUAL_HEIGHT_RATIO, BULLET_TYPE_RANGE = _const2["default"].BULLET_TYPE_RANGE, BULLET_RANGES_HEIGHT_RATIO = _const2["default"].BULLET_RANGES_HEIGHT_RATIO, BULLET_TYPE_MARKER = _const2["default"].BULLET_TYPE_MARKER, BULLET_MARKERS_HEIGHT_RATIO = _const2["default"].BULLET_MARKERS_HEIGHT_RATIO, BULLET_MARKER_DETECT_PADDING = _const2["default"].BULLET_MARKER_DETECT_PADDING, MAX_HEIGHT_WORD = _const2["default"].MAX_HEIGHT_WORD;
            var BulletChartSeries = function(_Series) {
              _inherits(BulletChartSeries2, _Series);
              function BulletChartSeries2(params) {
                _classCallCheck(this, BulletChartSeries2);
                var _this = _possibleConstructorReturn(this, _Series.call(this, params));
                _this.isVertical = params.isVertical;
                return _this;
              }
              BulletChartSeries2.prototype._makeSeriesData = function _makeSeriesData() {
                var groupBounds = this._makeBounds();
                return {
                  groupBounds,
                  seriesDataModel: this._getSeriesDataModel(),
                  isVertical: this.isVertical,
                  isAvailable: function isAvailable() {
                    return groupBounds && groupBounds.length > 0;
                  }
                };
              };
              BulletChartSeries2.prototype._makeBounds = function _makeBounds() {
                var _this2 = this;
                var seriesDataModel = this._getSeriesDataModel();
                var baseData = this._makeBaseDataForMakingBound();
                var iterationData = {
                  renderedItemCount: 0,
                  top: baseData.categoryAxisTop,
                  left: baseData.categoryAxisLeft
                };
                return seriesDataModel.map(function(seriesGroup) {
                  var iteratee = _this2._makeBulletChartBound.bind(_this2, baseData, iterationData);
                  var bounds = seriesGroup.map(iteratee);
                  _this2._updateIterationData(iterationData, baseData.itemWidth);
                  return bounds;
                });
              };
              BulletChartSeries2.prototype._makeBaseDataForMakingBound = function _makeBaseDataForMakingBound() {
                var groupCount = this._getSeriesDataModel().getGroupCount();
                var _layout = this.layout, _layout$dimension = _layout.dimension, width = _layout$dimension.width, height = _layout$dimension.height, position = _layout.position;
                var categoryAxisLeft = position.left;
                var categoryAxisTop = position.top;
                var categoryAxisWidth = void 0, valueAxisWidth = void 0;
                if (this.isVertical) {
                  categoryAxisTop += height;
                  categoryAxisWidth = width;
                  valueAxisWidth = height;
                } else {
                  categoryAxisWidth = height;
                  valueAxisWidth = width;
                }
                var itemWidth = categoryAxisWidth / groupCount;
                return {
                  categoryAxisTop,
                  categoryAxisLeft,
                  categoryAxisWidth,
                  valueAxisWidth,
                  itemWidth
                };
              };
              BulletChartSeries2.prototype._makeBulletChartBound = function _makeBulletChartBound(baseData, iterationData, item) {
                var type = item.type;
                var bound = void 0;
                if (type === BULLET_TYPE_ACTUAL) {
                  bound = this._makeBarBound(item, BULLET_ACTUAL_HEIGHT_RATIO, baseData, iterationData);
                } else if (type === BULLET_TYPE_RANGE) {
                  bound = this._makeBarBound(item, BULLET_RANGES_HEIGHT_RATIO, baseData, iterationData);
                } else if (type === BULLET_TYPE_MARKER) {
                  bound = this._makeLineBound(item, BULLET_MARKERS_HEIGHT_RATIO, baseData, iterationData);
                }
                bound.type = type;
                return bound;
              };
              BulletChartSeries2.prototype._makeBarBound = function _makeBarBound(_ref, widthRatio, baseData, iterationData) {
                var ratioDistance = _ref.ratioDistance, endRatio = _ref.endRatio;
                var barWidth = baseData.itemWidth * widthRatio;
                var barHeight = baseData.valueAxisWidth * ratioDistance;
                var barEndHeight = baseData.valueAxisWidth * endRatio;
                var bound = void 0;
                if (this.isVertical) {
                  bound = this._makeVerticalBarBound(iterationData, baseData, barWidth, barHeight, barEndHeight);
                } else {
                  bound = this._makeHorizontalBarBound(iterationData, baseData, barWidth, barHeight, barEndHeight);
                }
                return bound;
              };
              BulletChartSeries2.prototype._makeVerticalBarBound = function _makeVerticalBarBound(iterationData, baseData, barWidth, barHeight, barEndHeight) {
                return {
                  top: iterationData.top - barEndHeight,
                  left: iterationData.left + (baseData.itemWidth - barWidth) / 2,
                  width: barWidth,
                  height: barHeight
                };
              };
              BulletChartSeries2.prototype._makeHorizontalBarBound = function _makeHorizontalBarBound(iterationData, baseData, barWidth, barHeight, barEndHeight) {
                return {
                  top: iterationData.top + (baseData.itemWidth - barWidth) / 2,
                  left: iterationData.left + barEndHeight - barHeight,
                  width: barHeight,
                  height: barWidth
                };
              };
              BulletChartSeries2.prototype._makeLineBound = function _makeLineBound(model, widthRatio, baseData, iterationData) {
                var itemWidth = baseData.itemWidth, valueAxisWidth = baseData.valueAxisWidth;
                var lineWidth = itemWidth * widthRatio;
                var endHeight = valueAxisWidth * model.endRatio;
                var height = BULLET_MARKER_DETECT_PADDING;
                var width = BULLET_MARKER_DETECT_PADDING;
                var top = void 0, left = void 0;
                if (this.isVertical) {
                  top = iterationData.top - endHeight;
                  left = iterationData.left + (itemWidth - lineWidth) / 2;
                  width = lineWidth;
                } else {
                  top = iterationData.top + (itemWidth - lineWidth) / 2;
                  left = iterationData.left + endHeight;
                  height = lineWidth;
                }
                return {
                  top,
                  left,
                  width,
                  height,
                  length: lineWidth
                };
              };
              BulletChartSeries2.prototype._updateIterationData = function _updateIterationData(iterationData, itemWidth) {
                iterationData.renderedItemCount += 1;
                if (this.isVertical) {
                  iterationData.left += itemWidth;
                } else {
                  iterationData.top += itemWidth;
                }
              };
              BulletChartSeries2.prototype._renderSeriesArea = function _renderSeriesArea(paper, funcRenderGraph) {
                _series2["default"].prototype._renderSeriesArea.call(this, paper, funcRenderGraph);
                this.dataProcessor.setGraphColors(this.graphRenderer.getGraphColors());
              };
              BulletChartSeries2.prototype._renderSeriesLabel = function _renderSeriesLabel(paper) {
                var theme = this.theme.label;
                var seriesDataModel = this._getSeriesDataModel();
                var groupLabels = this._getLabelTexts(seriesDataModel);
                var positionsSet = this._calculateLabelPositions(seriesDataModel, theme);
                return this.graphRenderer.renderSeriesLabel(paper, positionsSet, groupLabels, theme);
              };
              BulletChartSeries2.prototype._getLabelTexts = function _getLabelTexts(seriesDataModel) {
                var _this3 = this;
                return seriesDataModel.map(function(seriesGroup) {
                  var seriesLabels = [];
                  seriesGroup.each(function(seriesDatum) {
                    if (seriesDatum.type !== BULLET_TYPE_RANGE) {
                      seriesLabels.push(_this3.decorateLabel(seriesDatum.endLabel));
                    }
                  });
                  return seriesLabels;
                });
              };
              BulletChartSeries2.prototype._calculateLabelPositions = function _calculateLabelPositions(seriesDataModel, theme) {
                var _this4 = this;
                var serieses = this.seriesData.groupBounds;
                var labelHeight = _renderUtil2["default"].getRenderedLabelHeight(MAX_HEIGHT_WORD, theme);
                return serieses.map(function(series) {
                  var bounds = [];
                  series.forEach(function(item) {
                    if (item.type !== BULLET_TYPE_RANGE) {
                      bounds.push(_this4._makePositionByBound(item, labelHeight));
                    }
                  });
                  return bounds;
                });
              };
              BulletChartSeries2.prototype._makePositionByBound = function _makePositionByBound(bound, labelHeight) {
                var boundTop = bound.top;
                var boundLeft = bound.left;
                var position = {};
                if (this.isVertical) {
                  var width = bound.width || bound.length;
                  position.top = boundTop - labelHeight;
                  position.left = boundLeft + width / 2;
                } else {
                  var _width = bound.width || 0;
                  var height = bound.height || bound.length;
                  position.top = boundTop + height / 2;
                  position.left = boundLeft + 5 + (_width || 0);
                }
                return position;
              };
              return BulletChartSeries2;
            }(_series2["default"]);
            function bulletSeriesFactory(params) {
              params.chartType = "bullet";
              params.libType = params.chartOptions.libType;
              params.chartBackground = params.chartTheme.chart.background;
              return new BulletChartSeries(params);
            }
            bulletSeriesFactory.componentType = "series";
            bulletSeriesFactory.BulletChartSeries = BulletChartSeries;
          },
          /* 127 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = zoomFactory;
            var _browser = __webpack_require__(22);
            var _browser2 = _interopRequireDefault(_browser);
            var _seriesTemplate = __webpack_require__(128);
            var _seriesTemplate2 = _interopRequireDefault(_seriesTemplate);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _domHandler = __webpack_require__(24);
            var _domHandler2 = _interopRequireDefault(_domHandler);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _eventListener = __webpack_require__(80);
            var _eventListener2 = _interopRequireDefault(_eventListener);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var COMPONENT_TYPE_DOM = _const2["default"].COMPONENT_TYPE_DOM, MAP_CHART_ZOOM_AREA_HEIGHT = _const2["default"].MAP_CHART_ZOOM_AREA_HEIGHT, MAP_CHART_ZOOM_AREA_WIDTH = _const2["default"].MAP_CHART_ZOOM_AREA_WIDTH, CHART_PADDING = _const2["default"].CHART_PADDING;
            var IS_MSIE_VERSION_LTE_THAN_8 = _browser2["default"].msie && _browser2["default"].version <= 8;
            var Zoom = function() {
              function Zoom2(params) {
                _classCallCheck(this, Zoom2);
                this.className = "tui-chart-zoom-area";
                var seriesTypes = params.seriesTypes;
                var isMapChart = seriesTypes && seriesTypes.length ? _predicate2["default"].isMapChart(seriesTypes[0]) : false;
                var legendOption = params.dataProcessor.options.legend;
                var isLegendTop = _predicate2["default"].isLegendAlignTop(legendOption.align);
                var isLegendVisible = legendOption.visible !== false;
                this.isMapLegendTop = isMapChart && isLegendTop && isLegendVisible;
                this.eventBus = params.eventBus;
                this.magn = 1;
                this.stackedWheelDelta = 0;
                this.drawingType = COMPONENT_TYPE_DOM;
                this._attachToEventBus();
              }
              Zoom2.prototype._attachToEventBus = function _attachToEventBus() {
                this.eventBus.on("wheel", this.onWheel, this);
              };
              Zoom2.prototype.render = function render(data) {
                var container = void 0;
                if (!IS_MSIE_VERSION_LTE_THAN_8) {
                  var positionTop = _calculator2["default"].sum([data.positionMap.series.top, -MAP_CHART_ZOOM_AREA_HEIGHT, MAP_CHART_ZOOM_AREA_WIDTH]);
                  if (this.isMapLegendTop) {
                    positionTop = data.positionMap.legend.top - MAP_CHART_ZOOM_AREA_WIDTH;
                  }
                  var position = {
                    top: positionTop,
                    right: CHART_PADDING
                  };
                  container = _domHandler2["default"].create("DIV", this.className);
                  container.innerHTML += _seriesTemplate2["default"].ZOOM_BUTTONS;
                  _renderUtil2["default"].renderPosition(container, position);
                  this._attachEvent(container);
                }
                return container;
              };
              Zoom2.prototype._findBtnElement = function _findBtnElement(target) {
                var btnClassName = "tui-chart-zoom-btn";
                var btnElement = target;
                if (!_domHandler2["default"].hasClass(target, btnClassName)) {
                  btnElement = _domHandler2["default"].findParentByClass(target, btnClassName);
                }
                return btnElement;
              };
              Zoom2.prototype._zoom = function _zoom(magn, position) {
                this.eventBus.fire("zoomMap", magn, position);
              };
              Zoom2.prototype._onClick = function _onClick(e) {
                var target = e.target || e.srcElement;
                var btnElement = this._findBtnElement(target);
                var zoomDirection = btnElement.getAttribute("data-magn");
                var magn = this._calculateMagn(zoomDirection);
                if (magn > 5) {
                  this.magn = 5;
                } else if (magn < 1) {
                  this.magn = 1;
                } else if (magn >= 1) {
                  this._zoom(magn);
                }
                if (e.preventDefault) {
                  e.preventDefault();
                }
                return false;
              };
              Zoom2.prototype._attachEvent = function _attachEvent(target) {
                _eventListener2["default"].on(target, "click", this._onClick, this);
              };
              Zoom2.prototype._calculateMagn = function _calculateMagn(zoomDirection) {
                if (zoomDirection > 0) {
                  this.magn += 0.1;
                } else if (zoomDirection < 0) {
                  this.magn -= 0.1;
                }
                return this.magn;
              };
              Zoom2.prototype.onWheel = function onWheel(wheelDelta, position) {
                var magn = this._calculateMagn(wheelDelta);
                if (magn > 5) {
                  this.magn = 5;
                } else if (magn < 1) {
                  this.magn = 1;
                } else if (magn >= 1) {
                  this._zoom(magn, position);
                }
              };
              return Zoom2;
            }();
            function zoomFactory(params) {
              return new Zoom(params);
            }
            zoomFactory.componentType = "zoom";
          },
          /* 128 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _templateMaker = __webpack_require__(93);
            var _templateMaker2 = _interopRequireDefault(_templateMaker);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var htmls = {
              HTML_SERIES_LABEL: '<div class="tui-chart-series-label" style="{{ cssText }}"{{ rangeLabelAttribute }}>{{ label }}</div>',
              TEXT_CSS_TEXT: "left:{{ left }}px;top:{{ top }}px;font-family:{{ fontFamily }};font-size:{{ fontSize }}px;font-weight:{{ fontWeight }}{{opacity}}",
              TEXT_CSS_TEXT_FOR_LINE_TYPE: "left:{{ left }}%;top:{{ top }}%;font-family:{{ fontFamily }};font-size:{{ fontSize }}px;font-weight:{{ fontWeight }}{{opacity}}",
              HTML_ZOOM_BUTTONS: '<a class="tui-chart-zoom-btn zoom-in" href="#" data-magn="1"></a><a class="tui-chart-zoom-btn zoom-out" href="#" data-magn="-1"></a>',
              HTML_SERIES_BLOCK: '<div class="tui-chart-series-block" style="{{ cssText }}">{{ label }}</div>'
            };
            exports2["default"] = {
              tplSeriesLabel: _templateMaker2["default"].template(htmls.HTML_SERIES_LABEL),
              tplCssText: _templateMaker2["default"].template(htmls.TEXT_CSS_TEXT),
              tplCssTextForLineType: _templateMaker2["default"].template(htmls.TEXT_CSS_TEXT_FOR_LINE_TYPE),
              ZOOM_BUTTONS: htmls.HTML_ZOOM_BUTTONS,
              tplSeriesBlock: _templateMaker2["default"].template(htmls.HTML_SERIES_BLOCK)
            };
          },
          /* 129 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _isArray = __webpack_require__(9);
            var _isArray2 = _interopRequireDefault(_isArray);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _inArray = __webpack_require__(26);
            var _inArray2 = _interopRequireDefault(_inArray);
            var _encodeHTMLEntity = __webpack_require__(130);
            var _encodeHTMLEntity2 = _interopRequireDefault(_encodeHTMLEntity);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _dataProcessorBase = __webpack_require__(131);
            var _dataProcessorBase2 = _interopRequireDefault(_dataProcessorBase);
            var _seriesDataModel = __webpack_require__(132);
            var _seriesDataModel2 = _interopRequireDefault(_seriesDataModel);
            var _seriesDataModelForBoxplot = __webpack_require__(136);
            var _seriesDataModelForBoxplot2 = _interopRequireDefault(_seriesDataModelForBoxplot);
            var _seriesDataModelForBullet = __webpack_require__(138);
            var _seriesDataModelForBullet2 = _interopRequireDefault(_seriesDataModelForBullet);
            var _seriesDataModelForTreemap = __webpack_require__(139);
            var _seriesDataModelForTreemap2 = _interopRequireDefault(_seriesDataModelForTreemap);
            var _seriesGroup = __webpack_require__(133);
            var _seriesGroup2 = _interopRequireDefault(_seriesGroup);
            var _rawDataHandler = __webpack_require__(50);
            var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            var _objectUtil = __webpack_require__(55);
            var _objectUtil2 = _interopRequireDefault(_objectUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _toConsumableArray(arr) {
              if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              } else {
                return Array.from(arr);
              }
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var DataProcessor = function(_DataProcessorBase) {
              _inherits(DataProcessor2, _DataProcessorBase);
              function DataProcessor2(rawData, chartType, options, seriesTypes) {
                _classCallCheck(this, DataProcessor2);
                var _this = _possibleConstructorReturn(this, _DataProcessorBase.call(this));
                _this.originalRawData = _objectUtil2["default"].deepCopy(rawData);
                _this.chartType = chartType;
                _this.options = options;
                _this.seriesTypes = seriesTypes;
                _this.originalLegendData = null;
                _this.selectLegendIndex = null;
                _this.dynamicData = [];
                _this.defaultValues = [0, 500];
                _this.initData(rawData);
                _this.initZoomedRawData();
                _this.baseInit();
                if (_this.isLineCoordinateType()) {
                  _this.integratedXAxisData = _this._integrateXAxisData();
                }
                return _this;
              }
              DataProcessor2.prototype._integrateXAxisData = function _integrateXAxisData() {
                var seriesData = this.rawData.series.line;
                var options = this.options.xAxis || {};
                var integratedXAxisData = [];
                var isDateTime = false;
                if ((0, _isArray2["default"])(options)) {
                  isDateTime = options.filter(function(option) {
                    return option.type && _predicate2["default"].isDatetimeType(option.type);
                  });
                } else {
                  isDateTime = options.type && _predicate2["default"].isDatetimeType(options.type);
                }
                seriesData.forEach(function(seriesDatum) {
                  seriesDatum.data.forEach(function(data) {
                    if (!(0, _isNull2["default"])(data)) {
                      integratedXAxisData.push(data[0]);
                    }
                  });
                });
                integratedXAxisData = [].concat(_toConsumableArray(new Set(integratedXAxisData)));
                if (isDateTime) {
                  integratedXAxisData = integratedXAxisData.map(function(data) {
                    return new Date(data);
                  });
                }
                return integratedXAxisData.sort(function(a, b) {
                  return a - b;
                });
              };
              DataProcessor2.prototype.getOriginalRawData = function getOriginalRawData() {
                return _objectUtil2["default"].deepCopy(this.originalRawData);
              };
              DataProcessor2.prototype.getCurrentData = function getCurrentData() {
                var zoomedRawData = this.zoomedRawData;
                if (zoomedRawData) {
                  zoomedRawData = _objectUtil2["default"].deepCopy(zoomedRawData);
                } else {
                  zoomedRawData = this.getOriginalRawData();
                }
                return zoomedRawData;
              };
              DataProcessor2.prototype._filterSeriesDataByIndexRange = function _filterSeriesDataByIndexRange(seriesData, startIndex, endIndex) {
                var series = [].concat(_toConsumableArray(seriesData));
                series.forEach(function(seriesDatum) {
                  seriesDatum.data = seriesDatum.data.slice(startIndex, endIndex + 1);
                });
                return series;
              };
              DataProcessor2.prototype._filterRawDataByIndexRange = function _filterRawDataByIndexRange(rawData, indexRange) {
                var _this2 = this;
                var _indexRange = _slicedToArray(indexRange, 2), startIndex = _indexRange[0], endIndex = _indexRange[1];
                var data = Object.assign({}, rawData);
                Object.entries(data.series).forEach(function(_ref) {
                  var _ref2 = _slicedToArray(_ref, 2), seriesType = _ref2[0], seriesDataSet = _ref2[1];
                  data.series[seriesType] = _this2._filterSeriesDataByIndexRange(seriesDataSet, startIndex, endIndex);
                });
                if (data.categories) {
                  data.categories = data.categories.slice(startIndex, endIndex + 1);
                }
                return data;
              };
              DataProcessor2.prototype._filterSeriesDataByValue = function _filterSeriesDataByValue(seriesData, minValue, maxValue) {
                var isDatetime = _predicate2["default"].isDatetimeType(this.options.xAxis.type);
                var series = [].concat(_toConsumableArray(seriesData));
                series.forEach(function(seriesDatum) {
                  seriesDatum.data = seriesDatum.data.filter(function(data) {
                    var xAxisValue = isDatetime ? new Date(data[0]) : data[0];
                    return xAxisValue >= minValue && xAxisValue <= maxValue;
                  });
                });
                return series;
              };
              DataProcessor2.prototype._filterRawDataByValue = function _filterRawDataByValue(rawData, valueRange) {
                var _this3 = this;
                var _valueRange = _slicedToArray(valueRange, 2), minValue = _valueRange[0], maxValue = _valueRange[1];
                var data = Object.assign({}, rawData);
                Object.entries(data.series).forEach(function(_ref3) {
                  var _ref4 = _slicedToArray(_ref3, 2), seriesType = _ref4[0], seriesDataSet = _ref4[1];
                  data.series[seriesType] = _this3._filterSeriesDataByValue(seriesDataSet, minValue, maxValue);
                });
                return data;
              };
              DataProcessor2.prototype.updateRawDataForZoom = function updateRawDataForZoom(range) {
                var currentData = this.getCurrentData();
                var rawData = this.getRawData();
                var getZoomedRawData = this.isLineCoordinateType() ? this._filterRawDataByValue.bind(this) : this._filterRawDataByIndexRange.bind(this);
                this.zoomedRawData = getZoomedRawData(currentData, range);
                rawData = getZoomedRawData(rawData, range);
                this.initData(rawData);
              };
              DataProcessor2.prototype.initZoomedRawData = function initZoomedRawData() {
                this.zoomedRawData = null;
              };
              DataProcessor2.prototype.initData = function initData(rawData) {
                var originalChange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                this.rawData = rawData;
                if (originalChange) {
                  this.originalRawData = _objectUtil2["default"].deepCopy(rawData);
                  this.originalLegendData = null;
                }
                this.categoriesMap = null;
                this.categoriesIsDateTime = {};
                this.stacks = null;
                this.seriesDataModelMap = {};
                this.legendVisibilities = null;
                this.zoomedRawData = null;
                this.seriesGroups = null;
                this.valuesMap = {};
                this.legendLabels = null;
                this.legendData = null;
                this.multilineCategories = null;
                this.coordinateType = null;
                this.lineCoordinateType = null;
              };
              DataProcessor2.prototype.getRawData = function getRawData() {
                return this.rawData;
              };
              DataProcessor2.prototype.findChartType = function findChartType(seriesType) {
                return _rawDataHandler2["default"].findChartType(this.rawData.seriesAlias, seriesType);
              };
              DataProcessor2.prototype._escapeCategories = function _escapeCategories(categories) {
                return categories.map(function(category) {
                  return (0, _encodeHTMLEntity2["default"])(String(category));
                });
              };
              DataProcessor2.prototype._mapCategories = function _mapCategories(categories, axisName) {
                var _this4 = this;
                var axisType = axisName + "Axis";
                var options = this.options[axisType] || {};
                var isDateTime = false;
                if ((0, _isArray2["default"])(options)) {
                  isDateTime = options.filter(function(option) {
                    return option.type && _predicate2["default"].isDatetimeType(option.type);
                  });
                } else {
                  isDateTime = options.type && _predicate2["default"].isDatetimeType(options.type);
                }
                if (isDateTime) {
                  categories = categories.map(function(value) {
                    return _this4.chageDatetypeToTimestamp(value);
                  });
                } else {
                  categories = this._escapeCategories(categories);
                }
                this.categoriesIsDateTime[axisName] = isDateTime;
                return categories;
              };
              DataProcessor2.prototype._processCategories = function _processCategories(type) {
                var rawCategories = this.rawData.categories;
                var categoriesMap = {};
                if ((0, _isArray2["default"])(rawCategories)) {
                  categoriesMap[type] = this._mapCategories(rawCategories, type);
                } else if (rawCategories) {
                  if (rawCategories.x) {
                    categoriesMap.x = this._mapCategories(rawCategories.x, "x");
                  }
                  if (rawCategories.y) {
                    categoriesMap.y = this._mapCategories(rawCategories.y, "y").reverse();
                  }
                }
                return categoriesMap;
              };
              DataProcessor2.prototype.getCategories = function getCategories(isVertical) {
                var type = isVertical ? "y" : "x";
                var foundCategories = [];
                if (!this.categoriesMap) {
                  this.categoriesMap = this._processCategories(type);
                }
                if ((0, _isExisty2["default"])(isVertical)) {
                  foundCategories = this.categoriesMap[type] || [];
                } else {
                  Object.values(this.categoriesMap).every(function(categories) {
                    foundCategories = categories;
                    return false;
                  });
                }
                return foundCategories;
              };
              DataProcessor2.prototype.getCategorieDateType = function getCategorieDateType(isVertical) {
                var type = isVertical ? "y" : "x";
                return this.categoriesIsDateTime[type];
              };
              DataProcessor2.prototype.chageDatetypeToTimestamp = function chageDatetypeToTimestamp(dateTypeValue) {
                var date = new Date(dateTypeValue);
                if (!(date.getTime() > 0)) {
                  date = new Date(parseInt(dateTypeValue, 10));
                }
                return date.getTime() || dateTypeValue;
              };
              DataProcessor2.prototype.getCategoryCount = function getCategoryCount(isVertical) {
                var categories = this.getCategories(isVertical);
                return categories ? categories.length : 0;
              };
              DataProcessor2.prototype.hasCategories = function hasCategories(isVertical) {
                return !!this.getCategoryCount(isVertical);
              };
              DataProcessor2.prototype.isXCountGreaterThanYCount = function isXCountGreaterThanYCount(chartType) {
                var seriesDataModel = this.getSeriesDataModel(chartType);
                return seriesDataModel.isXCountGreaterThanYCount();
              };
              DataProcessor2.prototype.hasXValue = function hasXValue(chartType) {
                var hasVerticalCategory = this.isXCountGreaterThanYCount(chartType);
                return !this.hasCategories(hasVerticalCategory) || hasVerticalCategory;
              };
              DataProcessor2.prototype.hasYValue = function hasYValue(chartType) {
                var hasVerticalCategory = this.isXCountGreaterThanYCount(chartType);
                return !this.hasCategories(hasVerticalCategory) || !hasVerticalCategory;
              };
              DataProcessor2.prototype.getCategory = function getCategory(index, isVertical) {
                return this.getCategories(isVertical)[index];
              };
              DataProcessor2.prototype.findCategoryIndex = function findCategoryIndex(value) {
                var _this5 = this;
                var categories = this.getCategories();
                var isDateType = this.getCategorieDateType();
                var foundIndex = null;
                categories.forEach(function(category, index) {
                  if (isDateType) {
                    value = _this5.chageDatetypeToTimestamp(value);
                  }
                  if (category === value) {
                    foundIndex = index;
                  }
                  return (0, _isNull2["default"])(foundIndex);
                });
                return foundIndex;
              };
              DataProcessor2.prototype.findAbsoluteCategoryIndex = function findAbsoluteCategoryIndex(value) {
                var originalCategories = this.originalRawData ? this.originalRawData.categories : null;
                var index = -1;
                if (!originalCategories) {
                  return index;
                }
                originalCategories.forEach(function(category, categoryIndex) {
                  var found = category === value;
                  if (found) {
                    index = categoryIndex;
                  }
                  return !found;
                });
                return index;
              };
              DataProcessor2.prototype._getTooltipCategory = function _getTooltipCategory(categoryIndex, isVertical) {
                var category = this.getCategory(categoryIndex, isVertical);
                var axisType = isVertical ? "yAxis" : "xAxis";
                var axisOption = this.options[axisType] || {};
                var tooltipOption = this.options.tooltip || {};
                if (_predicate2["default"].isDatetimeType(tooltipOption.type)) {
                  category = _renderUtil2["default"].formatDate(category, tooltipOption.dateFormat);
                } else if (_predicate2["default"].isDatetimeType(axisOption.type)) {
                  category = _renderUtil2["default"].formatDate(category, axisOption.dateFormat);
                }
                return category;
              };
              DataProcessor2.prototype.makeTooltipCategory = function makeTooltipCategory(categoryIndex, oppositeIndex, isVerticalChart) {
                var isVertical = !isVerticalChart;
                var category = this._getTooltipCategory(categoryIndex, isVertical);
                var categoryCount = this.getCategoryCount(!isVertical);
                if (categoryCount) {
                  category += ", " + this._getTooltipCategory(categoryCount - oppositeIndex - 1, !isVertical);
                }
                return category;
              };
              DataProcessor2.prototype.getStacks = function getStacks(seriesType) {
                if (!this.stacks) {
                  this.stacks = _rawDataHandler2["default"].pickStacks(this.rawData.series[seriesType]);
                }
                return this.stacks;
              };
              DataProcessor2.prototype.getStackCount = function getStackCount(seriesType) {
                return this.getStacks(seriesType).length;
              };
              DataProcessor2.prototype.findStackIndex = function findStackIndex(stack) {
                return (0, _inArray2["default"])(stack, this.getStacks());
              };
              DataProcessor2.prototype.isLineCoordinateType = function isLineCoordinateType() {
                var lineCoordinateType = this.lineCoordinateType;
                if (!(0, _isExisty2["default"])(lineCoordinateType)) {
                  var chartType = this.chartType;
                  lineCoordinateType = _predicate2["default"].isLineTypeChart(chartType) && !this.hasCategories();
                  this.lineCoordinateType = lineCoordinateType;
                }
                return lineCoordinateType;
              };
              DataProcessor2.prototype.isCoordinateType = function isCoordinateType() {
                var coordinateType = this.coordinateType;
                if (!(0, _isExisty2["default"])(coordinateType)) {
                  var chartType = this.chartType;
                  coordinateType = _predicate2["default"].isCoordinateTypeChart(chartType);
                  coordinateType = coordinateType || _predicate2["default"].isLineScatterComboChart(chartType, this.seriesTypes);
                  coordinateType = coordinateType || _predicate2["default"].isLineTypeChart(chartType) && !this.hasCategories();
                  this.coordinateType = coordinateType;
                }
                return coordinateType;
              };
              DataProcessor2.prototype.getSeriesDataModel = function getSeriesDataModel(seriesType) {
                if (!this.seriesDataModelMap[seriesType]) {
                  var chartType = this.findChartType(seriesType);
                  var rawSeriesData = this.rawData.series[seriesType];
                  var SeriesDataModelClass = void 0;
                  if (_predicate2["default"].isBoxplotChart(this.chartType)) {
                    SeriesDataModelClass = _seriesDataModelForBoxplot2["default"];
                  } else if (_predicate2["default"].isTreemapChart(this.chartType)) {
                    SeriesDataModelClass = _seriesDataModelForTreemap2["default"];
                  } else if (_predicate2["default"].isBulletChart(this.chartType)) {
                    SeriesDataModelClass = _seriesDataModelForBullet2["default"];
                  } else {
                    SeriesDataModelClass = _seriesDataModel2["default"];
                  }
                  this.seriesDataModelMap[seriesType] = new SeriesDataModelClass(rawSeriesData, chartType, this.options, this.getFormatFunctions(), this.isCoordinateType());
                }
                return this.seriesDataModelMap[seriesType];
              };
              DataProcessor2.prototype.getOption = function getOption(optionType) {
                return this.options[optionType];
              };
              DataProcessor2.prototype.getGroupCount = function getGroupCount(chartType) {
                return this.getSeriesDataModel(chartType).getGroupCount();
              };
              DataProcessor2.prototype._pushCategory = function _pushCategory(category) {
                if (this.rawData.categories) {
                  this.rawData.categories.push(category);
                  this.originalRawData.categories.push(category);
                }
              };
              DataProcessor2.prototype._shiftCategory = function _shiftCategory() {
                if (this.rawData.categories) {
                  this.rawData.categories.shift();
                  this.originalRawData.categories.shift();
                }
              };
              DataProcessor2.prototype._findRawSeriesDatumByName = function _findRawSeriesDatumByName(name, seriesType) {
                var seriesData = this.rawData.series[seriesType];
                var foundSeriesDatum = null;
                seriesData.forEach(function(seriesDatum) {
                  var isEqual = seriesDatum.name === name;
                  if (isEqual) {
                    foundSeriesDatum = seriesDatum;
                  }
                  return !isEqual;
                });
                return foundSeriesDatum;
              };
              DataProcessor2.prototype._pushValue = function _pushValue(seriesDatum, value, seriesType) {
                var rawSeriesDatum = this._findRawSeriesDatumByName(seriesDatum.name, seriesType);
                seriesDatum.data.push(value);
                if (rawSeriesDatum) {
                  rawSeriesDatum.data.push(value);
                }
              };
              DataProcessor2.prototype._pushValues = function _pushValues(seriesData, values, seriesType) {
                var _this6 = this;
                seriesData.forEach(function(seriesDatum, index) {
                  _this6._pushValue(seriesDatum, values[index], seriesType);
                });
              };
              DataProcessor2.prototype._pushSeriesData = function _pushSeriesData(values) {
                var _this7 = this;
                if (this.chartType !== "combo" && (0, _isArray2["default"])(values)) {
                  var temp = values;
                  values = {};
                  values[this.chartType] = temp;
                }
                Object.entries(this.originalRawData.series).forEach(function(_ref5) {
                  var _ref6 = _slicedToArray(_ref5, 2), seriesType = _ref6[0], seriesData = _ref6[1];
                  _this7._pushValues(seriesData, values[seriesType], seriesType);
                });
              };
              DataProcessor2.prototype._shiftValues = function _shiftValues(seriesData, seriesType) {
                var _this8 = this;
                seriesData.forEach(function(seriesDatum) {
                  var rawSeriesDatum = _this8._findRawSeriesDatumByName(seriesDatum.name, seriesType);
                  seriesDatum.data.shift();
                  if (rawSeriesDatum) {
                    rawSeriesDatum.data.shift();
                  }
                });
              };
              DataProcessor2.prototype._shiftSeriesData = function _shiftSeriesData() {
                var _this9 = this;
                Object.entries(this.originalRawData.series).forEach(function(_ref7) {
                  var _ref8 = _slicedToArray(_ref7, 2), seriesType = _ref8[0], seriesData = _ref8[1];
                  _this9._shiftValues(seriesData, seriesType);
                });
              };
              DataProcessor2.prototype.addDynamicData = function addDynamicData(category, values) {
                this.dynamicData.push({
                  category,
                  values
                });
              };
              DataProcessor2.prototype._pushDynamicData = function _pushDynamicData(data) {
                this._pushCategory(data.category);
                this._pushSeriesData(data.values);
              };
              DataProcessor2.prototype._pushDynamicDataForCoordinateType = function _pushDynamicDataForCoordinateType(data) {
                var _this10 = this;
                Object.values(this.originalRawData.series).forEach(function(seriesDatum) {
                  _this10._pushValue(seriesDatum, data[seriesDatum.name]);
                });
              };
              DataProcessor2.prototype.addDataFromDynamicData = function addDataFromDynamicData() {
                var datum = this.dynamicData.shift();
                if (datum) {
                  if (this.isCoordinateType()) {
                    this._pushDynamicDataForCoordinateType(datum.values);
                  } else {
                    this._pushDynamicData(datum);
                  }
                  this.initData(this.rawData);
                }
                return !!datum;
              };
              DataProcessor2.prototype.shiftData = function shiftData() {
                this._shiftCategory();
                this._shiftSeriesData();
                this.initData(this.rawData);
              };
              DataProcessor2.prototype.addDataFromRemainDynamicData = function addDataFromRemainDynamicData(shiftingOption) {
                var _this11 = this;
                var dynamicData = this.dynamicData;
                this.dynamicData = [];
                dynamicData.forEach(function(datum) {
                  _this11._pushCategory(datum.category);
                  _this11._pushSeriesData(datum.values);
                  if (shiftingOption) {
                    _this11._shiftCategory();
                    _this11._shiftSeriesData();
                  }
                });
                this.initData(this.rawData);
              };
              DataProcessor2.prototype._eachByAllSeriesDataModel = function _eachByAllSeriesDataModel(iteratee) {
                var _this12 = this;
                var seriesTypes = this.seriesTypes || [this.chartType];
                seriesTypes.forEach(function(chartType) {
                  return iteratee(_this12.getSeriesDataModel(chartType), chartType);
                });
              };
              DataProcessor2.prototype.isValidAllSeriesDataModel = function isValidAllSeriesDataModel() {
                var isValid = true;
                this._eachByAllSeriesDataModel(function(seriesDataModel) {
                  isValid = !!seriesDataModel.getGroupCount();
                });
                return isValid;
              };
              DataProcessor2.prototype._makeSeriesGroups = function _makeSeriesGroups() {
                var joinedGroups = [];
                this._eachByAllSeriesDataModel(function(seriesDataModel) {
                  seriesDataModel.each(function(seriesGroup, index) {
                    if (!joinedGroups[index]) {
                      joinedGroups[index] = [];
                    }
                    joinedGroups[index] = joinedGroups[index].concat(seriesGroup.items);
                  });
                });
                var seriesGroups = joinedGroups.map(function(items) {
                  return new _seriesGroup2["default"](items);
                });
                return seriesGroups;
              };
              DataProcessor2.prototype.getSeriesGroups = function getSeriesGroups() {
                if (!this.seriesGroups) {
                  this.seriesGroups = this._makeSeriesGroups();
                }
                return this.seriesGroups;
              };
              DataProcessor2.prototype.getValue = function getValue(groupIndex, index, chartType) {
                return this.getSeriesDataModel(chartType).getValue(groupIndex, index);
              };
              DataProcessor2.prototype.getDefaultDatetimeValues = function getDefaultDatetimeValues() {
                var hour = 60 * 60 * 1e3;
                var now = Date.now();
                return [now - hour, now];
              };
              DataProcessor2.prototype.isSeriesDataEmpty = function isSeriesDataEmpty(chartType) {
                var rawData = this.rawData;
                var seriesNotExist = rawData && !rawData.series;
                return !rawData || seriesNotExist || !rawData.series[chartType] || rawData.series[chartType] && !rawData.series[chartType].length;
              };
              DataProcessor2.prototype.isLimitOptionsEmpty = function isLimitOptionsEmpty(axisType) {
                var axisOption = this.options[axisType] || {};
                return (0, _isUndefined2["default"])(axisOption.min) && (0, _isUndefined2["default"])(axisOption.max);
              };
              DataProcessor2.prototype.isLimitOptionsInsufficient = function isLimitOptionsInsufficient(axisType) {
                var axisOption = this.options[axisType] || {};
                return (0, _isUndefined2["default"])(axisOption.min) || (0, _isUndefined2["default"])(axisOption.max);
              };
              DataProcessor2.prototype._createValues = function _createValues(chartType, valueType, axisName) {
                var values = void 0;
                var options = this.options;
                var plotOptions = options.plot;
                var axisOption = options[axisName] || {};
                var type = axisOption.type;
                var isEmptyRawData = this.isSeriesDataEmpty(chartType);
                var isEmptyLimitOptions = this.isLimitOptionsEmpty(axisName);
                var isInsufficientLimitOptions = this.isLimitOptionsInsufficient(axisName);
                var isLineOrAreaChart = _predicate2["default"].isLineChart(chartType) || _predicate2["default"].isAreaChart(chartType) || _predicate2["default"].isLineAreaComboChart(chartType, this.seriesTypes);
                var valueCandidate = this.defaultValues;
                if (_predicate2["default"].isComboChart(chartType)) {
                  values = [];
                  this._eachByAllSeriesDataModel(function(seriesDataModel) {
                    values = values.concat(seriesDataModel.getValues(valueType));
                  });
                } else if (isEmptyRawData && isInsufficientLimitOptions) {
                  if (!isEmptyLimitOptions && isInsufficientLimitOptions) {
                    valueCandidate = valueCandidate.concat([axisOption.min || axisOption.max]);
                  }
                  if (valueType === "x" && type === "datetime") {
                    values = this.getDefaultDatetimeValues();
                    if (isLineOrAreaChart && plotOptions) {
                      var plotValues = this.getValuesFromPlotOptions(plotOptions, type);
                      values = values.concat(plotValues);
                    }
                  } else {
                    values = valueCandidate;
                  }
                } else {
                  values = this.getSeriesDataModel(chartType).getValues(valueType);
                }
                return values;
              };
              DataProcessor2.prototype.getValuesFromPlotOptions = function getValuesFromPlotOptions(plotOptions, axisType) {
                var values = [];
                if (plotOptions.lines) {
                  plotOptions.lines.forEach(function(line) {
                    values.push(axisType !== "datetime" ? line.value : new Date(line.value));
                  });
                }
                if (plotOptions.bands) {
                  plotOptions.bands.forEach(function(line) {
                    var ranges = line.range.map(function(range) {
                      return axisType !== "datetime" ? range : new Date(range);
                    });
                    values = values.concat(ranges);
                  });
                }
                return values;
              };
              DataProcessor2.prototype.getValues = function getValues(chartType, valueType, axisType) {
                var mapKey = chartType + valueType;
                if (!this.valuesMap[mapKey]) {
                  this.valuesMap[mapKey] = this._createValues(chartType, valueType, axisType);
                }
                return this.valuesMap[mapKey];
              };
              DataProcessor2.prototype.eachBySeriesGroup = function eachBySeriesGroup(iteratee, isPivot) {
                this._eachByAllSeriesDataModel(function(seriesDataModel, chartType) {
                  seriesDataModel.each(function(seriesGroup, groupIndex) {
                    iteratee(seriesGroup, groupIndex, chartType);
                  }, isPivot);
                });
              };
              DataProcessor2.prototype._pickLegendLabel = function _pickLegendLabel(item) {
                return !(0, _isNull2["default"])(item) && item.name ? (0, _encodeHTMLEntity2["default"])(item.name) : null;
              };
              DataProcessor2.prototype._isVisibleLegend = function _isVisibleLegend(item) {
                var visibility = true;
                if ((0, _isNull2["default"])(item) || (0, _isExisty2["default"])(item.visible) && item.visible === false) {
                  visibility = false;
                }
                return visibility;
              };
              DataProcessor2.prototype._pickLegendData = function _pickLegendData(dataType) {
                var seriesData = this.rawData.series;
                var result = {};
                var pickerMethod = void 0;
                if (dataType === "visibility") {
                  pickerMethod = this._isVisibleLegend;
                } else if (dataType === "label") {
                  pickerMethod = this._pickLegendLabel;
                }
                if (pickerMethod) {
                  Object.entries(seriesData).forEach(function(_ref9) {
                    var _ref10 = _slicedToArray(_ref9, 2), seriesType = _ref10[0], seriesDatum = _ref10[1];
                    var data = seriesDatum.map(pickerMethod);
                    if ((0, _isExisty2["default"])(data)) {
                      result[seriesType] = data;
                    }
                  });
                }
                return result;
              };
              DataProcessor2.prototype.getLegendLabels = function getLegendLabels(chartType) {
                if (!this.legendLabels) {
                  this.legendLabels = this._pickLegendData("label");
                }
                return this.legendLabels[chartType] || this.legendLabels;
              };
              DataProcessor2.prototype.getLegendVisibility = function getLegendVisibility(chartType) {
                if (!this.legendVisibilities) {
                  this.legendVisibilities = this._pickLegendData("visibility");
                }
                return this.legendVisibilities[chartType] || this.legendVisibilities;
              };
              DataProcessor2.prototype._makeLegendData = function _makeLegendData() {
                var _ref11;
                var legendLabels = this.getLegendLabels(this.chartType);
                var legendVisibilities = this.getLegendVisibility();
                var seriesTypes = this.seriesTypes || [this.chartType];
                var legendLabelsMap = void 0;
                if ((0, _isArray2["default"])(legendLabels)) {
                  legendLabelsMap = [this.chartType];
                  legendLabelsMap[this.chartType] = legendLabels;
                } else {
                  seriesTypes = this.seriesTypes;
                  legendLabelsMap = legendLabels;
                }
                var legendData = seriesTypes.map(function(chartType) {
                  return legendLabelsMap[chartType].map(function(label, index) {
                    var is2DArray = (0, _isArray2["default"])(legendVisibilities[chartType]);
                    return {
                      chartType,
                      label,
                      visible: is2DArray ? legendVisibilities[chartType][index] : legendVisibilities[index]
                    };
                  });
                });
                return (_ref11 = []).concat.apply(_ref11, _toConsumableArray(legendData));
              };
              DataProcessor2.prototype.getLegendData = function getLegendData() {
                if (!this.legendData) {
                  this.legendData = this._makeLegendData();
                }
                if (!this.originalLegendData) {
                  this.originalLegendData = this.legendData;
                }
                return this.legendData;
              };
              DataProcessor2.prototype.getOriginalLegendData = function getOriginalLegendData() {
                return this.originalLegendData;
              };
              DataProcessor2.prototype.getLegendItem = function getLegendItem(index) {
                return this.getLegendData()[index];
              };
              DataProcessor2.prototype.getFirstItemLabel = function getFirstItemLabel(chartType) {
                return this.getSeriesDataModel(chartType).getFirstItemLabel();
              };
              DataProcessor2.prototype.addDataRatiosOfPieChart = function addDataRatiosOfPieChart(chartType) {
                this.getSeriesDataModel(chartType).addDataRatiosOfPieChart();
              };
              DataProcessor2.prototype.addDataRatiosForCoordinateType = function addDataRatiosForCoordinateType(chartType, limitMap, hasRadius) {
                if (_predicate2["default"].isLineTypeChart(chartType)) {
                  this._addStartValueToAllSeriesItem(limitMap.yAxis, chartType);
                }
                this.getSeriesDataModel(chartType).addDataRatiosForCoordinateType(limitMap, hasRadius);
              };
              DataProcessor2.prototype._addStartValueToAllSeriesItem = function _addStartValueToAllSeriesItem(limit, chartType) {
                var start = 0;
                if (limit.min >= 0) {
                  start = limit.min;
                } else if (limit.max <= 0) {
                  start = limit.max;
                }
                this.getSeriesDataModel(chartType).addStartValueToAllSeriesItem(start);
              };
              DataProcessor2.prototype.addDataRatios = function addDataRatios(limit, stack, chartType) {
                var seriesDataModel = this.getSeriesDataModel(chartType);
                this._addStartValueToAllSeriesItem(limit, chartType);
                seriesDataModel.addDataRatios(limit, stack);
              };
              DataProcessor2.prototype.addDataRatiosForTreemapChart = function addDataRatiosForTreemapChart(limit, chartType) {
                this.getSeriesDataModel(chartType).addDataRatios(limit);
              };
              DataProcessor2.prototype._createBaseValuesForNormalStackedChart = function _createBaseValuesForNormalStackedChart(chartType) {
                var seriesDataModel = this.getSeriesDataModel(chartType);
                var baseValues = [];
                seriesDataModel.each(function(seriesGroup) {
                  var valuesMap = seriesGroup._makeValuesMapPerStack();
                  Object.values(valuesMap).forEach(function(values) {
                    var plusSum = _calculator2["default"].sumPlusValues(values);
                    var minusSum = _calculator2["default"].sumMinusValues(values);
                    baseValues = baseValues.concat([plusSum, minusSum]);
                  });
                });
                return baseValues;
              };
              DataProcessor2.prototype.createBaseValuesForLimit = function createBaseValuesForLimit(chartType, isSingleYAxis, stack, valueType, axisType) {
                var baseValues = void 0;
                if (_predicate2["default"].isComboChart(this.chartType) && isSingleYAxis) {
                  baseValues = this.getValues(this.chartType, valueType);
                  if (_predicate2["default"].isNormalStackChart(chartType, stack)) {
                    baseValues = baseValues.concat(this._createBaseValuesForNormalStackedChart(chartType));
                  }
                } else if (_predicate2["default"].isTreemapChart(chartType)) {
                  baseValues = this.getValues(chartType, "colorValue");
                } else if (_predicate2["default"].isNormalStackChart(chartType, stack)) {
                  baseValues = this._createBaseValuesForNormalStackedChart(chartType);
                } else {
                  baseValues = this.getValues(chartType, valueType, axisType);
                }
                return baseValues;
              };
              DataProcessor2.prototype.findOverflowItem = function findOverflowItem(chartType, valueType) {
                var seriesDataModel = this.getSeriesDataModel(chartType);
                var maxRadiusValue = seriesDataModel.getMaxValue("r");
                var isBiggerRatioThanHalfRatio = function isBiggerRatioThanHalfRatio2(seriesItem) {
                  return seriesItem.r / maxRadiusValue > _const2["default"].HALF_RATIO;
                };
                return {
                  minItem: seriesDataModel.findMinSeriesItem(valueType, isBiggerRatioThanHalfRatio),
                  maxItem: seriesDataModel.findMaxSeriesItem(valueType, isBiggerRatioThanHalfRatio)
                };
              };
              DataProcessor2.prototype.setGraphColors = function setGraphColors(colors) {
                this.graphColors = colors;
              };
              DataProcessor2.prototype.getGraphColors = function getGraphColors() {
                return this.graphColors;
              };
              DataProcessor2.prototype.isComboDonutShowOuterLabel = function isComboDonutShowOuterLabel() {
                var seriesOptions = this.options.series;
                return seriesOptions && seriesOptions.pie2 && seriesOptions.pie2.labelAlign === "outer";
              };
              return DataProcessor2;
            }(_dataProcessorBase2["default"]);
            exports2["default"] = DataProcessor;
          },
          /* 130 */
          /***/
          function(module2, exports2) {
            "use strict";
            function encodeHTMLEntity(html) {
              var entities = {
                '"': "quot",
                "&": "amp",
                "<": "lt",
                ">": "gt",
                "'": "#39"
              };
              return html.replace(/[<>&"']/g, function(m0) {
                return entities[m0] ? "&" + entities[m0] + ";" : m0;
              });
            }
            module2.exports = encodeHTMLEntity;
          },
          /* 131 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isFunction = __webpack_require__(56);
            var _isFunction2 = _interopRequireDefault(_isFunction);
            var _isString = __webpack_require__(25);
            var _isString2 = _interopRequireDefault(_isString);
            var _pick = __webpack_require__(21);
            var _pick2 = _interopRequireDefault(_pick);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var DataProcessorBase = function() {
              function DataProcessorBase2() {
                _classCallCheck(this, DataProcessorBase2);
              }
              DataProcessorBase2.prototype.baseInit = function baseInit() {
                this.formatFunctions = null;
              };
              DataProcessorBase2.prototype.getValues = function getValues() {
              };
              DataProcessorBase2.prototype.getCurrentData = function getCurrentData() {
              };
              DataProcessorBase2.prototype.getMaxValue = function getMaxValue(chartType, valueType) {
                return _arrayUtil2["default"].max(this.getValues(chartType, valueType));
              };
              DataProcessorBase2.prototype.getMinValue = function getMinValue(chartType, valueType) {
                return _arrayUtil2["default"].min(this.getValues(chartType, valueType));
              };
              DataProcessorBase2.prototype.getFormattedMaxValue = function getFormattedMaxValue(chartType, areaType, valueType) {
                var maxValue = this.getMaxValue(chartType, valueType);
                var formatFunctions = this.getFormatFunctions();
                return _renderUtil2["default"].formatValue({
                  value: maxValue,
                  formatFunctions,
                  chartType,
                  areaType,
                  valueType
                });
              };
              DataProcessorBase2.prototype.getFormattedMinValue = function getFormattedMinValue(chartType, areaType, valueType) {
                var maxValue = this.getMinValue(chartType, valueType);
                var formatFunctions = this.getFormatFunctions();
                return _renderUtil2["default"].formatValue({
                  value: maxValue,
                  formatFunctions,
                  chartType,
                  areaType,
                  valueType
                });
              };
              DataProcessorBase2.prototype._pickMaxLenUnderPoint = function _pickMaxLenUnderPoint(values) {
                var max = 0;
                values.forEach(function(value) {
                  var len = _calculator2["default"].getDecimalLength(value);
                  if (len > max) {
                    max = len;
                  }
                });
                return max;
              };
              DataProcessorBase2.prototype._isZeroFill = function _isZeroFill(format) {
                return format.length > 2 && format.charAt(0) === "0";
              };
              DataProcessorBase2.prototype._isDecimal = function _isDecimal(format) {
                var indexOf = format.indexOf(".");
                return indexOf > -1 && indexOf < format.length - 1;
              };
              DataProcessorBase2.prototype._isComma = function _isComma(format) {
                return format.indexOf(",") > -1;
              };
              DataProcessorBase2.prototype._formatToZeroFill = function _formatToZeroFill(len, value) {
                var isMinus = value < 0;
                value = _renderUtil2["default"].formatToZeroFill(Math.abs(value), len);
                return (isMinus ? "-" : "") + value;
              };
              DataProcessorBase2.prototype._formatToDecimal = function _formatToDecimal(len, value) {
                return _renderUtil2["default"].formatToDecimal(value, len);
              };
              DataProcessorBase2.prototype._findSimpleTypeFormatFunctions = function _findSimpleTypeFormatFunctions(format) {
                var funcs = [];
                var len = void 0;
                if (this._isDecimal(format)) {
                  len = this._pickMaxLenUnderPoint([format]);
                  funcs = [this._formatToDecimal.bind(this, len)];
                } else if (this._isZeroFill(format)) {
                  len = format.length;
                  funcs = [this._formatToZeroFill.bind(this, len)];
                  return funcs;
                }
                if (this._isComma(format)) {
                  funcs.push(_renderUtil2["default"].formatToComma);
                }
                return funcs;
              };
              DataProcessorBase2.prototype._findFormatFunctions = function _findFormatFunctions() {
                var format = (0, _pick2["default"])(this.options, "chart", "format");
                var funcs = [];
                if ((0, _isFunction2["default"])(format)) {
                  funcs = [format];
                } else if ((0, _isString2["default"])(format)) {
                  funcs = this._findSimpleTypeFormatFunctions(format);
                }
                return funcs;
              };
              DataProcessorBase2.prototype.getFormatFunctions = function getFormatFunctions() {
                if (!this.formatFunctions) {
                  this.formatFunctions = this._findFormatFunctions();
                }
                return this.formatFunctions;
              };
              return DataProcessorBase2;
            }();
            exports2["default"] = DataProcessorBase;
          },
          /* 132 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _isArray = __webpack_require__(9);
            var _isArray2 = _interopRequireDefault(_isArray);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _pick = __webpack_require__(21);
            var _pick2 = _interopRequireDefault(_pick);
            var _seriesGroup = __webpack_require__(133);
            var _seriesGroup2 = _interopRequireDefault(_seriesGroup);
            var _seriesItem = __webpack_require__(134);
            var _seriesItem2 = _interopRequireDefault(_seriesItem);
            var _seriesItemForCoordinateType = __webpack_require__(135);
            var _seriesItemForCoordinateType2 = _interopRequireDefault(_seriesItemForCoordinateType);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _toConsumableArray(arr) {
              if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              } else {
                return Array.from(arr);
              }
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var concat = Array.prototype.concat;
            var SeriesDataModel = function() {
              function SeriesDataModel2(rawSeriesData, chartType, options, formatFunctions, isCoordinateType) {
                _classCallCheck(this, SeriesDataModel2);
                this.chartType = chartType;
                this.options = options || {};
                this.formatFunctions = formatFunctions;
                this.rawSeriesData = rawSeriesData || [];
                this.isCoordinateType = isCoordinateType;
                this.baseGroups = null;
                this.groups = null;
                this.options.series = this.options.series || {};
                this.isDivergingChart = _predicate2["default"].isDivergingChart(chartType, this.options.series.diverging);
                this.valuesMap = {};
                this._removeRangeValue();
              }
              SeriesDataModel2.prototype._removeRangeValue = function _removeRangeValue() {
                var seriesOption = (0, _pick2["default"])(this.options, "series") || {};
                var allowRange = _predicate2["default"].isAllowRangeData(this.chartType) && !_predicate2["default"].isValidStackOption(seriesOption.stack) && !seriesOption.spline;
                if (allowRange || this.isCoordinateType) {
                  return;
                }
                Object.values(this.rawSeriesData).forEach(function(rawItem) {
                  if (!(0, _isArray2["default"])(rawItem.data)) {
                    return;
                  }
                  rawItem.data.forEach(function(value, index) {
                    if ((0, _isExisty2["default"])(value)) {
                      var _concat$apply = concat.apply(value);
                      var _concat$apply2 = _slicedToArray(_concat$apply, 1);
                      rawItem.data[index] = _concat$apply2[0];
                    }
                  });
                });
              };
              SeriesDataModel2.prototype._createBaseGroups = function _createBaseGroups() {
                var chartType = this.chartType, formatFunctions = this.formatFunctions, isDivergingChart = this.isDivergingChart, isCoordinateType = this.isCoordinateType;
                var xAxisOption = this.options.xAxis;
                var isPieChart = _predicate2["default"].isPieChart(this.chartType);
                var hasRawDatumAsArray = _predicate2["default"].isHeatmapChart(this.chartType) || _predicate2["default"].isTreemapChart(this.chartType);
                var sortValues = void 0, SeriesItemClass = void 0;
                if (isCoordinateType) {
                  SeriesItemClass = _seriesItemForCoordinateType2["default"];
                  sortValues = function sortValues2(items) {
                    items.sort(function(a, b) {
                      return a.x - b.x;
                    });
                  };
                } else {
                  SeriesItemClass = _seriesItem2["default"];
                  sortValues = function sortValues2() {
                  };
                }
                return this.rawSeriesData.map(function(rawDatum) {
                  var stack = void 0, data = void 0, legendName = void 0;
                  data = (0, _isArray2["default"])(rawDatum) ? rawDatum : [].concat(rawDatum.data);
                  if (!hasRawDatumAsArray) {
                    stack = rawDatum.stack;
                  }
                  if (rawDatum.name) {
                    legendName = rawDatum.name;
                  }
                  if (isCoordinateType || isPieChart) {
                    data = data.filter(_isExisty2["default"]);
                  }
                  var items = data.map(function(datum, index) {
                    return new SeriesItemClass({
                      datum,
                      chartType,
                      formatFunctions,
                      index,
                      legendName,
                      stack,
                      isDivergingChart,
                      xAxisType: xAxisOption.type,
                      dateFormat: xAxisOption.dateFormat
                    });
                  });
                  sortValues(items);
                  return items;
                });
              };
              SeriesDataModel2.prototype._getBaseGroups = function _getBaseGroups() {
                if (!this.baseGroups) {
                  this.baseGroups = this._createBaseGroups();
                }
                return this.baseGroups;
              };
              SeriesDataModel2.prototype._createSeriesGroupsFromRawData = function _createSeriesGroupsFromRawData(isPivot) {
                var baseGroups = this._getBaseGroups();
                if (isPivot) {
                  baseGroups = _arrayUtil2["default"].pivot(baseGroups);
                }
                return baseGroups.map(function(items) {
                  return new _seriesGroup2["default"](items);
                });
              };
              SeriesDataModel2.prototype._getSeriesGroups = function _getSeriesGroups() {
                if (!this.groups) {
                  this.groups = this._createSeriesGroupsFromRawData(true);
                }
                return this.groups;
              };
              SeriesDataModel2.prototype.getGroupCount = function getGroupCount() {
                return this._getSeriesGroups().length;
              };
              SeriesDataModel2.prototype._getPivotGroups = function _getPivotGroups() {
                if (!this.pivotGroups) {
                  this.pivotGroups = this._createSeriesGroupsFromRawData();
                }
                return this.pivotGroups;
              };
              SeriesDataModel2.prototype.getSeriesGroup = function getSeriesGroup(index, isPivot) {
                return isPivot ? this._getPivotGroups()[index] : this._getSeriesGroups()[index];
              };
              SeriesDataModel2.prototype.getFirstSeriesGroup = function getFirstSeriesGroup(isPivot) {
                return this.getSeriesGroup(0, isPivot);
              };
              SeriesDataModel2.prototype.getFirstItemLabel = function getFirstItemLabel() {
                return this.getFirstSeriesGroup().getFirstSeriesItem().label;
              };
              SeriesDataModel2.prototype.getSeriesItem = function getSeriesItem(groupIndex, index, isPivot) {
                return this.getSeriesGroup(groupIndex, isPivot).getSeriesItem(index);
              };
              SeriesDataModel2.prototype.getFirstSeriesItem = function getFirstSeriesItem() {
                return this.getSeriesItem(0, 0);
              };
              SeriesDataModel2.prototype.getValue = function getValue(groupIndex, index) {
                return this.getSeriesItem(groupIndex, index).value;
              };
              SeriesDataModel2.prototype.getMinValue = function getMinValue(valueType) {
                return _arrayUtil2["default"].min(this.getValues(valueType));
              };
              SeriesDataModel2.prototype.getMaxValue = function getMaxValue(valueType) {
                return _arrayUtil2["default"].max(this.getValues(valueType));
              };
              SeriesDataModel2.prototype._findSeriesItem = function _findSeriesItem(condition) {
                var foundItem = void 0;
                this.each(function(seriesGroup) {
                  foundItem = seriesGroup.find(condition);
                  return !foundItem;
                });
                return foundItem;
              };
              SeriesDataModel2.prototype._findSeriesItemByValue = function _findSeriesItemByValue(valueType, value, condition) {
                condition = condition || function() {
                  return null;
                };
                return this._findSeriesItem(function(seriesItem) {
                  return seriesItem && seriesItem[valueType] === value && condition(seriesItem);
                });
              };
              SeriesDataModel2.prototype.findMinSeriesItem = function findMinSeriesItem(valueType, condition) {
                var minValue = this.getMinValue(valueType);
                return this._findSeriesItemByValue(valueType, minValue, condition);
              };
              SeriesDataModel2.prototype.findMaxSeriesItem = function findMaxSeriesItem(valueType, condition) {
                var maxValue = this.getMaxValue(valueType);
                return this._findSeriesItemByValue(valueType, maxValue, condition);
              };
              SeriesDataModel2.prototype._createValues = function _createValues(valueType) {
                var _ref;
                var values = this.map(function(seriesGroup) {
                  return seriesGroup.getValues(valueType);
                });
                values = (_ref = []).concat.apply(_ref, _toConsumableArray(values));
                return values.filter(function(value) {
                  return !isNaN(value);
                });
              };
              SeriesDataModel2.prototype.getValues = function getValues() {
                var valueType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "value";
                if (!this.valuesMap[valueType]) {
                  this.valuesMap[valueType] = this._createValues(valueType);
                }
                return this.valuesMap[valueType];
              };
              SeriesDataModel2.prototype.isXCountGreaterThanYCount = function isXCountGreaterThanYCount() {
                return this.getValues("x").length > this.getValues("y").length;
              };
              SeriesDataModel2.prototype._addRatiosWhenNormalStacked = function _addRatiosWhenNormalStacked(limit) {
                var distance = Math.abs(limit.max - limit.min);
                this.each(function(seriesGroup) {
                  seriesGroup.addRatios(distance);
                });
              };
              SeriesDataModel2.prototype._calculateBaseRatio = function _calculateBaseRatio() {
                var values = this.getValues();
                var plusSum = _calculator2["default"].sumPlusValues(values);
                var minusSum = Math.abs(_calculator2["default"].sumMinusValues(values));
                var ratio = plusSum > 0 && minusSum > 0 ? 0.5 : 1;
                return ratio;
              };
              SeriesDataModel2.prototype._addRatiosWhenPercentStacked = function _addRatiosWhenPercentStacked() {
                var baseRatio = this._calculateBaseRatio();
                this.each(function(seriesGroup) {
                  seriesGroup.addRatiosWhenPercentStacked(baseRatio);
                });
              };
              SeriesDataModel2.prototype._addRatiosWhenDivergingStacked = function _addRatiosWhenDivergingStacked() {
                this.each(function(seriesGroup) {
                  var values = seriesGroup.pluck("value");
                  var plusSum = _calculator2["default"].sumPlusValues(values);
                  var minusSum = Math.abs(_calculator2["default"].sumMinusValues(values));
                  seriesGroup.addRatiosWhenDivergingStacked(plusSum, minusSum);
                });
              };
              SeriesDataModel2.prototype._makeSubtractionValue = function _makeSubtractionValue(limit) {
                var allowMinusPointRender = _predicate2["default"].allowMinusPointRender(this.chartType);
                var subValue = 0;
                if (!allowMinusPointRender && _predicate2["default"].isMinusLimit(limit)) {
                  subValue = limit.max;
                } else if (allowMinusPointRender || limit.min >= 0) {
                  subValue = limit.min;
                }
                return subValue;
              };
              SeriesDataModel2.prototype._addRatios = function _addRatios(limit) {
                var distance = Math.abs(limit.max - limit.min);
                var subValue = this._makeSubtractionValue(limit);
                this.each(function(seriesGroup) {
                  seriesGroup.addRatios(distance, subValue);
                });
              };
              SeriesDataModel2.prototype.addDataRatios = function addDataRatios(limit, stack) {
                var isAllowedStackOption = _predicate2["default"].isAllowedStackOption(this.chartType);
                if (isAllowedStackOption && _predicate2["default"].isNormalStack(stack)) {
                  this._addRatiosWhenNormalStacked(limit);
                } else if (isAllowedStackOption && _predicate2["default"].isPercentStack(stack)) {
                  if (this.isDivergingChart) {
                    this._addRatiosWhenDivergingStacked();
                  } else {
                    this._addRatiosWhenPercentStacked();
                  }
                } else {
                  this._addRatios(limit);
                }
              };
              SeriesDataModel2.prototype.addDataRatiosOfPieChart = function addDataRatiosOfPieChart() {
                this.each(function(seriesGroup) {
                  var sum = _calculator2["default"].sum(seriesGroup.pluck("value"));
                  seriesGroup.addRatios(sum);
                });
              };
              SeriesDataModel2.prototype.addDataRatiosForCoordinateType = function addDataRatiosForCoordinateType(limitMap, hasRadius) {
                var xLimit = limitMap.xAxis;
                var yLimit = limitMap.yAxis;
                var maxRadius = hasRadius ? _arrayUtil2["default"].max(this.getValues("r")) : 0;
                var xDistance = void 0, xSubValue = void 0, yDistance = void 0, ySubValue = void 0;
                if (xLimit) {
                  xDistance = Math.abs(xLimit.max - xLimit.min);
                  xSubValue = this._makeSubtractionValue(xLimit);
                }
                if (yLimit) {
                  yDistance = Math.abs(yLimit.max - yLimit.min);
                  ySubValue = this._makeSubtractionValue(yLimit);
                }
                this.each(function(seriesGroup) {
                  seriesGroup.each(function(item) {
                    if (!item) {
                      return;
                    }
                    item.addRatio("x", xDistance, xSubValue);
                    item.addRatio("y", yDistance, ySubValue);
                    item.addRatio("r", maxRadius, 0);
                    if ((0, _isExisty2["default"])(item.start)) {
                      item.addRatio("start", yDistance, ySubValue);
                    }
                  });
                });
              };
              SeriesDataModel2.prototype.addStartValueToAllSeriesItem = function addStartValueToAllSeriesItem(start) {
                this.each(function(seriesGroup) {
                  seriesGroup.addStartValueToAllSeriesItem(start);
                });
              };
              SeriesDataModel2.prototype.hasRangeData = function hasRangeData() {
                var hasRangeData2 = false;
                this.each(function(seriesGroup) {
                  hasRangeData2 = seriesGroup.hasRangeData();
                  return !hasRangeData2;
                });
                return hasRangeData2;
              };
              SeriesDataModel2.prototype.each = function each(iteratee, isPivot) {
                var groups = isPivot ? this._getPivotGroups() : this._getSeriesGroups();
                groups.forEach(function(seriesGroup, index) {
                  return iteratee(seriesGroup, index);
                });
              };
              SeriesDataModel2.prototype.map = function map(iteratee, isPivot) {
                var results = [];
                this.each(function(seriesGroup, index) {
                  results.push(iteratee(seriesGroup, index));
                }, isPivot);
                return results;
              };
              return SeriesDataModel2;
            }();
            exports2["default"] = SeriesDataModel;
          },
          /* 133 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _pluck = __webpack_require__(58);
            var _pluck2 = _interopRequireDefault(_pluck);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var SeriesGroup = function() {
              function SeriesGroup2(seriesItems) {
                _classCallCheck(this, SeriesGroup2);
                this.items = seriesItems;
                this.valuesMap = {};
                this.valuesMapPerStack = null;
              }
              SeriesGroup2.prototype.getSeriesItemCount = function getSeriesItemCount() {
                return this.items.length;
              };
              SeriesGroup2.prototype.getSeriesItem = function getSeriesItem(index) {
                return this.items[index];
              };
              SeriesGroup2.prototype.getFirstSeriesItem = function getFirstSeriesItem() {
                return this.getSeriesItem(0);
              };
              SeriesGroup2.prototype._createValues = function _createValues(valueType) {
                var values = [];
                this.each(function(item) {
                  if (!item) {
                    return;
                  }
                  if ((0, _isExisty2["default"])(item[valueType])) {
                    values.push(item[valueType]);
                  }
                  if ((0, _isExisty2["default"])(item.start)) {
                    values.push(item.start);
                  }
                });
                return values;
              };
              SeriesGroup2.prototype.getValues = function getValues(valueType) {
                valueType = valueType || "value";
                if (!this.valuesMap[valueType]) {
                  this.valuesMap[valueType] = this._createValues(valueType);
                }
                return this.valuesMap[valueType];
              };
              SeriesGroup2.prototype._makeValuesMapPerStack = function _makeValuesMapPerStack() {
                var valuesMap = {};
                this.each(function(item) {
                  if (!valuesMap[item.stack]) {
                    valuesMap[item.stack] = [];
                  }
                  valuesMap[item.stack].push(item.value);
                });
                return valuesMap;
              };
              SeriesGroup2.prototype.getValuesMapPerStack = function getValuesMapPerStack() {
                if (!this.valuesMapPerStack) {
                  this.valuesMapPerStack = this._makeValuesMapPerStack();
                }
                return this.valuesMapPerStack;
              };
              SeriesGroup2.prototype._makeSumMapPerStack = function _makeSumMapPerStack() {
                var valuesMap = this.getValuesMapPerStack();
                var sumMap = {};
                Object.entries(valuesMap).forEach(function(_ref) {
                  var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], values = _ref2[1];
                  sumMap[key] = _calculator2["default"].sum(values.map(function(value) {
                    return Math.abs(value);
                  }));
                });
                return sumMap;
              };
              SeriesGroup2.prototype.addStartValueToAllSeriesItem = function addStartValueToAllSeriesItem(start) {
                this.each(function(item) {
                  if (!item) {
                    return;
                  }
                  item.addStart(start);
                });
              };
              SeriesGroup2.prototype.addRatiosWhenPercentStacked = function addRatiosWhenPercentStacked(baseRatio) {
                var sumMap = this._makeSumMapPerStack();
                this.each(function(item) {
                  var dividingNumber = sumMap[item.stack];
                  item.addRatio(dividingNumber, 0, baseRatio);
                });
              };
              SeriesGroup2.prototype.addRatiosWhenDivergingStacked = function addRatiosWhenDivergingStacked(plusSum, minusSum) {
                this.each(function(item) {
                  var dividingNumber = item.value >= 0 ? plusSum : minusSum;
                  item.addRatio(dividingNumber, 0, 0.5);
                });
              };
              SeriesGroup2.prototype.addRatios = function addRatios(divNumber, subValue) {
                this.each(function(item) {
                  if (!item) {
                    return;
                  }
                  item.addRatio(divNumber, subValue);
                });
              };
              SeriesGroup2.prototype.hasRangeData = function hasRangeData() {
                var hasRangeData2 = false;
                this.each(function(seriesItem) {
                  hasRangeData2 = seriesItem && seriesItem.isRange;
                  return !hasRangeData2;
                });
                return hasRangeData2;
              };
              SeriesGroup2.prototype.each = function each(iteratee) {
                this.items.forEach(iteratee);
              };
              SeriesGroup2.prototype.map = function map(iteratee) {
                return this.items.map(iteratee);
              };
              SeriesGroup2.prototype.pluck = function pluck(key) {
                var items = this.items.filter(_isExisty2["default"]);
                return (0, _pluck2["default"])(items, key);
              };
              SeriesGroup2.prototype.find = function find(condition) {
                var foundItem = void 0;
                this.each(function(seriesItem) {
                  if (condition(seriesItem)) {
                    foundItem = seriesItem;
                  }
                  return !foundItem;
                });
                return foundItem || null;
              };
              SeriesGroup2.prototype.filter = function filter(condition) {
                return this.items.filter(condition);
              };
              return SeriesGroup2;
            }();
            exports2["default"] = SeriesGroup;
          },
          /* 134 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var SeriesItem = function() {
              function SeriesItem2(params) {
                _classCallCheck(this, SeriesItem2);
                this.chartType = params.chartType;
                this.stack = params.stack || _const2["default"].DEFAULT_STACK;
                this.isDivergingChart = params.isDivergingChart;
                this.formatFunctions = params.formatFunctions;
                this.isRange = false;
                this.value = null;
                this.label = null;
                this.tooltipLabel = null;
                this.ratio = null;
                this.end = null;
                this.endLabel = null;
                this.endRatio = null;
                this.start = null;
                this.startLabel = null;
                this.startRatio = null;
                this.ratioDistance = null;
                if (_predicate2["default"].isBulletChart(this.chartType)) {
                  this.type = params.type;
                }
                this.legendName = params.legendName;
                this._initValues(params.datum, params.index);
              }
              SeriesItem2.prototype._initValues = function _initValues(rawValue, index) {
                var _this = this;
                var values = this._createValues(rawValue);
                var hasStart = values.length > 1;
                var _values = _slicedToArray(values, 1), value = _values[0];
                this.value = this.end = value;
                this.index = index;
                if (this.isDivergingChart) {
                  value = Math.abs(value);
                }
                if ((0, _isNull2["default"])(value)) {
                  this._setLabel("");
                } else {
                  ["label", "tooltipLabel"].forEach(function(labelType) {
                    _this[labelType] = _renderUtil2["default"].formatValue({
                      value,
                      formatFunctions: _this.formatFunctions,
                      chartType: _this.chartType,
                      areaType: labelType === "tooltipLabel" ? "makingTooltipLabel" : "makingSeriesLabel",
                      legendName: _this.legendName
                    });
                  });
                }
                this.endLabel = this.label;
                if (hasStart) {
                  this.addStart(values[1], true);
                  this._updateFormattedValueforRange();
                  this.isRange = true;
                }
              };
              SeriesItem2.prototype._setLabel = function _setLabel(value) {
                this.label = value;
                this.tooltipLabel = value;
              };
              SeriesItem2.prototype._createValues = function _createValues(value) {
                var values = [].concat(value).map(function(newValue) {
                  return (0, _isNull2["default"])(newValue) ? null : parseFloat(newValue);
                });
                values = values.sort(function(a, b) {
                  if (a < 0 && b < 0) {
                    return a - b;
                  }
                  return b - a;
                });
                return values;
              };
              SeriesItem2.prototype.addStart = function addStart(value) {
                if (!(0, _isNull2["default"])(this.start)) {
                  return;
                }
                this.start = value;
                this.startLabel = _renderUtil2["default"].formatValue({
                  value,
                  formatFunctions: this.formatFunctions,
                  chartType: this.chartType,
                  areaType: "series",
                  legendName: this.legendName
                });
              };
              SeriesItem2.prototype._updateFormattedValueforRange = function _updateFormattedValueforRange() {
                this._setLabel(this.startLabel + " ~ " + this.endLabel);
              };
              SeriesItem2.prototype.addRatio = function addRatio() {
                var divNumber = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
                var subNumber = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                var baseRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
                this.ratio = this.endRatio = _calculator2["default"].calculateRatio(this.value, divNumber, subNumber, baseRatio);
                if ((0, _isExisty2["default"])(this.start)) {
                  this.startRatio = _calculator2["default"].calculateRatio(this.start, divNumber, subNumber, baseRatio);
                  this.ratioDistance = Math.abs(this.endRatio - this.startRatio);
                }
              };
              SeriesItem2.prototype._getFormattedValueForTooltip = function _getFormattedValueForTooltip(valueType) {
                return _renderUtil2["default"].formatValue({
                  value: this[valueType],
                  formatFunctions: this.formatFunctions,
                  chartType: this.chartType,
                  areaType: "tooltip",
                  valueType,
                  legendName: this.legendName
                });
              };
              SeriesItem2.prototype.pickValueMapForTooltip = function pickValueMapForTooltip() {
                var valueMap = {
                  value: this._getFormattedValueForTooltip("value"),
                  ratio: this.ratio
                };
                if ((0, _isExisty2["default"])(this.start)) {
                  valueMap.start = this._getFormattedValueForTooltip("start");
                  valueMap.end = this._getFormattedValueForTooltip("end");
                  valueMap.startRatio = this.startRatio;
                  valueMap.endRatio = this.endRatio;
                }
                return valueMap;
              };
              return SeriesItem2;
            }();
            exports2["default"] = SeriesItem;
          },
          /* 135 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _isArray = __webpack_require__(9);
            var _isArray2 = _interopRequireDefault(_isArray);
            var _isDate = __webpack_require__(18);
            var _isDate2 = _interopRequireDefault(_isDate);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isNumber = __webpack_require__(19);
            var _isNumber2 = _interopRequireDefault(_isNumber);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var SeriesItemForCoordinateType = function() {
              function SeriesItemForCoordinateType2(params) {
                _classCallCheck(this, SeriesItemForCoordinateType2);
                this.chartType = params.chartType;
                this.formatFunctions = params.formatFunctions;
                this.xAxisType = params.xAxisType;
                this.dateFormat = params.dateFormat;
                this.ratioMap = {};
                this._initData(params.datum, params.index);
              }
              SeriesItemForCoordinateType2.prototype._initData = function _initData(rawSeriesDatum, index) {
                var date = void 0;
                if ((0, _isArray2["default"])(rawSeriesDatum)) {
                  this.x = rawSeriesDatum[0] || 0;
                  this.y = rawSeriesDatum[1] || 0;
                  if (_predicate2["default"].isBubbleChart(this.chartType)) {
                    var _rawSeriesDatum = _slicedToArray(rawSeriesDatum, 4);
                    this.r = _rawSeriesDatum[2];
                    var _rawSeriesDatum$ = _rawSeriesDatum[3];
                    this.label = _rawSeriesDatum$ === void 0 ? "" : _rawSeriesDatum$;
                  } else {
                    var _rawSeriesDatum2 = _slicedToArray(rawSeriesDatum, 3);
                    var _rawSeriesDatum2$ = _rawSeriesDatum2[2];
                    this.label = _rawSeriesDatum2$ === void 0 ? "" : _rawSeriesDatum2$;
                  }
                } else {
                  this.x = rawSeriesDatum.x;
                  this.y = rawSeriesDatum.y;
                  this.r = rawSeriesDatum.r;
                  this.label = rawSeriesDatum.label || "";
                }
                if (_predicate2["default"].isDatetimeType(this.xAxisType)) {
                  date = (0, _isDate2["default"])(this.x) ? this.x : new Date(this.x);
                  this.x = date.getTime() || 0;
                }
                this.index = index;
                if (!this.label) {
                  if (_predicate2["default"].isLineTypeChart(this.chartType) && _predicate2["default"].isDatetimeType(this.xAxisType)) {
                    this.label = _renderUtil2["default"].formatDate(this.x, this.dateFormat);
                  } else {
                    this.label = _renderUtil2["default"].formatValue({
                      value: this.x,
                      formatFunctions: this.formatFunctions,
                      chartType: this.chartType,
                      areaType: "series"
                    });
                  }
                  var labelItem = _renderUtil2["default"].formatValue({
                    value: this.y,
                    formatFunctions: this.formatFunctions,
                    chartType: this.chartType,
                    areaType: "series"
                  });
                  this.label += ",&nbsp;" + labelItem;
                }
              };
              SeriesItemForCoordinateType2.prototype.addStart = function addStart(value) {
                this.start = value;
              };
              SeriesItemForCoordinateType2.prototype.addRatio = function addRatio(valueType, divNumber, subNumber) {
                if (!(0, _isExisty2["default"])(this.ratioMap[valueType]) && divNumber) {
                  this.ratioMap[valueType] = (this[valueType] - subNumber) / divNumber;
                }
              };
              SeriesItemForCoordinateType2.prototype._getFormattedValueForTooltip = function _getFormattedValueForTooltip(valueType) {
                var ratio = this.ratioMap[valueType];
                var value = this[valueType];
                var formattedValue = _renderUtil2["default"].formatValue({
                  value,
                  formatFunctions: this.formatFunctions,
                  chartType: this.chartType,
                  areaType: "tooltip",
                  valueType
                });
                return (0, _isNumber2["default"])(ratio) ? formattedValue : value;
              };
              SeriesItemForCoordinateType2.prototype.pickValueMapForTooltip = function pickValueMapForTooltip() {
                var valueMap = {
                  x: this._getFormattedValueForTooltip("x"),
                  y: this._getFormattedValueForTooltip("y"),
                  xRatio: this.ratioMap.x,
                  yRatio: this.ratioMap.y
                };
                if ((0, _isExisty2["default"])(this.r)) {
                  valueMap.r = this._getFormattedValueForTooltip("r");
                  valueMap.rRatio = this.ratioMap.r;
                }
                return valueMap;
              };
              return SeriesItemForCoordinateType2;
            }();
            exports2["default"] = SeriesItemForCoordinateType;
          },
          /* 136 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _seriesItemForBoxplot = __webpack_require__(137);
            var _seriesItemForBoxplot2 = _interopRequireDefault(_seriesItemForBoxplot);
            var _seriesDataModel = __webpack_require__(132);
            var _seriesDataModel2 = _interopRequireDefault(_seriesDataModel);
            var _isArray = __webpack_require__(9);
            var _isArray2 = _interopRequireDefault(_isArray);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var concat = Array.prototype.concat;
            var SeriesDataModelForBoxplot = function(_SeriesDataModel) {
              _inherits(SeriesDataModelForBoxplot2, _SeriesDataModel);
              function SeriesDataModelForBoxplot2(rawSeriesData, chartType, options, formatFunctions) {
                _classCallCheck(this, SeriesDataModelForBoxplot2);
                var _this = _possibleConstructorReturn(this, _SeriesDataModel.call(this));
                _this.chartType = chartType;
                _this.options = options || {};
                _this.formatFunctions = formatFunctions;
                _this.rawSeriesData = rawSeriesData || [];
                _this.baseGroups = null;
                _this.groups = null;
                _this.options.series = _this.options.series || {};
                _this.valuesMap = {};
                return _this;
              }
              SeriesDataModelForBoxplot2.prototype._createBaseGroups = function _createBaseGroups() {
                var chartType = this.chartType, formatFunctions = this.formatFunctions;
                return this.rawSeriesData.map(function(rawDatum) {
                  var data = (0, _isArray2["default"])(rawDatum) ? rawDatum : [].concat(rawDatum.data);
                  var items = data.map(function(datum, index) {
                    return new _seriesItemForBoxplot2["default"]({
                      datum,
                      chartType,
                      formatFunctions,
                      index,
                      legendName: rawDatum.name
                    });
                  });
                  return items;
                });
              };
              SeriesDataModelForBoxplot2.prototype._createValues = function _createValues() {
                var values = [];
                this.map(function(seriesGroup) {
                  return seriesGroup.items.forEach(function(group) {
                    values.push(group.min);
                    values.push(group.max);
                    values.push(group.uq);
                    values.push(group.lq);
                    values.push(group.median);
                  });
                });
                values = concat.apply([], values);
                return values.filter(function(value) {
                  return !isNaN(value);
                });
              };
              return SeriesDataModelForBoxplot2;
            }(_seriesDataModel2["default"]);
            exports2["default"] = SeriesDataModelForBoxplot;
          },
          /* 137 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var SeriesItem = function() {
              function SeriesItem2(params) {
                _classCallCheck(this, SeriesItem2);
                this.chartType = params.chartType;
                this.formatFunctions = params.formatFunctions;
                this.value = null;
                this.label = null;
                this.ratio = null;
                this.min = null;
                this.minLabel = null;
                this.minRatio = null;
                this.max = null;
                this.maxLabel = null;
                this.maxRatio = null;
                this.median = null;
                this.medianLabel = null;
                this.medianRatio = null;
                this.lq = null;
                this.lqLabel = null;
                this.lqRatio = null;
                this.uq = null;
                this.uqLabel = null;
                this.uqRatio = null;
                this.ratioDistance = null;
                this.legendName = params.legendName;
                this._initValues(params.datum, params.index);
              }
              SeriesItem2.prototype._initValues = function _initValues(rawValue, index) {
                var _this = this;
                var values = this._createValues(rawValue);
                var _values = _slicedToArray(values, 5), min = _values[0], lq = _values[1], median = _values[2], uq = _values[3], max = _values[4];
                var hasOutlier = values.length > 5;
                var outliers = void 0;
                var formatValue = function formatValue2(value) {
                  return _renderUtil2["default"].formatValue({
                    value,
                    formatFunctions: _this.formatFunctions,
                    chartType: _this.chartType,
                    areaType: "makingSeriesLabel",
                    legendName: _this.legendName
                  });
                };
                this.value = this.max = max;
                this.uq = uq;
                this.median = median;
                this.lq = lq;
                this.min = min;
                this.index = index;
                if (hasOutlier) {
                  this.outliers = [];
                  outliers = this.outliers;
                  values.slice(5).forEach(function(outlier) {
                    outliers.push({
                      value: outlier,
                      label: formatValue(outlier)
                    });
                  });
                }
                this.label = formatValue(max);
                this.uqLabel = formatValue(uq);
                this.medianLabel = formatValue(median);
                this.lqLabel = formatValue(lq);
                this.minLabel = formatValue(min);
                this.maxLabel = this.label;
              };
              SeriesItem2.prototype._createValues = function _createValues(value) {
                return [].concat(value).map(function(newValue) {
                  return (0, _isNull2["default"])(newValue) ? null : parseFloat(newValue);
                });
              };
              SeriesItem2.prototype.addStart = function addStart(value) {
                if (!(0, _isNull2["default"])(this.min)) {
                  return;
                }
                this.min = value;
                this.minLabel = _renderUtil2["default"].formatValue({
                  value,
                  formatFunctions: this.formatFunctions,
                  chartType: this.chartType,
                  areaType: "series",
                  legendName: this.legendName
                });
              };
              SeriesItem2.prototype._updateFormattedValueforRange = function _updateFormattedValueforRange() {
                this.label = this.minLabel + "~" + this.maxLabel;
              };
              SeriesItem2.prototype.addRatio = function addRatio() {
                var divNumber = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
                var subNumber = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                var baseRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
                var calculateRatio = _calculator2["default"].calculateRatio;
                this.ratio = this.maxRatio = calculateRatio(this.max, divNumber, subNumber, baseRatio);
                this.uqRatio = calculateRatio(this.uq, divNumber, subNumber, baseRatio);
                this.medianRatio = calculateRatio(this.median, divNumber, subNumber, baseRatio);
                this.lqRatio = calculateRatio(this.lq, divNumber, subNumber, baseRatio);
                this.minRatio = calculateRatio(this.min, divNumber, subNumber, baseRatio);
                (this.outliers || []).forEach(function(outlier) {
                  outlier.ratio = calculateRatio(outlier.value, divNumber, subNumber, baseRatio);
                });
                this.ratioDistance = Math.abs(this.uqRatio - this.lqRatio);
              };
              SeriesItem2.prototype._getFormattedValueForTooltip = function _getFormattedValueForTooltip(valueType) {
                return _renderUtil2["default"].formatValue({
                  value: this[valueType],
                  formatFunctions: this.formatFunctions,
                  chartType: this.chartType,
                  areaType: "tooltip",
                  valueType,
                  legendName: this.legendName
                });
              };
              SeriesItem2.prototype.pickValueMapForTooltip = function pickValueMapForTooltip() {
                var valueMap = {
                  value: this._getFormattedValueForTooltip("value"),
                  ratio: this.ratio
                };
                if ((0, _isExisty2["default"])(this.min)) {
                  valueMap.min = this._getFormattedValueForTooltip("min");
                  valueMap.max = this._getFormattedValueForTooltip("max");
                  valueMap.minRatio = this.minRatio;
                  valueMap.maxRatio = this.maxRatio;
                  valueMap.maxLabel = this.maxLabel;
                  valueMap.minLabel = this.minLabel;
                  valueMap.uqLabel = this.uqLabel;
                  valueMap.lqLabel = this.lqLabel;
                  valueMap.medianLabel = this.medianLabel;
                  valueMap.outliers = this.outliers;
                }
                return valueMap;
              };
              return SeriesItem2;
            }();
            exports2["default"] = SeriesItem;
          },
          /* 138 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _seriesItem = __webpack_require__(134);
            var _seriesItem2 = _interopRequireDefault(_seriesItem);
            var _seriesDataModel = __webpack_require__(132);
            var _seriesDataModel2 = _interopRequireDefault(_seriesDataModel);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var SeriesDataModelForBullet = function(_SeriesDataModel) {
              _inherits(SeriesDataModelForBullet2, _SeriesDataModel);
              function SeriesDataModelForBullet2() {
                _classCallCheck(this, SeriesDataModelForBullet2);
                return _possibleConstructorReturn(this, _SeriesDataModel.apply(this, arguments));
              }
              SeriesDataModelForBullet2.prototype._createBaseGroups = function _createBaseGroups() {
                var chartType = this.chartType, formatFunctions = this.formatFunctions;
                var maxRangeCount = 0;
                var maxMarkerCount = 0;
                var baseGroups = this.rawSeriesData.map(function(rawDatum) {
                  var items = [];
                  var data = rawDatum.data, markers = rawDatum.markers, ranges = rawDatum.ranges;
                  var markerCount = markers.length;
                  var rangeCount = ranges.length;
                  if (ranges && rangeCount) {
                    ranges.forEach(function(range) {
                      items.push(new _seriesItem2["default"]({
                        datum: range,
                        chartType,
                        formatFunctions,
                        type: _const2["default"].BULLET_TYPE_RANGE
                      }));
                    });
                    maxRangeCount = Math.max(maxRangeCount, rangeCount);
                  }
                  if (data) {
                    items.push(new _seriesItem2["default"]({
                      datum: data,
                      chartType,
                      formatFunctions,
                      type: _const2["default"].BULLET_TYPE_ACTUAL
                    }));
                  }
                  if (markers && markerCount) {
                    markers.forEach(function(marker) {
                      items.push(new _seriesItem2["default"]({
                        datum: marker,
                        chartType,
                        formabutFunctions: formatFunctions,
                        type: _const2["default"].BULLET_TYPE_MARKER
                      }));
                    });
                    maxMarkerCount = Math.max(maxMarkerCount, markerCount);
                  }
                  return items;
                });
                this.maxMarkerCount = maxMarkerCount;
                this.maxRangeCount = maxRangeCount;
                return baseGroups;
              };
              SeriesDataModelForBullet2.prototype._createSeriesGroupsFromRawData = function _createSeriesGroupsFromRawData() {
                return _seriesDataModel2["default"].prototype._createSeriesGroupsFromRawData.call(this);
              };
              return SeriesDataModelForBullet2;
            }(_seriesDataModel2["default"]);
            exports2["default"] = SeriesDataModelForBullet;
          },
          /* 139 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _pluck = __webpack_require__(58);
            var _pluck2 = _interopRequireDefault(_pluck);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _seriesDataModel = __webpack_require__(132);
            var _seriesDataModel2 = _interopRequireDefault(_seriesDataModel);
            var _seriesItemForTreemap = __webpack_require__(140);
            var _seriesItemForTreemap2 = _interopRequireDefault(_seriesItemForTreemap);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var SeriesDataModelForTreeMap = function(_SeriesDataModel) {
              _inherits(SeriesDataModelForTreeMap2, _SeriesDataModel);
              function SeriesDataModelForTreeMap2() {
                _classCallCheck(this, SeriesDataModelForTreeMap2);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                var _this = _possibleConstructorReturn(this, _SeriesDataModel.call.apply(_SeriesDataModel, [this].concat(args)));
                _this.foundSeriesItemsMap = {};
                _this.seriesItemMap = {};
                return _this;
              }
              SeriesDataModelForTreeMap2.prototype._flattenHierarchicalData = function _flattenHierarchicalData(rawSeriesData, parent, ancestorIndexes) {
                var _this2 = this;
                var flatData = [];
                var idPrefix = void 0;
                if (parent) {
                  idPrefix = parent + "_";
                } else {
                  idPrefix = _const2["default"].TREEMAP_ID_PREFIX;
                  parent = _const2["default"].TREEMAP_ROOT_ID;
                }
                ancestorIndexes = ancestorIndexes || [];
                rawSeriesData.forEach(function(datum, index) {
                  var id = idPrefix + index;
                  var children = datum.children;
                  var indexes = ancestorIndexes.concat(index);
                  datum.indexes = indexes;
                  if (!(0, _isNull2["default"])(datum.value)) {
                    flatData.push(datum);
                  }
                  if (!datum.id) {
                    datum.id = id;
                  }
                  if (!datum.parent) {
                    datum.parent = parent;
                  }
                  if (children) {
                    flatData = flatData.concat(_this2._flattenHierarchicalData(children, id, indexes));
                    delete datum.children;
                  }
                });
                return flatData;
              };
              SeriesDataModelForTreeMap2.prototype._partitionRawSeriesDataByParent = function _partitionRawSeriesDataByParent(rawSeriesData, parent) {
                var filtered = [];
                var rejected = [];
                rawSeriesData.forEach(function(datum) {
                  if (datum.parent === parent) {
                    filtered.push(datum);
                  } else {
                    rejected.push(datum);
                  }
                });
                return [filtered, rejected];
              };
              SeriesDataModelForTreeMap2.prototype._setTreeProperties = function _setTreeProperties(flatSeriesData, depth, parent, group) {
                var _this3 = this;
                var parted = this._partitionRawSeriesDataByParent(flatSeriesData, parent);
                var _parted = _slicedToArray(parted, 1), filtered = _parted[0];
                var _parted2 = _slicedToArray(parted, 2), rejected = _parted2[1];
                var childDepth = depth + 1;
                filtered.forEach(function(datum, index) {
                  datum.depth = depth;
                  datum.group = (0, _isUndefined2["default"])(group) ? index : group;
                  var descendants = _this3._setTreeProperties(rejected, childDepth, datum.id, datum.group, datum.fillOpacity);
                  var children = descendants.filter(function(descendant) {
                    return descendant.depth === childDepth;
                  });
                  if (children.length) {
                    datum.value = _calculator2["default"].sum((0, _pluck2["default"])(children, "value"));
                    datum.hasChild = true;
                  } else {
                    datum.hasChild = false;
                  }
                  if (descendants.length) {
                    descendants.sort(function(a, b) {
                      return b.value - a.value;
                    });
                  }
                  filtered = filtered.concat(descendants);
                });
                return filtered;
              };
              SeriesDataModelForTreeMap2.prototype._setRatio = function _setRatio(flatSeriesData, parent) {
                var _this4 = this;
                var parted = this._partitionRawSeriesDataByParent(flatSeriesData, parent);
                var _parted3 = _slicedToArray(parted, 2), filtered = _parted3[0], rejected = _parted3[1];
                var total = _calculator2["default"].sum((0, _pluck2["default"])(filtered, "value"));
                filtered.forEach(function(datum) {
                  var value = (0, _isNull2["default"])(datum.value) ? 0 : datum.value;
                  datum.ratio = value / total;
                  if (datum.hasChild) {
                    _this4._setRatio(rejected, datum.id);
                  }
                });
              };
              SeriesDataModelForTreeMap2.prototype._createBaseGroups = function _createBaseGroups() {
                var chartType = this.chartType, seriesItemMap = this.seriesItemMap, formatFunctions = this.formatFunctions;
                var flatSeriesData = this._flattenHierarchicalData(this.rawSeriesData);
                flatSeriesData = this._setTreeProperties(flatSeriesData, 1, _const2["default"].TREEMAP_ROOT_ID);
                this._setRatio(flatSeriesData, _const2["default"].TREEMAP_ROOT_ID);
                return [flatSeriesData.map(function(rawDatum) {
                  var seriesItem = new _seriesItemForTreemap2["default"](rawDatum, formatFunctions, chartType);
                  seriesItemMap[seriesItem.id] = seriesItem;
                  return seriesItem;
                })];
              };
              SeriesDataModelForTreeMap2.prototype._findSeriesItems = function _findSeriesItems(key, condition) {
                if (!this.foundSeriesItemsMap[key]) {
                  this.foundSeriesItemsMap[key] = this.getFirstSeriesGroup(true).filter(condition);
                }
                return this.foundSeriesItemsMap[key];
              };
              SeriesDataModelForTreeMap2.prototype._makeCacheKey = function _makeCacheKey() {
                for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }
                var key = args[0];
                if (args.length > 1) {
                  key += args.slice(1).join("_");
                }
                return key;
              };
              SeriesDataModelForTreeMap2.prototype._isValidGroup = function _isValidGroup(group, comparingGroup) {
                return !(0, _isExisty2["default"])(comparingGroup) || group === comparingGroup;
              };
              SeriesDataModelForTreeMap2.prototype.findSeriesItemsByDepth = function findSeriesItemsByDepth(depth, group) {
                var _this5 = this;
                var key = this._makeCacheKey(_const2["default"].TREEMAP_DEPTH_KEY_PREFIX, depth, group);
                return this._findSeriesItems(key, function(seriesItem) {
                  return seriesItem.depth === depth && _this5._isValidGroup(seriesItem.group, group);
                });
              };
              SeriesDataModelForTreeMap2.prototype.findSeriesItemsByParent = function findSeriesItemsByParent(parent) {
                var key = this._makeCacheKey(_const2["default"].TREEMAP_PARENT_KEY_PREFIX, parent);
                return this._findSeriesItems(key, function(seriesItem) {
                  return seriesItem.parent === parent;
                });
              };
              SeriesDataModelForTreeMap2.prototype.findLeafSeriesItems = function findLeafSeriesItems(group) {
                var _this6 = this;
                var key = this._makeCacheKey(_const2["default"].TREEMAP_LEAF_KEY_PREFIX, group);
                return this._findSeriesItems(key, function(seriesItem) {
                  return !seriesItem.hasChild && _this6._isValidGroup(seriesItem.group, group);
                });
              };
              SeriesDataModelForTreeMap2.prototype.findParentByDepth = function findParentByDepth(id, depth) {
                var seriesItem = this.seriesItemMap[id] || null;
                if (seriesItem && seriesItem.depth !== depth) {
                  seriesItem = this.findParentByDepth(seriesItem.parent, depth);
                }
                return seriesItem;
              };
              SeriesDataModelForTreeMap2.prototype.initSeriesItemsMap = function initSeriesItemsMap() {
                this.foundSeriesItemsMap = null;
              };
              return SeriesDataModelForTreeMap2;
            }(_seriesDataModel2["default"]);
            exports2["default"] = SeriesDataModelForTreeMap;
          },
          /* 140 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var SeriesItemForTreemap = function() {
              function SeriesItemForTreemap2(rawSeriesDatum, formatFunctions, chartType) {
                _classCallCheck(this, SeriesItemForTreemap2);
                this.chartType = chartType;
                this.formatFunctions = formatFunctions;
                this.id = rawSeriesDatum.id;
                this.parent = rawSeriesDatum.parent;
                this.value = rawSeriesDatum.value;
                this.ratio = rawSeriesDatum.ratio;
                this.colorValue = rawSeriesDatum.colorValue;
                this.depth = rawSeriesDatum.depth;
                this.label = rawSeriesDatum.label || "";
                this.group = rawSeriesDatum.group;
                this.hasChild = !!rawSeriesDatum.hasChild;
                this.indexes = rawSeriesDatum.indexes;
                this.fillOpacity = rawSeriesDatum.fillOpacity;
              }
              SeriesItemForTreemap2.prototype.addRatio = function addRatio() {
                var divNumber = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
                var subNumber = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                this.colorRatio = _calculator2["default"].calculateRatio(this.colorValue, divNumber, subNumber, 1) || -1;
              };
              SeriesItemForTreemap2.prototype.pickValueMapForTooltip = function pickValueMapForTooltip() {
                var formatFunctions = this.formatFunctions, chartType = this.chartType, colorValue = this.colorValue;
                var formattedValue = _renderUtil2["default"].formatValue({
                  value: this.value,
                  formatFunctions,
                  chartType,
                  areaType: "tooltipValue"
                });
                var label = formattedValue;
                var valueMap = {
                  legend: this.label || "",
                  value: formattedValue,
                  label,
                  ratio: this.ratio,
                  tooltipColorIndex: this.indexes[0]
                };
                if ((0, _isExisty2["default"])(colorValue)) {
                  valueMap.colorValue = _renderUtil2["default"].formatValue({
                    value: colorValue,
                    formatFunctions,
                    chartType,
                    areaType: "tooltipColorValue"
                  });
                  valueMap.colorRatio = this.colorRatio;
                }
                return valueMap;
              };
              SeriesItemForTreemap2.prototype.pickLabelTemplateData = function pickLabelTemplateData() {
                var templateData = {
                  value: this.value,
                  ratio: this.ratio,
                  label: this.label
                };
                if ((0, _isExisty2["default"])(this.colorValue)) {
                  templateData.colorValue = this.colorValue;
                  templateData.colorValueRatio = this.ratio;
                }
                return templateData;
              };
              return SeriesItemForTreemap2;
            }();
            exports2["default"] = SeriesItemForTreemap;
          },
          /* 141 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _boundsModel = __webpack_require__(142);
            var _boundsModel2 = _interopRequireDefault(_boundsModel);
            var _scaleDataModel = __webpack_require__(148);
            var _scaleDataModel2 = _interopRequireDefault(_scaleDataModel);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            exports2["default"] = {
              /**
               * Create BoundsModel.
               * @param {DataProcessor} dataProcessor - DataProcessor instance
               * @param {object} params - parameters
               * @returns {BoundsModel}
               * @private
               */
              _createBoundsModel: function _createBoundsModel(dataProcessor, params) {
                return new _boundsModel2["default"]({
                  chartType: params.chartType,
                  seriesTypes: params.seriesTypes,
                  options: params.options,
                  theme: params.theme,
                  dataProcessor,
                  hasAxes: params.hasAxes,
                  isVertical: params.isVertical
                });
              },
              /**
               * Create ScaleDataModel.
               * @param {DataProcessor} dataProcessor - DataProcessor instance
               * @param {BoundsModel} boundsModel - BoundsModel instance
               * @param {object} params - parameters
               * @returns {ScaleDataModel}
               * @private
               */
              _createScaleDataModel: function _createScaleDataModel(dataProcessor, boundsModel, params) {
                return new _scaleDataModel2["default"]({
                  chartType: params.chartType,
                  seriesTypes: params.seriesTypes,
                  options: params.options,
                  theme: params.theme,
                  dataProcessor,
                  boundsModel,
                  hasRightYAxis: params.hasRightYAxis,
                  addedDataCount: params.addedDataCount
                });
              },
              /**
               * Add y axis scale.
               * @param {ScaleDataModel} scaleDataModel - ScaleDataModel instance
               * @param {string} name - component name
               * @param {object} scaleOption - option for add scale
               * @param {object} yAxisOptions - option for yAxis
               */
              addYAxisScale: function addYAxisScale(scaleDataModel, name, scaleOption, yAxisOptions) {
                scaleDataModel.addScale(name, scaleOption && scaleOption.options || yAxisOptions || {}, {
                  valueType: scaleOption.valueType || "value",
                  areaType: scaleOption.areaType,
                  chartType: scaleOption.chartType
                }, scaleOption.additionalOptions);
              },
              /**
               * Register dimension for y axis.
               * @param {ComponentManager} componentManager - ComponentManager instance
               * @param {BoundsModel} boundsModel - BoundsModel instance
               * @param {object.<string, object>} scaleDataMap - scale data map
               * @param {string} axisName - axis name like yAxis and rightYAxis
               * @param {boolean} isVertical - whether vertical or not
               * @private
               */
              _registerYAxisDimension: function _registerYAxisDimension(componentManager, boundsModel, scaleDataMap, axisName, isVertical) {
                var yAxis = componentManager.get(axisName);
                var limit = null;
                var yAxisLabels = [];
                if (!yAxis) {
                  return;
                }
                var scaleData = scaleDataMap[axisName];
                if (scaleData) {
                  limit = scaleData.limit;
                  yAxisLabels = scaleData.labels;
                }
                boundsModel.registerYAxisDimension({
                  limit,
                  axisName,
                  options: yAxis.options,
                  theme: yAxis.theme,
                  yAxisLabels,
                  isVertical
                });
              },
              /**
               * Set layout bounds and scale.
               * @param {DataProcessor} dataProcessor - DataProcessor instance
               * @param {ComponentManager} componentManager - ComponentManager instance
               * @param {BoundsModel} boundsModel - BoundsModel instance
               * @param {ScaleDataModel} scaleDataModel - ScaleDataModel instance
               * @param {object} params - parameter for setting layout bounds and scale data.
               * @private
               */
              _setLayoutBoundsAndScale: function _setLayoutBoundsAndScale(dataProcessor, componentManager, boundsModel, scaleDataModel, params) {
                var options = params.options, _params$scaleOption = params.scaleOption, scaleOption = _params$scaleOption === void 0 ? {} : _params$scaleOption, addingDataMode = params.addingDataMode, isVertical = params.isVertical;
                if (componentManager.has("xAxis")) {
                  boundsModel.registerXAxisHeight();
                }
                if (componentManager.has("legend")) {
                  if (componentManager.get("legend").colorSpectrum) {
                    boundsModel.registerSpectrumLegendDimension();
                  } else {
                    boundsModel.registerLegendDimension();
                  }
                }
                if (scaleOption.yAxis) {
                  this.addYAxisScale(scaleDataModel, "yAxis", scaleOption.yAxis, params.options.yAxis);
                }
                if (scaleOption.rightYAxis) {
                  this.addYAxisScale(scaleDataModel, "rightYAxis", scaleOption.rightYAxis);
                }
                if (scaleOption.legend) {
                  scaleDataModel.addScale("legend", {}, {
                    chartType: params.chartType
                  }, {
                    tickCounts: [_const2["default"].SPECTRUM_LEGEND_TICK_COUNT]
                  });
                }
                var scaleDataMap = scaleDataModel.scaleDataMap;
                if (scaleDataMap.legend && componentManager.get("legend") && componentManager.get("legend").colorSpectrum) {
                  boundsModel.registerSpectrumLegendDimension(scaleDataMap.legend.limit);
                }
                this._registerYAxisDimension(componentManager, boundsModel, scaleDataMap, "yAxis", isVertical);
                this._registerYAxisDimension(componentManager, boundsModel, scaleDataMap, "rightYAxis", isVertical);
                if (scaleOption.xAxis) {
                  scaleDataModel.addScale("xAxis", options.xAxis, {
                    valueType: scaleOption.xAxis.valueType || "value"
                  }, scaleOption.xAxis.additionalOptions);
                }
                if (params.hasAxes) {
                  scaleDataModel.setAxisDataMap();
                }
                boundsModel.registerSeriesDimension();
                if (componentManager.has("circleLegend") && options.circleLegend.visible) {
                  boundsModel.registerCircleLegendDimension(scaleDataModel.axisDataMap);
                }
                if (componentManager.has("xAxis")) {
                  if (_predicate2["default"].isAutoTickInterval(options.xAxis.tickInterval)) {
                    scaleDataModel.updateXAxisDataForAutoTickInterval(params.prevXAxisData, addingDataMode);
                  }
                  scaleDataModel.updateXAxisDataForLabel(addingDataMode);
                }
                boundsModel.registerBoundsData(scaleDataModel.axisDataMap.xAxis);
              },
              /**
               * Build layout bounds and scale data.
               * @param {DataProcessor} dataProcessor - DataProcessor instance
               * @param {ComponentManager} componentManager - ComponentManager instance
               * @param {object} params - parameter for building layout bounds and scale data.
               * @returns {{
               *      dimensionMap: object,
               *      positionMap: object,
               *      limitMap: {
               *          xAxis: ?{min: number, max: number},
               *          yAxis: ?{min: number, max: number},
               *          rightYAxis: ?{min: number, max: number},
               *          legend: ?{min: number, max: number}
               *      },
               *      axisDataMap: ?object,
               *      maxRadius: ?number,
               *      legendScaleData: ?object
               * }}
               */
              build: function build(dataProcessor, componentManager, params) {
                var boundsModel = this._createBoundsModel(dataProcessor, params);
                var scaleDataModel = this._createScaleDataModel(dataProcessor, boundsModel, params);
                this._setLayoutBoundsAndScale(dataProcessor, componentManager, boundsModel, scaleDataModel, params);
                var boundsAndScale = {
                  dimensionMap: boundsModel.dimensionMap,
                  positionMap: boundsModel.positionMap,
                  limitMap: scaleDataModel.makeLimitMap(params.seriesTypes || [params.chartType], params.isVertical)
                };
                if (scaleDataModel.axisDataMap) {
                  boundsAndScale.axisDataMap = scaleDataModel.axisDataMap;
                }
                if (_predicate2["default"].isBubbleChart(params.chartType)) {
                  boundsAndScale.maxRadius = boundsModel.calculateMaxRadius(scaleDataModel.axisDataMap);
                }
                if (scaleDataModel.scaleDataMap.legend) {
                  boundsAndScale.legendScaleData = scaleDataModel.scaleDataMap.legend;
                }
                return boundsAndScale;
              }
            };
          },
          /* 142 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _browser = __webpack_require__(22);
            var _browser2 = _interopRequireDefault(_browser);
            var _isArray = __webpack_require__(9);
            var _isArray2 = _interopRequireDefault(_isArray);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _pluck = __webpack_require__(58);
            var _pluck2 = _interopRequireDefault(_pluck);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _raphaelRenderUtil = __webpack_require__(12);
            var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
            var _circleLegendCalculator = __webpack_require__(143);
            var _circleLegendCalculator2 = _interopRequireDefault(_circleLegendCalculator);
            var _axisCalculator = __webpack_require__(144);
            var _axisCalculator2 = _interopRequireDefault(_axisCalculator);
            var _legendCalculator = __webpack_require__(145);
            var _legendCalculator2 = _interopRequireDefault(_legendCalculator);
            var _seriesCalculator = __webpack_require__(146);
            var _seriesCalculator2 = _interopRequireDefault(_seriesCalculator);
            var _spectrumLegendCalculator = __webpack_require__(147);
            var _spectrumLegendCalculator2 = _interopRequireDefault(_spectrumLegendCalculator);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var LEGEND_AREA_H_PADDING = _const2["default"].LEGEND_AREA_H_PADDING;
            var IS_LTE_IE8 = _browser2["default"].msie && _browser2["default"].version <= 8;
            var BoundsModel = function() {
              function BoundsModel2(params) {
                _classCallCheck(this, BoundsModel2);
                this.options = params.options || {};
                this.options.legend = this.options.legend || {};
                this.options.yAxis = this.options.yAxis || {};
                this.theme = params.theme || {};
                this.hasAxes = params.hasAxes;
                this.chartType = params.chartType;
                this.seriesTypes = params.seriesTypes || [];
                this.dataProcessor = params.dataProcessor;
                this.initBoundsData();
              }
              BoundsModel2.prototype.initBoundsData = function initBoundsData() {
                this.dimensionMap = {
                  legend: {
                    width: 0
                  },
                  yAxis: {
                    width: 0
                  },
                  rightYAxis: {
                    width: 0
                  },
                  xAxis: {
                    height: 0
                  },
                  circleLegend: {
                    width: 0
                  },
                  chartExportMenu: {
                    width: 0
                  }
                };
                this.positionMap = {};
                this.chartLeftPadding = _const2["default"].CHART_PADDING;
                this.maxRadiusForBubbleChart = null;
                this._registerChartDimension();
                this._registerTitleDimension();
                this._registerChartExportMenuDimension();
              };
              BoundsModel2.prototype._registerDimension = function _registerDimension(name, dimension) {
                this.dimensionMap[name] = Object.assign(this.dimensionMap[name] || {}, dimension);
              };
              BoundsModel2.prototype.getBound = function getBound(name) {
                return {
                  dimension: this.dimensionMap[name] || {},
                  position: this.positionMap[name] || {}
                };
              };
              BoundsModel2.prototype._setBound = function _setBound(name, bound) {
                this.dimensionMap[name] = bound.dimension;
                this.positionMap[name] = bound.position;
              };
              BoundsModel2.prototype.getDimension = function getDimension(name) {
                return this.dimensionMap[name];
              };
              BoundsModel2.prototype.getDimensionMap = function getDimensionMap(types) {
                var _this = this;
                var dimensionMap = {};
                if (types && types.length) {
                  types.forEach(function(type) {
                    dimensionMap[type] = _this.dimensionMap[type];
                  });
                } else {
                  dimensionMap = this.dimensionMap;
                }
                return JSON.parse(JSON.stringify(dimensionMap));
              };
              BoundsModel2.prototype.getPosition = function getPosition(name) {
                return this.positionMap[name];
              };
              BoundsModel2.prototype._registerChartDimension = function _registerChartDimension() {
                var chartOptions = this.options.chart || {};
                var dimension = {
                  width: chartOptions.width || _const2["default"].CHART_DEFAULT_WIDTH,
                  height: chartOptions.height || _const2["default"].CHART_DEFAULT_HEIGHT
                };
                this._registerDimension("chart", dimension);
              };
              BoundsModel2.prototype._registerTitleDimension = function _registerTitleDimension() {
                var chartOptions = this.options.chart || {};
                var hasTitleOption = (0, _isExisty2["default"])(chartOptions.title);
                var titleTheme = this.theme.title;
                var titleHeight = hasTitleOption ? _raphaelRenderUtil2["default"].getRenderedTextSize(chartOptions.title.text, titleTheme.fontSize, titleTheme.fontFamily).height : 0;
                var height = titleHeight || 0;
                if (height) {
                  height += _const2["default"].TITLE_PADDING;
                }
                this._registerDimension("title", {
                  height
                });
              };
              BoundsModel2.prototype._registerChartExportMenuDimension = function _registerChartExportMenuDimension() {
                var dimension = void 0;
                if (this.options.chartExportMenu.visible === false) {
                  dimension = {
                    width: 0,
                    height: 0
                  };
                } else {
                  dimension = {
                    height: _const2["default"].CHART_EXPORT_MENU_SIZE + _const2["default"].SERIES_AREA_V_PADDING,
                    width: _const2["default"].CHART_EXPORT_MENU_SIZE
                  };
                }
                this._registerDimension("chartExportMenu", dimension);
              };
              BoundsModel2.prototype.registerXAxisHeight = function registerXAxisHeight() {
                this._registerDimension("xAxis", {
                  height: _axisCalculator2["default"].calculateXAxisHeight(this.options.xAxis, this.theme.xAxis)
                });
              };
              BoundsModel2.prototype.registerLegendDimension = function registerLegendDimension() {
                var legendLabels = (0, _pluck2["default"])(this.dataProcessor.getOriginalLegendData(), "label");
                var legendOptions = this.options.legend;
                var labelTheme = this.theme.legend.label;
                var chartWidth = this.getDimension("chart").width;
                var legendDimension = _legendCalculator2["default"].calculate(legendOptions, labelTheme, legendLabels, chartWidth);
                this._registerDimension("legend", legendDimension);
              };
              BoundsModel2.prototype.registerSpectrumLegendDimension = function registerSpectrumLegendDimension(limit) {
                var maxValue = limit ? limit.max : this.dataProcessor.getFormattedMaxValue(this.chartType, "legend");
                var minValue = limit ? limit.min : "";
                var labelTheme = this.theme.label;
                var align = this.options.legend.align;
                var dimension = void 0;
                if (_predicate2["default"].isHorizontalLegend(align)) {
                  var isBoxType = _predicate2["default"].isBoxTypeChart(this.chartType);
                  var isTopLegend = _predicate2["default"].isLegendAlignTop(align);
                  dimension = _spectrumLegendCalculator2["default"]._makeHorizontalDimension(maxValue, labelTheme, isBoxType, isTopLegend);
                } else {
                  dimension = _spectrumLegendCalculator2["default"]._makeVerticalDimension(maxValue, minValue, labelTheme);
                }
                this._registerDimension("legend", dimension);
                this.useSpectrumLegend = true;
              };
              BoundsModel2.prototype.registerYAxisDimension = function registerYAxisDimension(dimensionInfos) {
                var limit = dimensionInfos.limit, options = dimensionInfos.options, theme = dimensionInfos.theme, yAxisLabels = dimensionInfos.yAxisLabels, isVertical = dimensionInfos.isVertical, componentName = dimensionInfos.axisName;
                var isDiverging = this.options.series && this.options.series.diverging;
                var categories = void 0, yAxisOptions = void 0;
                if (limit) {
                  categories = [limit.min, limit.max];
                } else if (_predicate2["default"].isHeatmapChart(this.chartType) || !isVertical) {
                  categories = this.dataProcessor.getCategories(true);
                } else {
                  return;
                }
                if ((0, _isArray2["default"])(options)) {
                  yAxisOptions = componentName === "yAxis" ? options[0] : options[1];
                } else {
                  yAxisOptions = options;
                }
                this._registerDimension(componentName, {
                  width: _axisCalculator2["default"].calculateYAxisWidth(categories, yAxisOptions, theme, yAxisLabels, isDiverging)
                });
              };
              BoundsModel2.prototype.calculateSeriesWidth = function calculateSeriesWidth() {
                var maxLabel = this.dataProcessor.getFormattedMaxValue(this.chartType, "series", "value");
                var dimensionMap = this.getDimensionMap(["chart", "yAxis", "legend", "rightYAxis"]);
                var maxLabelWidth = 0;
                if (!_predicate2["default"].isColumnTypeChart(this.chartType)) {
                  maxLabelWidth = _renderUtil2["default"].getRenderedLabelHeight(maxLabel, this.theme.title);
                }
                var seriesWidth = _seriesCalculator2["default"].calculateWidth(dimensionMap, this.options.legend, maxLabelWidth);
                if (_predicate2["default"].isMapChart(this.chartType) && !IS_LTE_IE8) {
                  seriesWidth -= _const2["default"].MAP_CHART_ZOOM_AREA_WIDTH + LEGEND_AREA_H_PADDING;
                }
                return seriesWidth;
              };
              BoundsModel2.prototype.calculateSeriesHeight = function calculateSeriesHeight() {
                var dimensionMap = this.getDimensionMap(["chart", "title", "legend", "xAxis", "chartExportMenu"]);
                var yAxisTitleAreaHeight = 0;
                if (this.options.yAxis && this.options.yAxis.title) {
                  yAxisTitleAreaHeight = _renderUtil2["default"].getRenderedLabelHeight(this.options.yAxis.title, this.theme.title);
                }
                return _seriesCalculator2["default"].calculateHeight(dimensionMap, this.options.legend, yAxisTitleAreaHeight);
              };
              BoundsModel2.prototype.getBaseSizeForLimit = function getBaseSizeForLimit(isVertical) {
                var baseSize = void 0;
                if (isVertical) {
                  baseSize = this.calculateSeriesHeight();
                } else {
                  baseSize = this.calculateSeriesWidth();
                }
                return baseSize;
              };
              BoundsModel2.prototype._makeSeriesDimension = function _makeSeriesDimension() {
                return {
                  width: this.calculateSeriesWidth(),
                  height: this.calculateSeriesHeight()
                };
              };
              BoundsModel2.prototype.registerSeriesDimension = function registerSeriesDimension() {
                var seriesDimension = this._makeSeriesDimension();
                this._registerDimension("series", seriesDimension);
              };
              BoundsModel2.prototype._updateLegendAndSeriesWidth = function _updateLegendAndSeriesWidth(circleLegendWidth, diffWidth) {
                var legendOptions = this.options.legend;
                if (_predicate2["default"].isVerticalLegend(legendOptions.align) && legendOptions.visible) {
                  this._registerDimension("legend", {
                    width: circleLegendWidth
                  });
                }
                this._registerDimension("series", {
                  width: this.getDimension("series").width - diffWidth
                });
              };
              BoundsModel2.prototype.registerCircleLegendDimension = function registerCircleLegendDimension(axisDataMap) {
                var seriesDimension = this.getDimension("series");
                var legendOptions = this.options.legend;
                var maxLabel = this.dataProcessor.getFormattedMaxValue(this.chartType, "circleLegend", "r");
                var fontFamily = this.theme.chart.fontFamily;
                var circleLegendWidth = _circleLegendCalculator2["default"].calculateCircleLegendWidth(seriesDimension, axisDataMap, maxLabel, fontFamily);
                var legendWidth = void 0;
                if (_predicate2["default"].isVerticalLegend(legendOptions.align) && legendOptions.visible) {
                  legendWidth = this.getDimension("legend").width;
                } else {
                  legendWidth = 0;
                }
                circleLegendWidth = Math.min(circleLegendWidth, Math.max(legendWidth, _const2["default"].MIN_LEGEND_WIDTH));
                var diffWidth = circleLegendWidth - legendWidth;
                this._registerDimension("circleLegend", {
                  width: circleLegendWidth,
                  height: circleLegendWidth
                });
                if (diffWidth > 0) {
                  this._updateLegendAndSeriesWidth(circleLegendWidth, diffWidth);
                }
              };
              BoundsModel2.prototype._makePlotDimension = function _makePlotDimension() {
                var seriesDimension = this.getDimension("series");
                return {
                  width: seriesDimension.width,
                  height: seriesDimension.height + _const2["default"].OVERLAPPING_WIDTH
                };
              };
              BoundsModel2.prototype._registerCenterComponentsDimension = function _registerCenterComponentsDimension() {
                var seriesDimension = this.getDimension("series");
                this._registerDimension("tooltip", seriesDimension);
                this._registerDimension("mouseEventDetector", seriesDimension);
              };
              BoundsModel2.prototype._registerAxisComponentsDimension = function _registerAxisComponentsDimension() {
                var plotDimension = this._makePlotDimension();
                this._registerDimension("plot", plotDimension);
                this._registerDimension("xAxis", {
                  width: plotDimension.width
                });
                this._registerDimension("yAxis", {
                  height: plotDimension.height
                });
                this._registerDimension("rightYAxis", {
                  height: plotDimension.height
                });
              };
              BoundsModel2.prototype._updateDimensionsWidth = function _updateDimensionsWidth(overflowInfo) {
                var overflowLeft = Math.max(overflowInfo.overflowLeft, 0);
                var overflowRight = overflowInfo.overflowRight ? Math.max(overflowInfo.overflowRight, 0) : 0;
                var margin = overflowLeft + overflowRight;
                this.chartLeftPadding += overflowLeft;
                this.dimensionMap.plot.width -= margin;
                this.dimensionMap.series.width -= margin;
                this.dimensionMap.mouseEventDetector.width -= margin;
                this.dimensionMap.xAxis.width -= margin;
              };
              BoundsModel2.prototype._updateDimensionsHeight = function _updateDimensionsHeight(diffHeight) {
                this.dimensionMap.plot.height -= diffHeight;
                this.dimensionMap.series.height -= diffHeight;
                this.dimensionMap.mouseEventDetector.height -= diffHeight;
                this.dimensionMap.tooltip.height -= diffHeight;
                this.dimensionMap.yAxis.height -= diffHeight;
                this.dimensionMap.rightYAxis.height -= diffHeight;
                this.dimensionMap.xAxis.height += diffHeight;
              };
              BoundsModel2.prototype._updateDimensionsForXAxisLabel = function _updateDimensionsForXAxisLabel(xAxisData) {
                if (xAxisData.overflowRight > 0 || xAxisData.overflowLeft > 0) {
                  this._updateDimensionsWidth(xAxisData);
                }
                if (xAxisData.overflowHeight) {
                  this._updateDimensionsHeight(xAxisData.overflowHeight);
                }
              };
              BoundsModel2.prototype._registerAxisComponentsPosition = function _registerAxisComponentsPosition(leftLegendWidth) {
                var seriesPosition = this.getPosition("series");
                var seriesDimension = this.getDimension("series");
                var yAxisWidth = this.getDimension("yAxis").width;
                var leftAreaWidth = leftLegendWidth + yAxisWidth + seriesDimension.width;
                this.positionMap.plot = {
                  top: seriesPosition.top,
                  left: seriesPosition.left
                };
                this.positionMap.yAxis = {
                  top: seriesPosition.top,
                  left: this.chartLeftPadding + leftLegendWidth
                };
                this.positionMap.xAxis = {
                  top: seriesPosition.top + seriesDimension.height,
                  left: seriesPosition.left
                };
                this.positionMap.rightYAxis = {
                  top: seriesPosition.top,
                  left: this.chartLeftPadding + leftAreaWidth - _const2["default"].OVERLAPPING_WIDTH
                };
              };
              BoundsModel2.prototype._makeLegendPosition = function _makeLegendPosition() {
                var dimensionMap = this.dimensionMap;
                var seriesDimension = dimensionMap.series;
                var seriesPositionTop = this.getPosition("series").top;
                var legendOption = this.options.legend;
                var top = 0;
                var yAxisAreaWidth = void 0, left = void 0;
                if (_predicate2["default"].isHorizontalLegend(legendOption.align)) {
                  left = (this.getDimension("chart").width - this.getDimension("legend").width) / 2;
                  if (_predicate2["default"].isLegendAlignBottom(legendOption.align)) {
                    top = seriesPositionTop + seriesDimension.height + this.getDimension("xAxis").height + _const2["default"].SERIES_AREA_V_PADDING;
                  } else {
                    top = seriesPositionTop - dimensionMap.legend.height + _const2["default"].LEGEND_AREA_V_PADDING;
                  }
                } else {
                  if (_predicate2["default"].isLegendAlignLeft(legendOption.align)) {
                    left = this.chartLeftPadding;
                  } else {
                    yAxisAreaWidth = this.getDimension("yAxis").width + this.getDimension("rightYAxis").width;
                    left = this.chartLeftPadding + yAxisAreaWidth + seriesDimension.width;
                  }
                  top = seriesPositionTop + _const2["default"].SERIES_AREA_V_PADDING;
                }
                return {
                  top,
                  left
                };
              };
              BoundsModel2.prototype._makeSpectrumLegendPosition = function _makeSpectrumLegendPosition() {
                var legendOption = this.options.legend;
                var align = this.options.legend.align;
                var seriesPosition = this.getPosition("series");
                var seriesDimension = this.getDimension("series");
                var legendDimension = this.getDimension("legend");
                var top = void 0, left = void 0, right = void 0;
                if (_predicate2["default"].isHorizontalLegend(align)) {
                  left = (this.getDimension("chart").width - legendDimension.width) / 2;
                  if (_predicate2["default"].isLegendAlignTop(align)) {
                    top = seriesPosition.top - legendDimension.height;
                  } else {
                    top = seriesPosition.top + seriesDimension.height + this.getDimension("xAxis").height;
                  }
                } else {
                  if (_predicate2["default"].isLegendAlignLeft(legendOption.align)) {
                    left = this.chartLeftPadding;
                  } else {
                    right = this.getDimension("chart").width - this.chartLeftPadding;
                    left = right - this.getDimension("legend").width;
                  }
                  if (_predicate2["default"].isBoxTypeChart(this.chartType)) {
                    top = seriesPosition.top;
                  } else {
                    top = seriesPosition.top + _const2["default"].MAP_CHART_ZOOM_AREA_HEIGHT * 0.75;
                  }
                }
                var position = {
                  top,
                  left
                };
                if (right) {
                  position.right = right;
                }
                return position;
              };
              BoundsModel2.prototype._makeChartExportMenuPosition = function _makeChartExportMenuPosition() {
                var top = this.getPosition("series").top - _const2["default"].SERIES_AREA_V_PADDING - _const2["default"].CHART_EXPORT_MENU_SIZE;
                return {
                  top,
                  right: _const2["default"].CHART_PADDING
                };
              };
              BoundsModel2.prototype._makeCircleLegendPosition = function _makeCircleLegendPosition() {
                var seriesPosition = this.getPosition("series");
                var seriesDimension = this.getDimension("series");
                var circleDimension = this.getDimension("circleLegend");
                var legendOptions = this.options.legend;
                var left = void 0, legendWidth = void 0;
                if (_predicate2["default"].isLegendAlignLeft(legendOptions.align)) {
                  left = 0;
                } else {
                  left = seriesPosition.left + seriesDimension.width;
                }
                if (_predicate2["default"].isVerticalLegend(legendOptions.align) && legendOptions.visible) {
                  legendWidth = this.getDimension("legend").width + _const2["default"].CHART_PADDING;
                  left += (legendWidth - circleDimension.width) / 2;
                }
                return {
                  top: seriesPosition.top + seriesDimension.height - circleDimension.height,
                  left
                };
              };
              BoundsModel2.prototype._isNeedExpansionSeries = function _isNeedExpansionSeries() {
                var chartType = this.chartType;
                return !(_predicate2["default"].isPieChart(chartType) || _predicate2["default"].isMapChart(chartType)) && !_predicate2["default"].isTreemapChart(chartType) && !_predicate2["default"].isRadialChart(chartType) && !_predicate2["default"].isPieDonutComboChart(chartType, this.seriesTypes);
              };
              BoundsModel2.prototype._registerEssentialComponentsPositions = function _registerEssentialComponentsPositions() {
                var seriesPosition = this.getPosition("series");
                var tooltipPosition = void 0;
                this.positionMap.mouseEventDetector = Object.assign({}, seriesPosition);
                this.positionMap.legend = this.useSpectrumLegend ? this._makeSpectrumLegendPosition() : this._makeLegendPosition();
                this.positionMap.chartExportMenu = this._makeChartExportMenuPosition();
                if (this.getDimension("circleLegend").width) {
                  this.positionMap.circleLegend = this._makeCircleLegendPosition();
                }
                if (this._isNeedExpansionSeries()) {
                  tooltipPosition = {
                    top: seriesPosition.top - _const2["default"].SERIES_EXPAND_SIZE,
                    left: seriesPosition.left - _const2["default"].SERIES_EXPAND_SIZE
                  };
                } else {
                  tooltipPosition = seriesPosition;
                }
                this.positionMap.tooltip = tooltipPosition;
              };
              BoundsModel2.prototype._registerPositions = function _registerPositions() {
                var _this2 = this;
                var alignOption = this.options.legend.align;
                var isVisibleLegend = this.options.legend.visible;
                var legendDimension = this.getDimension("legend");
                var isLegendAlignTop = _predicate2["default"].isLegendAlignTop(alignOption) && isVisibleLegend;
                var isLegendAlignLeft = _predicate2["default"].isLegendAlignLeft(alignOption) && isVisibleLegend;
                var topLegendHeight = isLegendAlignTop ? legendDimension.height : 0;
                var leftLegendWidth = isLegendAlignLeft ? legendDimension.width : 0;
                var titleOrExportMenuHeight = Math.max(this.getDimension("title").height, this.getDimension("chartExportMenu").height);
                var yAxisTitlePadding = function() {
                  if (_this2.options.yAxis.title && !_this2.useSpectrumLegend) {
                    var titlePadding = _renderUtil2["default"].getRenderedLabelHeight(_this2.options.yAxis.title, _this2.theme.yAxis.title);
                    return titlePadding + _const2["default"].Y_AXIS_TITLE_PADDING;
                  }
                  return 0;
                }();
                var seriesPadding = Math.max(0, Math.max(topLegendHeight, yAxisTitlePadding) - _const2["default"].TITLE_PADDING);
                var seriesTop = titleOrExportMenuHeight + seriesPadding;
                if (!titleOrExportMenuHeight) {
                  seriesTop = Math.max(topLegendHeight, yAxisTitlePadding);
                }
                var seriesPosition = {
                  top: seriesTop + _const2["default"].CHART_PADDING,
                  left: this.chartLeftPadding + leftLegendWidth + this.getDimension("yAxis").width
                };
                this.positionMap.series = seriesPosition;
                if (this.hasAxes) {
                  this._registerAxisComponentsPosition(leftLegendWidth);
                }
                this._registerEssentialComponentsPositions();
              };
              BoundsModel2.prototype._registerExtendedSeriesBound = function _registerExtendedSeriesBound() {
                var seriesBound = this.getBound("series");
                if (this._isNeedExpansionSeries()) {
                  seriesBound = _renderUtil2["default"].expandBound(seriesBound);
                }
                this._setBound("extendedSeries", seriesBound);
              };
              BoundsModel2.prototype._updateBoundsForYAxisCenterOption = function _updateBoundsForYAxisCenterOption() {
                var yAxisWidth = this.getDimension("yAxis").width;
                var yAxisExtensibleLeft = Math.floor(this.getDimension("series").width / 2) + _const2["default"].OVERLAPPING_WIDTH;
                var xAxisDecreasingLeft = yAxisWidth - _const2["default"].OVERLAPPING_WIDTH;
                var additionalLeft = _renderUtil2["default"].isOldBrowser() ? 1 : 0;
                this.dimensionMap.extendedSeries.width += yAxisWidth;
                this.dimensionMap.xAxis.width += _const2["default"].OVERLAPPING_WIDTH;
                this.dimensionMap.plot.width += yAxisWidth + _const2["default"].OVERLAPPING_WIDTH;
                this.dimensionMap.mouseEventDetector.width += yAxisWidth;
                this.dimensionMap.tooltip.width += yAxisWidth;
                this.positionMap.series.left -= yAxisWidth - additionalLeft;
                this.positionMap.extendedSeries.left -= xAxisDecreasingLeft - additionalLeft;
                this.positionMap.plot.left -= xAxisDecreasingLeft;
                this.positionMap.yAxis.left += yAxisExtensibleLeft;
                this.positionMap.xAxis.left -= xAxisDecreasingLeft;
                this.positionMap.mouseEventDetector.left -= xAxisDecreasingLeft;
                this.positionMap.tooltip.left -= xAxisDecreasingLeft;
              };
              BoundsModel2.prototype.registerBoundsData = function registerBoundsData(xAxisData) {
                this._registerCenterComponentsDimension();
                if (this.useSpectrumLegend) {
                  this._updateDimensionsForSpectrumLegend();
                }
                if (this.hasAxes) {
                  this._registerAxisComponentsDimension();
                  this._updateDimensionsForXAxisLabel(xAxisData);
                }
                this._registerPositions();
                this._registerExtendedSeriesBound();
                if (this.options.yAxis.isCenter) {
                  this._updateBoundsForYAxisCenterOption();
                }
              };
              BoundsModel2.prototype._updateDimensionsForSpectrumLegend = function _updateDimensionsForSpectrumLegend() {
                var legendAlignOption = this.options.legend.align;
                var legendDimension = this.getDimension("legend");
                var seriesDimension = this.getDimension("series");
                if (_predicate2["default"].isHorizontalLegend(legendAlignOption) && legendDimension.width > seriesDimension.width) {
                  legendDimension.width = seriesDimension.width;
                } else if (_predicate2["default"].isVerticalLegend(legendAlignOption)) {
                  if (_predicate2["default"].isBoxTypeChart(this.chartType)) {
                    legendDimension.height = seriesDimension.height;
                  } else if (legendDimension.height > seriesDimension.height - _const2["default"].MAP_CHART_ZOOM_AREA_HEIGHT) {
                    legendDimension.height = seriesDimension.height - _const2["default"].MAP_CHART_ZOOM_AREA_HEIGHT;
                  }
                }
              };
              BoundsModel2.prototype.calculateMaxRadius = function calculateMaxRadius(axisDataMap) {
                var dimensionMap = this.getDimensionMap(["series", "circleLegend"]);
                var circleLegendVisible = this.options.circleLegend ? this.options.circleLegend.visible : false;
                return _circleLegendCalculator2["default"].calculateMaxRadius(dimensionMap, axisDataMap, circleLegendVisible);
              };
              return BoundsModel2;
            }();
            exports2["default"] = BoundsModel;
          },
          /* 143 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            exports2["default"] = {
              /**
               * Calculate step of pixel unit.
               * @param {{tickCount: number, isLabelAxis: boolean}} axisData - data for rendering axis
               * @param {number} size - width or height of series area
               * @returns {number}
               * @private
               */
              _calculatePixelStep: function _calculatePixelStep(axisData, size) {
                var tickCount = axisData.tickCount;
                var pixelStep = void 0;
                if (axisData.isLabelAxis) {
                  pixelStep = size / tickCount / 2;
                } else {
                  pixelStep = size / (tickCount - 1);
                }
                return parseInt(pixelStep, 10);
              },
              /**
               * Calculate radius by axis data.
               * @param {{width: number, height: number}} seriesDimension - dimension for series
               * @param {{xAxis: object, yAxis: object}} axisDataMap - axis data map
               * @returns {number}
               * @private
               */
              _calculateRadiusByAxisData: function _calculateRadiusByAxisData(seriesDimension, axisDataMap) {
                var yPixelStep = this._calculatePixelStep(axisDataMap.yAxis, seriesDimension.height);
                var xPixelStep = this._calculatePixelStep(axisDataMap.xAxis, seriesDimension.width);
                return Math.min(yPixelStep, xPixelStep);
              },
              /**
               * Get max width of label for CircleLegend.
               * @param {string} maxLabel - maximum label
               * @param {string} fontFamily - fontFamily for legend
               * @returns {number}
               * @private
               */
              _getCircleLegendLabelMaxWidth: function _getCircleLegendLabelMaxWidth(maxLabel, fontFamily) {
                return _renderUtil2["default"].getRenderedLabelWidth(maxLabel, {
                  fontSize: _const2["default"].CIRCLE_LEGEND_LABEL_FONT_SIZE,
                  fontFamily
                });
              },
              /**
               * Calculate width for circle legend.
               * @param {{width: number, height: number}} seriesDimension - dimension for series
               * @param {{xAxis: object, yAxis: object}} axisDataMap - axis data map
               * @param {string} maxLabel - maximum label
               * @param {string} fontFamily - fontFamily for legend
               * @returns {number}
               */
              calculateCircleLegendWidth: function calculateCircleLegendWidth(seriesDimension, axisDataMap, maxLabel, fontFamily) {
                var maxRadius = this._calculateRadiusByAxisData(seriesDimension, axisDataMap);
                var maxLabelWidth = this._getCircleLegendLabelMaxWidth(maxLabel, fontFamily);
                return Math.max(maxRadius * 2, maxLabelWidth) + _const2["default"].CIRCLE_LEGEND_PADDING;
              },
              /**
               * Calculate max radius.
               * @param {{series: {width: number, height: number}, circleLegend: {width: number}}} dimensionMap - dimension map
               * @param {{xAxis: object, yAxis: object}} axisDataMap - axis data map
               * @param {boolean} [circleLegendVisible] - circleLegend visible option
               * @returns {number}
               */
              calculateMaxRadius: function calculateMaxRadius(dimensionMap, axisDataMap, circleLegendVisible) {
                var maxRadius = this._calculateRadiusByAxisData(dimensionMap.series, axisDataMap);
                var circleLegendWidth = dimensionMap.circleLegend.width;
                if (!circleLegendVisible) {
                  return maxRadius;
                }
                return Math.min((circleLegendWidth - _const2["default"].CIRCLE_LEGEND_PADDING) / 2, maxRadius);
              }
            };
          },
          /* 144 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            exports2["default"] = {
              /**
               * Calculate height for x axis.
               * @param {{title: string, labelMargin: number}} options - title and label margin option for x axis
               * @param {{title: object, label: object}} theme - theme for x axis
               * @returns {*}
               */
              calculateXAxisHeight: function calculateXAxisHeight(options, theme) {
                var title = options.title;
                var titleHeight = title ? _renderUtil2["default"].getRenderedLabelHeight(title.text, theme.title) : 0;
                var titleAreaHeight = titleHeight ? titleHeight + _const2["default"].X_AXIS_TITLE_PADDING : 0;
                var labelMargin = options.labelMargin || 0;
                var labelHeight = _renderUtil2["default"].getRenderedLabelHeight(_const2["default"].MAX_HEIGHT_WORD, theme.label);
                var height = titleAreaHeight + _const2["default"].X_AXIS_LABEL_PADDING;
                if (labelMargin > 0) {
                  height += labelMargin;
                }
                if (options.showLabel !== false) {
                  height += labelHeight;
                }
                return height;
              },
              /**
               * Calculate width for y axis.
               * @param {Array.<string | number>} labels labels
               * @param {{title: ?string, isCenter: ?boolean}} options - options
               * @param {{title: object, label: object}} theme - theme for y axis calculate
               * @param {Array} yAxisLabels - yAxis labels for y axis calculate
               * @param {boolean} isDiverging - whether is diverging chart or not
               * @returns {number}
               */
              calculateYAxisWidth: function calculateYAxisWidth(labels, options, theme, yAxisLabels, isDiverging) {
                var labelMargin = options.labelMargin, prefix = options.prefix, suffix = options.suffix, isCenter = options.isCenter, type = options.type, dateFormat = options.dateFormat, showLabel = options.showLabel, title = options.title, maxWidth = options.maxWidth;
                var titleWidth = 0;
                var maxLabelWidth = 0;
                var width = 0;
                labels = options.categories || labels;
                labels = _renderUtil2["default"].addPrefixSuffix(labels, prefix, suffix);
                yAxisLabels = _renderUtil2["default"].addPrefixSuffix(yAxisLabels, prefix, suffix);
                if (isCenter) {
                  width += _const2["default"].Y_AXIS_LABEL_PADDING;
                }
                if (_predicate2["default"].isDatetimeType(type)) {
                  labels = _renderUtil2["default"].formatDates(labels, dateFormat);
                  yAxisLabels = _renderUtil2["default"].formatDates(yAxisLabels, dateFormat);
                }
                if (labelMargin && labelMargin > 0) {
                  width += labelMargin;
                }
                labels = yAxisLabels.length ? yAxisLabels : labels;
                if (showLabel !== false) {
                  maxLabelWidth = _renderUtil2["default"].getRenderedLabelsMaxWidth(labels, theme.label, maxWidth);
                }
                if (title) {
                  titleWidth = _renderUtil2["default"].getRenderedLabelWidth(title.text, theme.title);
                }
                width += (isDiverging ? Math.max(maxLabelWidth, titleWidth) : maxLabelWidth) + _const2["default"].Y_AXIS_LABEL_PADDING;
                return width;
              }
            };
          },
          /* 145 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var LEGEND_CHECKBOX_SIZE = _const2["default"].LEGEND_CHECKBOX_SIZE, LEGEND_ICON_WIDTH = _const2["default"].LEGEND_ICON_WIDTH, LEGEND_LABEL_LEFT_PADDING = _const2["default"].LEGEND_LABEL_LEFT_PADDING, LEGEND_V_LABEL_RIGHT_PADDING = _const2["default"].LEGEND_V_LABEL_RIGHT_PADDING, LEGEND_H_LABEL_RIGHT_PADDING = _const2["default"].LEGEND_H_LABEL_RIGHT_PADDING, LEGEND_AREA_H_PADDING = _const2["default"].LEGEND_AREA_H_PADDING;
            exports2["default"] = {
              /**
               * Calculate sum of legends width.
               * @param {Array.<string>} labels - legend labels
               * @param {{fontSize: number, fontFamily: number}} labelTheme - legend label theme
               * @param {number} checkboxWidth - width for checkbox
               * @param {?number} [maxWidth] - user option legend maxWidth
               * @returns {number}
               * @private
               */
              _calculateLegendsWidth: function _calculateLegendsWidth(labels, labelTheme, checkboxWidth, maxWidth) {
                var restWidth = _calculator2["default"].sum([LEGEND_AREA_H_PADDING, checkboxWidth, LEGEND_ICON_WIDTH, LEGEND_LABEL_LEFT_PADDING]);
                return labels.map(function(label) {
                  var labelWidth = _renderUtil2["default"].getRenderedLabelWidth(label, labelTheme);
                  if (maxWidth && labelWidth > maxWidth) {
                    labelWidth = maxWidth;
                  }
                  labelWidth += restWidth;
                  return labelWidth + LEGEND_H_LABEL_RIGHT_PADDING;
                });
              },
              /**
               * Divide legend labels.
               * @param {Array.<string>} labels legend labels
               * @param {number} maxRowCount division limit count
               * @returns {Array.<Array.<string>>}
               * @private
               */
              _divideLegendLabels: function _divideLegendLabels(labels, maxRowCount) {
                var results = [];
                var temp = [];
                labels.forEach(function(label) {
                  if (temp.length < maxRowCount) {
                    temp.push(label);
                  } else {
                    results.push(temp);
                    temp = [label];
                  }
                });
                if (temp.length) {
                  results.push(temp);
                }
                return results;
              },
              /**
               * Get max line width.
               * @param {Array.<string>} dividedLabels - divided labels
               * @param {{fontFamily: ?string, fontSize: ?string}} labelTheme - label theme
               * @param {number} checkboxWidth - width for checkbox
               * @param {?number} [maxWidth] - user option legend maxWidth
               * @returns {number}
               * @private
               */
              _getLegendWidthInfo: function _getLegendWidthInfo(dividedLabels, labelTheme, checkboxWidth, maxWidth) {
                var _this = this;
                var labelWidthArr = [];
                var legendWidths = dividedLabels.map(function(labels) {
                  var legendLabelWidthArr = _this._calculateLegendsWidth(labels, labelTheme, checkboxWidth, maxWidth);
                  var legendWidth = _calculator2["default"].sum(legendLabelWidthArr);
                  labelWidthArr = labelWidthArr.concat(legendLabelWidthArr);
                  legendWidth = legendWidth - LEGEND_H_LABEL_RIGHT_PADDING + LEGEND_AREA_H_PADDING;
                  return legendWidth;
                });
                return {
                  labelWidthArr,
                  legendWidths
                };
              },
              /**
               * Make divided labels and max line width.
               * @param {Array.<string>} labels legend labels
               * @param {number} chartWidth chart width
               * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme
               * @param {number} checkboxWidth - width for checkbox
               * @param {?number} [maxWidth] - user option legend maxWidth
               * @returns {{dividedLabels: Array.<Array.<string>>, maxLineWidth: number}}
               * @private
               */
              _makeDividedLabelsAndMaxLineWidth: function _makeDividedLabelsAndMaxLineWidth(labels, chartWidth, labelTheme, checkboxWidth, maxWidth) {
                var maxRowCount = Number.MAX_VALUE;
                var divideCount = 1;
                var maxLineWidth = 0;
                var dividedLabels = void 0, lineWidths = void 0, labelWidths = void 0;
                do {
                  maxRowCount = Math.round(labels.length / divideCount);
                  dividedLabels = this._divideLegendLabels(labels, maxRowCount);
                  var legendWidthInfo = this._getLegendWidthInfo(dividedLabels, labelTheme, checkboxWidth, maxWidth);
                  lineWidths = legendWidthInfo.legendWidths;
                  labelWidths = legendWidthInfo.labelWidthArr;
                  maxLineWidth = _arrayUtil2["default"].max(lineWidths);
                  if (maxRowCount === 1) {
                    break;
                  }
                  divideCount += 1;
                } while (maxLineWidth >= chartWidth);
                maxLineWidth = Math.min(maxLineWidth, chartWidth);
                return {
                  labels: this._optimizedHorizontalLegendLabels(labels, labelWidths, maxLineWidth),
                  maxLineWidth
                };
              },
              /**
               * Make space optimized legend labels
               * @param {Array.<string>} labels - labels string
               * @param {Array.<number>} labelWidths - labels width
               * @param {number} maxLineWidth - max line width
               * @returns {Array.<Array.<string>>}
               * @private
               */
              _optimizedHorizontalLegendLabels: function _optimizedHorizontalLegendLabels(labels, labelWidths, maxLineWidth) {
                var optimizedDvidedLabels = [];
                var labelsLastIdx = labels.length - 1;
                var sum = 0;
                var temp = [];
                labels.forEach(function(label, labelIdx) {
                  var labelWidth = labelWidths[labelIdx];
                  var paddingWidth = LEGEND_AREA_H_PADDING - LEGEND_H_LABEL_RIGHT_PADDING;
                  var predictedLineWidth = sum + labelWidth + paddingWidth;
                  if (predictedLineWidth <= maxLineWidth) {
                    temp.push(label);
                  } else {
                    optimizedDvidedLabels.push(temp);
                    temp = [label];
                    sum = 0;
                  }
                  sum += labelWidth;
                  if (labelsLastIdx === labelIdx) {
                    optimizedDvidedLabels.push(temp);
                  }
                });
                return optimizedDvidedLabels;
              },
              /**
               * Calculate height of horizontal legend.
               * @param {Array.<Array.<string>>} dividedLabels - divided labels
               * @param {{fontSize: number, fontFamily: number}} labelTheme - label theme for legend
               * @returns {number}
               * @private
               */
              _calculateHorizontalLegendHeight: function _calculateHorizontalLegendHeight(dividedLabels, labelTheme) {
                var heightByLabel = Math.max.apply(null, dividedLabels.map(function(labels) {
                  return _renderUtil2["default"].getRenderedLabelsMaxHeight(labels, labelTheme);
                }));
                var labelItemHeightWithPaddingTop = _calculator2["default"].sum([Math.max(_const2["default"].LEGEND_CHECKBOX_SIZE, heightByLabel), _const2["default"].LINE_MARGIN_TOP]);
                var legendHeight = labelItemHeightWithPaddingTop * dividedLabels.length - _const2["default"].LINE_MARGIN_TOP + _const2["default"].SERIES_AREA_V_PADDING;
                return legendHeight;
              },
              /**
               * Make dimension of horizontal legend.
               * @param {{fontSize: number, fontFamily: number}} labelTheme - label theme for legend
               * @param {Array.<string>} legendLabels - labels for legend
               * @param {number} chartWidth - chart width
               * @param {number} checkboxWidth - width for checkbox
               * @param {?number} [maxWidth] - user option legend maxWidth
               * @returns {{width: number, height: (number)}}
               * @private
               */
              _makeHorizontalDimension: function _makeHorizontalDimension(labelTheme, legendLabels, chartWidth, checkboxWidth, maxWidth) {
                var dividedInfo = this._makeDividedLabelsAndMaxLineWidth(legendLabels, chartWidth, labelTheme, checkboxWidth, maxWidth);
                var horizontalLegendHeight = this._calculateHorizontalLegendHeight(dividedInfo.labels, labelTheme);
                var legendHeight = horizontalLegendHeight + _const2["default"].SERIES_AREA_V_PADDING;
                return {
                  width: Math.max(dividedInfo.maxLineWidth, _const2["default"].MIN_LEGEND_WIDTH),
                  height: legendHeight
                };
              },
              /**
               * Make dimension of vertical legend.
               * @param {{fontSize: number, fontFamily: number}} labelTheme - label theme for legend
               * @param {Array.<string>} legendLabels - labels for legend
               * @param {number} checkboxWidth - width for checkbox
               * @param {?number} [maxWidth] - user option legend maxWidth
               * @returns {{width: (number)}}
               * @private
               */
              _makeVerticalDimension: function _makeVerticalDimension(labelTheme, legendLabels, checkboxWidth, maxWidth) {
                var labelWidth = _renderUtil2["default"].getRenderedLabelsMaxWidth(legendLabels, labelTheme);
                var legendWidth = 0;
                if (maxWidth && labelWidth > maxWidth) {
                  labelWidth = maxWidth;
                }
                legendWidth = _calculator2["default"].sum([LEGEND_AREA_H_PADDING * 2, checkboxWidth, LEGEND_ICON_WIDTH, LEGEND_LABEL_LEFT_PADDING, labelWidth, LEGEND_V_LABEL_RIGHT_PADDING]);
                return {
                  width: legendWidth,
                  height: 0
                };
              },
              /**
               * Calculate legend dimension.
               * @param {{showCheckbox: boolean, visible: boolean, align: string}} options - options for legend
               * @param {{fontSize: number, fontFamily: number}} labelTheme - label theme for legend
               * @param {Array.<string>} legendLabels - labels for legend
               * @param {number} chartWidth chart width
               * @returns {{width: number, height: number}}
               */
              calculate: function calculate(options, labelTheme, legendLabels, chartWidth) {
                var checkboxWidth = options.showCheckbox === false ? 0 : LEGEND_CHECKBOX_SIZE + LEGEND_LABEL_LEFT_PADDING;
                var maxWidth = options.maxWidth;
                var dimension = {};
                if (!options.visible) {
                  dimension.width = 0;
                } else if (_predicate2["default"].isHorizontalLegend(options.align)) {
                  dimension = this._makeHorizontalDimension(labelTheme, legendLabels, chartWidth, checkboxWidth, maxWidth);
                } else {
                  dimension = this._makeVerticalDimension(labelTheme, legendLabels, checkboxWidth, maxWidth);
                }
                return dimension;
              }
            };
          },
          /* 146 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            exports2["default"] = {
              /**
               * Calculate width.
               * @param {{
               *      chart: {width: number},
               *      yAxis: {width: number},
               *      legend: {width: number},
               *      rightYAxis: ?{width: number}
               * }} dimensionMap - dimension map
               * @param {{align: ?string, visible: boolean}} legendOptions - legend options
               * @param {number} maxLabelWidth - max label width
               * @returns {number} series width
               */
              calculateWidth: function calculateWidth(dimensionMap, legendOptions, maxLabelWidth) {
                var chartWidth = dimensionMap.chart.width, yAxis = dimensionMap.yAxis, rightYAxis = dimensionMap.rightYAxis, legend = dimensionMap.legend;
                var yAxisAreaWidth = yAxis.width + rightYAxis.width;
                var legendDimension = legend;
                var legendWidth = 0;
                var xAxisLabelPadding = 0;
                if (_predicate2["default"].isVerticalLegend(legendOptions.align) && legendOptions.visible) {
                  legendWidth = legendDimension ? legendDimension.width : 0;
                }
                if (!legendWidth && !rightYAxis.width && maxLabelWidth) {
                  xAxisLabelPadding = maxLabelWidth / 2;
                }
                return chartWidth - _const2["default"].CHART_PADDING * 2 - yAxisAreaWidth - legendWidth - xAxisLabelPadding;
              },
              /**
               * Calculate height.
               * @param {{
               *      chart: {height: number},
               *      title: {height: number},
               *      legend: {height: number},
               *      xAxis: {height: number}
               * }} dimensionMap - dimension map
               * @param {{align: ?string, visible: boolean}} legendOptions - legend options
               * @param {number} yAxisTitleAreaHeight - yAxis title area height
               * @returns {number} series height
               */
              calculateHeight: function calculateHeight(dimensionMap, legendOptions, yAxisTitleAreaHeight) {
                var chartHeight = dimensionMap.chart.height;
                var titleHeight = Math.max(dimensionMap.title.height, dimensionMap.chartExportMenu.height);
                var legendHeight = legendOptions.visible ? dimensionMap.legend.height : 0;
                var topLegendHeight = _predicate2["default"].isLegendAlignTop(legendOptions.align) ? legendHeight : 0;
                var topAreaPadding = Math.max(0, Math.max(yAxisTitleAreaHeight, topLegendHeight) - _const2["default"].TITLE_PADDING);
                var topAreaHeight = titleHeight + topAreaPadding;
                var bottomLegendHeight = _predicate2["default"].isLegendAlignBottom(legendOptions.align) ? legendHeight : 0;
                var bottomAreaHeight = dimensionMap.xAxis.height + bottomLegendHeight;
                return chartHeight - _const2["default"].CHART_PADDING * 2 - topAreaHeight - bottomAreaHeight;
              }
            };
          },
          /* 147 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var MAP_LEGEND_TOOLTIP_HORIZONTAL_PADDING = _const2["default"].MAP_LEGEND_TOOLTIP_HORIZONTAL_PADDING, MAP_LEGEND_WEDGE_SIZE = _const2["default"].MAP_LEGEND_WEDGE_SIZE, MAP_LEGEND_AREA_PADDING_WIDE = _const2["default"].MAP_LEGEND_AREA_PADDING_WIDE, MAP_LEGEND_PADDING_BTW_GRAPH_AND_WEDGE = _const2["default"].MAP_LEGEND_PADDING_BTW_GRAPH_AND_WEDGE, MAP_LEGEND_GRAPH_SIZE = _const2["default"].MAP_LEGEND_GRAPH_SIZE, MAP_LEGEND_LABEL_PADDING = _const2["default"].MAP_LEGEND_LABEL_PADDING, VERTICAL_MAP_LEGEND_HEIGHT = _const2["default"].VERTICAL_MAP_LEGEND_HEIGHT, MAP_LEGEND_TOOLTIP_VERTICAL_PADDING = _const2["default"].MAP_LEGEND_TOOLTIP_VERTICAL_PADDING, MAP_LEGEND_AREA_PADDING_NARROW = _const2["default"].MAP_LEGEND_AREA_PADDING_NARROW, HORIZONTAL_MAP_LEGEND_WIDTH = _const2["default"].HORIZONTAL_MAP_LEGEND_WIDTH;
            exports2["default"] = {
              /**
               * Make vertical dimension.
               * @param {string} maxValue - formatted max value
               * @param {string} minValue - formatted min value
               * @param {object} labelTheme - theme for label
               * @returns {{width: number, height: number}}
               * @private
               */
              _makeVerticalDimension: function _makeVerticalDimension(maxValue, minValue, labelTheme) {
                var maxValueLabelWidth = _renderUtil2["default"].getRenderedLabelWidth(maxValue, labelTheme);
                var minValueLabelWidth = _renderUtil2["default"].getRenderedLabelWidth(minValue, labelTheme);
                var labelWidth = _renderUtil2["default"].getRenderedLabelWidth(maxValue, labelTheme);
                var tooltipWidth = _calculator2["default"].sum([MAP_LEGEND_TOOLTIP_HORIZONTAL_PADDING * 2, labelWidth, MAP_LEGEND_WEDGE_SIZE]);
                return {
                  width: _calculator2["default"].sum([MAP_LEGEND_AREA_PADDING_WIDE, tooltipWidth, MAP_LEGEND_PADDING_BTW_GRAPH_AND_WEDGE, MAP_LEGEND_GRAPH_SIZE, MAP_LEGEND_LABEL_PADDING, Math.max(maxValueLabelWidth, minValueLabelWidth)]),
                  height: VERTICAL_MAP_LEGEND_HEIGHT
                };
              },
              /**
               * Make horizontal dimension.
               * @param {string} maxValue - formatted max value
               * @param {object} labelTheme - theme for label
               * @param {boolean} isBoxType - whether use narrow padding or not
               * @param {boolean} isTopLegend - whether use top legend or not
               * @returns {{width: number, height: number}}
               * @private
               */
              _makeHorizontalDimension: function _makeHorizontalDimension(maxValue, labelTheme, isBoxType, isTopLegend) {
                var labelHeight = _renderUtil2["default"].getRenderedLabelHeight(maxValue, labelTheme);
                var tooltipHeight = _calculator2["default"].sum([MAP_LEGEND_TOOLTIP_VERTICAL_PADDING * 2, labelHeight, MAP_LEGEND_WEDGE_SIZE]);
                var padding = isBoxType ? MAP_LEGEND_AREA_PADDING_NARROW : MAP_LEGEND_AREA_PADDING_WIDE;
                var additionalTopPadding = isTopLegend ? MAP_LEGEND_AREA_PADDING_WIDE : 0;
                return {
                  width: HORIZONTAL_MAP_LEGEND_WIDTH,
                  height: _calculator2["default"].sum([padding, tooltipHeight, MAP_LEGEND_PADDING_BTW_GRAPH_AND_WEDGE, MAP_LEGEND_GRAPH_SIZE, MAP_LEGEND_LABEL_PADDING, labelHeight, MAP_LEGEND_LABEL_PADDING, additionalTopPadding])
                };
              }
            };
          },
          /* 148 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isArray = __webpack_require__(9);
            var _isArray2 = _interopRequireDefault(_isArray);
            var _isNull = __webpack_require__(6);
            var _isNull2 = _interopRequireDefault(_isNull);
            var _scaleDataMaker = __webpack_require__(149);
            var _scaleDataMaker2 = _interopRequireDefault(_scaleDataMaker);
            var _scaleLabelFormatter = __webpack_require__(151);
            var _scaleLabelFormatter2 = _interopRequireDefault(_scaleLabelFormatter);
            var _axisDataMaker = __webpack_require__(152);
            var _axisDataMaker2 = _interopRequireDefault(_axisDataMaker);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var ScaleDataModel = function() {
              function ScaleDataModel2(params) {
                _classCallCheck(this, ScaleDataModel2);
                this.chartType = params.chartType;
                this.seriesTypes = params.seriesTypes;
                this.dataProcessor = params.dataProcessor;
                this.boundsModel = params.boundsModel;
                this.options = params.options;
                this.theme = params.theme;
                this.hasRightYAxis = !!params.hasRightYAxis;
                this.prevValidLabelCount = null;
                this.initScaleData(params.addedDataCount);
                this.initForAutoTickInterval();
              }
              ScaleDataModel2.prototype.initScaleData = function initScaleData(addedDataCount) {
                this.scaleDataMap = {};
                this.axisDataMap = {};
                this.addedDataCount = addedDataCount;
              };
              ScaleDataModel2.prototype.initForAutoTickInterval = function initForAutoTickInterval() {
                this.firstTickCount = null;
              };
              ScaleDataModel2.prototype._pickLimitOption = function _pickLimitOption(axisOptions) {
                axisOptions = axisOptions || {};
                return {
                  min: axisOptions.min,
                  max: axisOptions.max
                };
              };
              ScaleDataModel2.prototype._createBaseScaleData = function _createBaseScaleData(typeMap, baseOptions, axisOptions, additionalOptions) {
                var chartType = typeMap.chartType;
                var isVertical = typeMap.areaType !== "xAxis";
                var baseValues = this.dataProcessor.createBaseValuesForLimit(chartType, additionalOptions.isSingleYAxis, baseOptions.stack, typeMap.valueType, typeMap.areaType);
                var baseSize = this.boundsModel.getBaseSizeForLimit(isVertical);
                var options = Object.assign(baseOptions, {
                  isVertical,
                  limitOption: this._pickLimitOption(axisOptions),
                  tickCounts: additionalOptions.tickCounts,
                  showLabel: this.options.series.showLabel
                });
                if (_predicate2["default"].isBubbleChart(chartType)) {
                  options.overflowItem = this.dataProcessor.findOverflowItem(chartType, typeMap.valueType);
                }
                if (_predicate2["default"].isMapChart(chartType) || _predicate2["default"].isHeatmapChart(chartType) || _predicate2["default"].isTreemapChart(chartType)) {
                  options.useSpectrumLegend = true;
                }
                return _scaleDataMaker2["default"].makeScaleData(baseValues, baseSize, chartType, options);
              };
              ScaleDataModel2.prototype._createScaleLabels = function _createScaleLabels(baseScaleData, typeMap, baseOptions, dateFormat) {
                var formatFunctions = this.dataProcessor.getFormatFunctions();
                var options = Object.assign(baseOptions, {
                  dateFormat
                });
                return _scaleLabelFormatter2["default"].createFormattedLabels(baseScaleData, typeMap, options, formatFunctions);
              };
              ScaleDataModel2.prototype._createScaleData = function _createScaleData(axisOptions, typeMap, additionalOptions) {
                var seriesOptions = this.options.series;
                var chartType = typeMap.chartType || this.chartType;
                typeMap.chartType = chartType;
                seriesOptions = seriesOptions[chartType] || seriesOptions;
                var baseOptions = {
                  stack: additionalOptions.stack || seriesOptions.stack,
                  diverging: seriesOptions.diverging,
                  type: axisOptions.type
                };
                var baseScaleData = this._createBaseScaleData(typeMap, baseOptions, axisOptions, additionalOptions);
                return Object.assign(baseScaleData, {
                  labels: this._createScaleLabels(baseScaleData, typeMap, baseOptions, axisOptions.dateFormat),
                  axisOptions
                });
              };
              ScaleDataModel2.prototype._createValueAxisData = function _createValueAxisData(scaleData, labelTheme, aligned, isVertical, isPositionRight) {
                var hasCategories = this.dataProcessor.hasCategories();
                var isCoordinateLineType = !isVertical && !hasCategories && aligned;
                var labels = scaleData.labels, limit = scaleData.limit, step = scaleData.step;
                var tickCount = labels.length;
                var axisData = _axisDataMaker2["default"].makeValueAxisData({
                  labels,
                  tickCount: labels.length,
                  limit,
                  step,
                  labelTheme,
                  aligned,
                  options: scaleData.axisOptions,
                  isVertical: !!isVertical,
                  isPositionRight: !!isPositionRight
                });
                if (isCoordinateLineType) {
                  var values = this.dataProcessor.getValues(this.chartType, "x");
                  var additional = _axisDataMaker2["default"].makeAdditionalDataForCoordinateLineType(labels, values, limit, step, tickCount);
                  Object.assign(axisData, additional);
                }
                return axisData;
              };
              ScaleDataModel2.prototype._createLabelAxisData = function _createLabelAxisData(axisOptions, labelTheme, aligned, isVertical, isPositionRight) {
                var labels = axisOptions.categories || this.dataProcessor.getCategories(isVertical);
                return _axisDataMaker2["default"].makeLabelAxisData({
                  labels,
                  options: axisOptions,
                  labelTheme,
                  aligned,
                  isVertical: !!isVertical,
                  isPositionRight: !!isPositionRight,
                  addedDataCount: this.options.series.shifting ? this.addedDataCount : 0
                });
              };
              ScaleDataModel2.prototype._createAxisData = function _createAxisData(scaleData, axisOptions, labelTheme, isVertical, isPositionRight) {
                var aligned = _predicate2["default"].isLineTypeChart(this.chartType, this.seriesTypes) && !axisOptions.pointOnColumn;
                var axisData = void 0;
                if (scaleData) {
                  axisData = this._createValueAxisData(scaleData, labelTheme, aligned, isVertical, isPositionRight);
                } else {
                  axisData = this._createLabelAxisData(axisOptions, labelTheme, aligned, isVertical, isPositionRight);
                }
                return axisData;
              };
              ScaleDataModel2.prototype._createAxesData = function _createAxesData() {
                var scaleDataMap = this.scaleDataMap, options = this.options, theme = this.theme;
                var yAxisOptions = (0, _isArray2["default"])(options.yAxis) ? options.yAxis : [options.yAxis];
                var dataMap = {};
                dataMap.xAxis = this._createAxisData(scaleDataMap.xAxis, options.xAxis, theme.xAxis.label);
                dataMap.yAxis = this._createAxisData(scaleDataMap.yAxis, yAxisOptions[0], theme.yAxis.label, true);
                if (this.hasRightYAxis) {
                  dataMap.rightYAxis = this._createAxisData(scaleDataMap.rightYAxis, yAxisOptions[1], theme.yAxis.label, true, true);
                  if (!dataMap.rightYAxis.aligned) {
                    dataMap.rightYAxis.aligned = dataMap.yAxis.aligned;
                  }
                }
                return dataMap;
              };
              ScaleDataModel2.prototype.addScale = function addScale(axisName, axisOptions) {
                var typeMap = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                var additionalOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
                typeMap.areaType = typeMap.areaType || axisName;
                typeMap.chartType = additionalOptions.chartType || typeMap.chartType;
                this.scaleDataMap[axisName] = this._createScaleData(axisOptions, typeMap, additionalOptions);
              };
              ScaleDataModel2.prototype.setAxisDataMap = function setAxisDataMap() {
                this.axisDataMap = this._createAxesData();
              };
              ScaleDataModel2.prototype.updateXAxisDataForAutoTickInterval = function updateXAxisDataForAutoTickInterval(prevXAxisData, addingDataMode) {
                var shiftingOption = this.options.series.shifting;
                var zoomableOption = this.options.series.zoomable;
                var xAxisData = this.axisDataMap.xAxis;
                var seriesWidth = this.boundsModel.getDimension("series").width;
                var addedCount = this.addedDataCount;
                if (shiftingOption || !prevXAxisData || zoomableOption) {
                  _axisDataMaker2["default"].updateLabelAxisDataForAutoTickInterval(xAxisData, seriesWidth, addedCount, addingDataMode);
                } else {
                  _axisDataMaker2["default"].updateLabelAxisDataForStackingDynamicData(xAxisData, prevXAxisData, this.firstTickCount);
                }
                if (!this.firstTickCount) {
                  this.firstTickCount = xAxisData.tickCount;
                }
              };
              ScaleDataModel2.prototype.updateXAxisDataForLabel = function updateXAxisDataForLabel(addingDataMode) {
                var axisData = this.axisDataMap.xAxis;
                var dimensionMap = this.boundsModel.getDimensionMap(["series", "yAxis", "chart"]);
                var isLabelAxis = axisData.isLabelAxis;
                var theme = this.theme.xAxis.label;
                var validLabelCount = void 0, additionalData = void 0;
                var labels = axisData.labels;
                if (addingDataMode) {
                  labels = labels.slice(0, labels.length - 1);
                }
                labels = _renderUtil2["default"].addPrefixSuffix(labels, this.options.xAxis.prefix, this.options.xAxis.suffix);
                var validLabels = labels.filter(function(label) {
                  return label;
                });
                if (!(0, _isNull2["default"])(this.prevValidLabelCount)) {
                  validLabelCount = this.prevValidLabelCount;
                } else {
                  validLabelCount = validLabels.length;
                }
                if (this.options.yAxis.isCenter) {
                  validLabelCount += 1;
                  dimensionMap.yAxis.width = 0;
                }
                if (axisData.options.rotateLabel === false) {
                  additionalData = _axisDataMaker2["default"].makeAdditionalDataForMultilineLabels(labels, validLabelCount, theme, isLabelAxis, dimensionMap);
                } else {
                  additionalData = _axisDataMaker2["default"].makeAdditionalDataForRotatedLabels(validLabels, validLabelCount, theme, isLabelAxis, dimensionMap);
                }
                this.prevValidLabelCount = validLabelCount;
                Object.assign(axisData, additionalData);
              };
              ScaleDataModel2.prototype._findLimit = function _findLimit(limitMap, seriesIndex, isVertical) {
                var limit = void 0;
                if (seriesIndex === 0) {
                  limit = isVertical ? limitMap.yAxis : limitMap.xAxis;
                } else {
                  limit = limitMap.rightYAxis ? limitMap.rightYAxis : limitMap.yAxis;
                }
                return limit;
              };
              ScaleDataModel2.prototype.makeLimitMap = function makeLimitMap(seriesTypes, isVertical) {
                var _this = this;
                var scaleDataMap = this.scaleDataMap;
                var limitMap = {};
                if (scaleDataMap.xAxis) {
                  limitMap.xAxis = scaleDataMap.xAxis.limit;
                }
                if (scaleDataMap.yAxis) {
                  limitMap.yAxis = scaleDataMap.yAxis.limit;
                }
                if (scaleDataMap.rightYAxis) {
                  limitMap.rightYAxis = scaleDataMap.rightYAxis.limit;
                }
                if (scaleDataMap.legend) {
                  limitMap.legend = scaleDataMap.legend.limit;
                }
                seriesTypes.forEach(function(seriesType, index) {
                  limitMap[seriesType] = _this._findLimit(limitMap, index, isVertical);
                });
                return limitMap;
              };
              return ScaleDataModel2;
            }();
            exports2["default"] = ScaleDataModel;
          },
          /* 149 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            var _coordinateScaleCalculator = __webpack_require__(150);
            var _coordinateScaleCalculator2 = _interopRequireDefault(_coordinateScaleCalculator);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var scaleDataMaker = {
              /**
               * Make limit for diverging option.
               * To balance diverging chart
               * compare absolute value of min, max. and find larger one
               * set min by making the value negative
               * @param {{min: number, max: number}} limit limit
               * @returns {{min: number, max: number}} changed limit
               * @private
               */
              _makeLimitForDivergingOption: function _makeLimitForDivergingOption(limit) {
                var newMax = Math.max(Math.abs(limit.min), Math.abs(limit.max));
                return {
                  min: -newMax,
                  max: newMax
                };
              },
              /**
               * Adjust limit for bubble chart.
               * @param {{min: number, max: number}} limit - limit
               * @param {number} step - step;
               * @param {{min: boolean, max: boolean}} isOverflowed - overflow Item map
               * @returns {object} limit
               * @private
               */
              _adjustLimitForOverflow: function _adjustLimitForOverflow(limit, step, isOverflowed) {
                var min = limit.min, max = limit.max;
                if (isOverflowed.min) {
                  min = _calculator2["default"].subtract(min, step);
                }
                if (isOverflowed.max) {
                  max = _calculator2["default"].add(max, step);
                }
                return {
                  min,
                  max
                };
              },
              /**
               * millisecond map
               */
              millisecondMap: {
                year: 31536e6,
                month: 26784e5,
                week: 6048e5,
                date: 864e5,
                hour: 36e5,
                minute: 6e4,
                second: 1e3
              },
              /**
               * millisecond types
               */
              millisecondTypes: ["year", "month", "week", "date", "hour", "minute", "second"],
              /**
               * Find date type.
               * @param {{min: number, max: number}} dataLimit - data limit
               * @param {number} count - data count
               * @returns {string}
               * @private
               */
              _findDateType: function _findDateType(dataLimit, count) {
                var diff = dataLimit.max - dataLimit.min;
                var millisecondTypes = this.millisecondTypes, millisecondMap = this.millisecondMap;
                var lastTypeIndex = millisecondTypes.length - 1;
                var foundType = void 0;
                if (diff) {
                  millisecondTypes.every(function(type, index) {
                    var millisecond = millisecondMap[type];
                    var dividedCount = Math.floor(diff / millisecond);
                    var foundIndex = void 0;
                    if (dividedCount) {
                      foundIndex = index < lastTypeIndex && dividedCount < 2 && dividedCount < count ? index + 1 : index;
                      foundType = millisecondTypes[foundIndex];
                    }
                    return !(0, _isExisty2["default"])(foundIndex);
                  });
                } else {
                  foundType = _const2["default"].DATE_TYPE_SECOND;
                }
                return foundType;
              },
              /**
               * Make datetime information
               * @param {{min: number, max: number}} dataLimit - data limit
               * @param {number} count - data count
               * @returns {{divisionNumber: number, minDate: number, dataLimit: {min: number, max: number}}}
               * @private
               */
              _makeDatetimeInfo: function _makeDatetimeInfo(dataLimit, count) {
                var dateType = this._findDateType(dataLimit, count);
                var divisionNumber = this.millisecondMap[dateType];
                var minDate = _calculator2["default"].divide(dataLimit.min, divisionNumber);
                var maxDate = _calculator2["default"].divide(dataLimit.max, divisionNumber);
                var max = maxDate - minDate;
                return {
                  divisionNumber,
                  minDate,
                  dataLimit: {
                    min: 0,
                    max
                  }
                };
              },
              /**
               * Restore scale to datetime type.
               * @param {{scale: number, limit:{min: number, max: number}}} scale - scale
               * @param {number} minDate - minimum date
               * @param {number} divisionNumber - division number
               * @returns {{step: number, limit: {min: number, max: number}}}
               * @private
               */
              _restoreScaleToDatetimeType: function _restoreScaleToDatetimeType(scale, minDate, divisionNumber) {
                var limit = scale.limit;
                scale.step = _calculator2["default"].multiply(scale.step, divisionNumber);
                limit.min = _calculator2["default"].multiply(_calculator2["default"].add(limit.min, minDate), divisionNumber);
                limit.max = _calculator2["default"].multiply(_calculator2["default"].add(limit.max, minDate), divisionNumber);
                return scale;
              },
              /**
               * Get limit values safely by limit values are both Zero then set max value to 10 temporary.
               * @param {Array} baseValues base values
               * @returns {{min: number, max: number}}
               */
              _getLimitSafely: function _getLimitSafely(baseValues) {
                var limit = {
                  min: _arrayUtil2["default"].min(baseValues),
                  max: _arrayUtil2["default"].max(baseValues)
                };
                if (baseValues.length === 1) {
                  var _baseValues = _slicedToArray(baseValues, 1), firstValue = _baseValues[0];
                  if (firstValue > 0) {
                    limit.min = 0;
                  } else if (firstValue === 0) {
                    limit.max = 10;
                  } else {
                    limit.max = 0;
                  }
                } else if (limit.min === 0 && limit.max === 0) {
                  limit.max = 10;
                } else if (limit.min === limit.max) {
                  limit.min -= limit.min / 10;
                  limit.max += limit.max / 10;
                }
                return limit;
              },
              /**
               * Calculate date time scale.
               * @param {Array.<number>} baseValues - base values for calculating scale data
               * @param {number} baseSize - base size(width or height) for calculating scale data
               * @param {boolean} isDiverging - is diverging or not
               * @returns {{limit: {min: number, max: number}, step: number}}
               * @private
               */
              _calculateDatetimeScale: function _calculateDatetimeScale(baseValues, baseSize, isDiverging) {
                var datetimeInfo = this._makeDatetimeInfo(this._getLimitSafely(baseValues), baseValues.length);
                var limit = datetimeInfo.dataLimit;
                if (isDiverging) {
                  limit = this._makeLimitForDivergingOption(limit);
                }
                var scale = (0, _coordinateScaleCalculator2["default"])({
                  min: limit.min,
                  max: limit.max,
                  offsetSize: baseSize,
                  minimumStepSize: 1
                });
                scale = this._restoreScaleToDatetimeType(scale, datetimeInfo.minDate, datetimeInfo.divisionNumber);
                return scale;
              },
              /**
               * Calculate percent stackType scale.
               * @param {Array.<number>} baseValues - base values
               * @param {boolean} isDiverging - is diverging or not
               * @returns {{limit: {min:number, max:number}, step: number}}
               * @private
               */
              _calculatePercentStackedScale: function _calculatePercentStackedScale(baseValues, isDiverging) {
                var scale = void 0;
                if (_calculator2["default"].sumMinusValues(baseValues) === 0) {
                  scale = _const2["default"].PERCENT_STACKED_AXIS_SCALE;
                } else if (_calculator2["default"].sumPlusValues(baseValues) === 0) {
                  scale = _const2["default"].MINUS_PERCENT_STACKED_AXIS_SCALE;
                } else if (isDiverging) {
                  scale = _const2["default"].DIVERGING_PERCENT_STACKED_AXIS_SCALE;
                } else {
                  scale = _const2["default"].DUAL_PERCENT_STACKED_AXIS_SCALE;
                }
                return scale;
              },
              /**
               * Calculate coordinate scale.
               * @param {object} makeScaleInfos - calculate scale infos
               *     @param {Array.<number>} makeScaleInfos.baseValues - base values
               *     @param {number} makeScaleInfos.baseSize - base size(width or height) for calculating scale data
               *     @param {object} makeScaleInfos.overflowItem - overflow item
               *     @param {boolean} makeScaleInfos.isDiverging - is diverging or not
               *     @param {strint} makeScaleInfos.chartType - chartType
               *     @param {object} makeScaleInfos.options - scale options
               *         @param {{min: ?number, max: ?number}} makeScaleInfos.options.limit - limit options
               * @returns {{limit: {min:number, max:number}, step: number}}
               * @private
               */
              _calculateCoordinateScale: function _calculateCoordinateScale(makeScaleInfos) {
                var _makeScaleInfos$optio = makeScaleInfos.options, _makeScaleInfos$optio2 = _makeScaleInfos$optio.limitOption, limitOption = _makeScaleInfos$optio2 === void 0 ? {} : _makeScaleInfos$optio2, useSpectrumLegend = _makeScaleInfos$optio.useSpectrumLegend, baseSize = makeScaleInfos.baseSize, overflowItem = makeScaleInfos.overflowItem, chartType = makeScaleInfos.chartType;
                var limit = this._getLimitSafely(makeScaleInfos.baseValues);
                var hasMinOption = (0, _isExisty2["default"])(limitOption.min);
                var hasMaxOption = (0, _isExisty2["default"])(limitOption.max);
                var min = limit.min, max = limit.max;
                var isOverflowed = void 0;
                var stepCount = makeScaleInfos.options.stepCount;
                if (hasMinOption) {
                  min = limitOption.min;
                  stepCount = null;
                }
                if (hasMaxOption) {
                  max = limitOption.max;
                  stepCount = null;
                }
                var scaleData = (0, _coordinateScaleCalculator2["default"])({
                  min,
                  max,
                  stepCount,
                  offsetSize: baseSize
                });
                if (!useSpectrumLegend) {
                  isOverflowed = this._isOverflowed(overflowItem, scaleData, limit, hasMinOption, hasMaxOption);
                }
                if (isOverflowed && !_predicate2["default"].isMapTypeChart(chartType)) {
                  scaleData.limit = this._adjustLimitForOverflow(scaleData.limit, scaleData.step, isOverflowed);
                }
                if (makeScaleInfos.isDiverging) {
                  scaleData.limit = this._makeLimitForDivergingOption(scaleData.limit);
                }
                return scaleData;
              },
              _isOverflowed: function _isOverflowed(overflowItem, scaleData, limit, hasMinOption, hasMaxOption) {
                var isBubbleMinOverflowed = !!(overflowItem && overflowItem.minItem);
                var isBubbleMaxOverflowed = !!(overflowItem && overflowItem.maxItem);
                var scaleDataLimit = scaleData.limit;
                var isOverflowedMin = isBubbleMinOverflowed || !hasMinOption && scaleDataLimit.min === limit.min && scaleDataLimit.min !== 0;
                var isOverflowedMax = isBubbleMaxOverflowed || !hasMaxOption && scaleDataLimit.max === limit.max && scaleDataLimit.max !== 0;
                if (!isOverflowedMin && !isOverflowedMax) {
                  return null;
                }
                return {
                  min: isOverflowedMin,
                  max: isOverflowedMax
                };
              },
              /**
               * Make scale data.
               * @param {Array.<number>} baseValues - base values for calculating scale data
               * @param {number} baseSize - base size(width or height) for calculating scale data
               * @param {string} chartType - chart type
               * @param {{
               *      type: string,
               *      stack: string,
               *      diverging: boolean,
               *      isVertical: boolean,
               *      limitOption: ?{min: ?number, max: ?number},
               *      tickCounts: ?Array.<number>
               * }} options - options
               * @returns {{limit: {min:number, max:number}, step: number, stepCount: number}}
               */
              makeScaleData: function makeScaleData(baseValues, baseSize, chartType, options) {
                var scaleData = void 0;
                var isDiverging = _predicate2["default"].isDivergingChart(chartType, options.diverging);
                var overflowItem = options.overflowItem;
                if (_predicate2["default"].isPercentStackChart(chartType, options.stack)) {
                  scaleData = this._calculatePercentStackedScale(baseValues, isDiverging);
                } else if (_predicate2["default"].isDatetimeType(options.type)) {
                  scaleData = this._calculateDatetimeScale(baseValues, baseSize, isDiverging);
                } else {
                  if (_predicate2["default"].isRadialChart(chartType)) {
                    options.stepCount = Math.floor(baseSize / 100);
                  }
                  scaleData = this._calculateCoordinateScale({
                    baseValues,
                    baseSize,
                    overflowItem,
                    isDiverging,
                    chartType,
                    options
                  });
                }
                return scaleData;
              }
            };
            exports2["default"] = scaleDataMaker;
          },
          /* 150 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isNumber = __webpack_require__(19);
            var _isNumber2 = _interopRequireDefault(_isNumber);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var SNAP_VALUES = [1, 2, 5, 10];
            var DEFAULT_PIXELS_PER_STEP = 88;
            function getDigits(number) {
              var logNumberDividedLN10 = number === 0 ? 1 : Math.log(Math.abs(number)) / Math.LN10;
              return Math.pow(10, Math.floor(logNumberDividedLN10));
            }
            function getSnappedNumber(number) {
              var snapNumber = void 0;
              for (var i = 0, t = SNAP_VALUES.length; i < t; i += 1) {
                snapNumber = SNAP_VALUES[i];
                var guideValue = (snapNumber + (SNAP_VALUES[i + 1] || snapNumber)) / 2;
                if (number <= guideValue) {
                  break;
                }
              }
              return snapNumber;
            }
            function getNormalizedStep(step) {
              var placeNumber = getDigits(step);
              var simplifiedStepValue = step / placeNumber;
              return getSnappedNumber(simplifiedStepValue) * placeNumber;
            }
            function getNormalizedLimit(min, max, step, showLabel) {
              var minNumber = Math.min(getDigits(max), getDigits(step));
              var placeNumber = minNumber > 1 ? 1 : 1 / minNumber;
              var fixedStep = step * placeNumber;
              var noExtraMax = max;
              var isNotEnoughSize = false;
              max = Math.ceil(max * placeNumber / fixedStep) * fixedStep / placeNumber;
              isNotEnoughSize = fixedStep / 2 > max - noExtraMax;
              if (showLabel && isNotEnoughSize) {
                max += fixedStep;
              }
              if (min > step) {
                min = Math.floor(min * placeNumber / fixedStep) * fixedStep / placeNumber;
              } else if (min < 0) {
                min = -(Math.ceil(Math.abs(min) * placeNumber / fixedStep) * fixedStep) / placeNumber;
              } else {
                min = 0;
              }
              return {
                min,
                max
              };
            }
            function getNormalizedStepCount(limitSize, step) {
              var multiplier = 1 / Math.min(getDigits(limitSize), getDigits(step));
              return Math.ceil(limitSize * multiplier / (step * multiplier));
            }
            function getNormalizedScale(scale, showLabel) {
              var step = getNormalizedStep(scale.step);
              var edge = getNormalizedLimit(scale.limit.min, scale.limit.max, step, showLabel);
              var limitSize = Math.abs(edge.max - edge.min);
              var stepCount = getNormalizedStepCount(limitSize, step);
              return {
                limit: {
                  min: edge.min,
                  max: edge.max
                },
                step,
                stepCount
              };
            }
            function getRoughScale(min, max, offsetSize, stepCount, minimumStepSize) {
              var limitSize = Math.abs(max - min);
              var valuePerPixel = limitSize / offsetSize;
              if (!stepCount) {
                stepCount = Math.ceil(offsetSize / DEFAULT_PIXELS_PER_STEP);
              }
              var pixelsPerStep = offsetSize / stepCount;
              var step = valuePerPixel * pixelsPerStep;
              if ((0, _isNumber2["default"])(minimumStepSize) && step < minimumStepSize) {
                step = minimumStepSize;
                stepCount = limitSize / step;
              }
              return {
                limit: {
                  min,
                  max
                },
                step,
                stepCount
              };
            }
            function coordinateScaleCalculator(options) {
              var min = options.min, max = options.max, offsetSize = options.offsetSize, stepCount = options.stepCount, minimumStepSize = options.minimumStepSize, showLabel = options.showLabel;
              var scale = getRoughScale(min, max, offsetSize, stepCount, minimumStepSize);
              scale = getNormalizedScale(scale, showLabel);
              return scale;
            }
            exports2["default"] = coordinateScaleCalculator;
          },
          /* 151 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var scaleLabelFormatter = {
              /**
               * Get functions for formatting value.
               * @param {string} chartType - chart type
               * @param {object} stack - stack options
               * @param {?Array.<function>} formatFunctions - format functions
               * @returns {Array.<function>}
               * @private
               */
              _getFormatFunctions: function _getFormatFunctions(chartType, stack, formatFunctions) {
                if (_predicate2["default"].isPercentStackChart(chartType, stack)) {
                  formatFunctions = [function(value) {
                    return value + "%";
                  }];
                }
                return formatFunctions;
              },
              /**
               * Create scale values.
               * @param {{limit: {min: number, max: number}, step: number}} scale - scale data
               * @param {string} chartType - chart type
               * @param {boolean} diverging - diverging option
               * @returns {Array.<number>}
               * @private
               */
              _createScaleValues: function _createScaleValues(scale, chartType, diverging) {
                var values = _calculator2["default"].makeLabelsFromLimit(scale.limit, scale.step);
                return _predicate2["default"].isDivergingChart(chartType, diverging) ? values.map(Math.abs) : values;
              },
              /**
               * Create formatted scale values.
               * @param {{limit: {min: number, max: number}, step: number}} scale - scale data
               * @param {{
               *      chartType: string,
               *      areaType: string,
               *      valueType: string
               * }} typeMap - type map
               * @param {{
               *      type: string,
               *      stack: object,
               *      diverging: boolean,
               *      dateFormat: ?string
               * }} options - options
               * @param {?Array.<function>} formatFunctions - format functions
               * @returns {Array.<string|number>|*}
               */
              createFormattedLabels: function createFormattedLabels(scale, typeMap, options, formatFunctions) {
                var chartType = typeMap.chartType, areaType = typeMap.areaType, valueType = typeMap.valueType;
                var diverging = options.diverging, type = options.type, dateFormat = options.dateFormat, stack = options.stack;
                var values = this._createScaleValues(scale, chartType, diverging);
                var formattedValues = void 0;
                if (_predicate2["default"].isDatetimeType(type)) {
                  formattedValues = _renderUtil2["default"].formatDates(values, dateFormat);
                } else {
                  formatFunctions = this._getFormatFunctions(chartType, stack, formatFunctions);
                  formattedValues = _renderUtil2["default"].formatValues(values, formatFunctions, {
                    chartType,
                    areaType,
                    valueType
                  });
                }
                return formattedValues;
              }
            };
            exports2["default"] = scaleLabelFormatter;
          },
          /* 152 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _range = __webpack_require__(13);
            var _range2 = _interopRequireDefault(_range);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _geometric = __webpack_require__(74);
            var _geometric2 = _interopRequireDefault(_geometric);
            var _calculator = __webpack_require__(42);
            var _calculator2 = _interopRequireDefault(_calculator);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            var AUTO_INTERVAL_MIN_WIDTH = 90;
            var AUTO_INTERVAL_MAX_WIDTH = 121;
            var AUTO_INTERVAL_RANGE_STEP = 5;
            var axisDataMaker = {
              /**
               * Makes labels by labelInterval option.
               * @param {Array.<string>} labels - labels
               * @param {number} labelInterval - label interval option
               * @param {number} [addedDataCount] - added data count
               * @returns {Array.<string>} labels
               * @private
               */
              _makeLabelsByIntervalOption: function _makeLabelsByIntervalOption(labels, labelInterval, addedDataCount) {
                addedDataCount = addedDataCount || 0;
                labels = labels.map(function(label, index) {
                  if ((index + addedDataCount) % labelInterval !== 0) {
                    label = _const2["default"].EMPTY_AXIS_LABEL;
                  }
                  return label;
                });
                return labels;
              },
              /**
               * Make axis data for label type.
               * @memberOf module:axisDataMaker
               * @param {object} params - parameters
               *      @param {Array.<string>} params.labels - chart labels
               *      @param {boolean} params.isVertical - whether vertical or not
               *      @param {boolean} params.aligned - whether align or not
               *      @param {?boolean} params.addedDataCount - added data count
               * @returns {{
               *      labels: Array.<string>,
               *      tickCount: number,
               *      validTickCount: number,
               *      isLabelAxis: boolean,
               *      options: object,
               *      isVertical: boolean,
               *      isPositionRight: boolean,
               *      aligned: boolean
               * }}
               */
              makeLabelAxisData: function makeLabelAxisData(params) {
                var _params$options = params.options, options = _params$options === void 0 ? {} : _params$options;
                var tickCount = params.labels.length;
                var labels = params.labels;
                if (_predicate2["default"].isValidLabelInterval(options.labelInterval, options.tickInterval) && params.labels.length > options.labelInterval) {
                  labels = this._makeLabelsByIntervalOption(params.labels, options.labelInterval, params.addedDataCount);
                }
                if (_predicate2["default"].isDatetimeType(options.type)) {
                  labels = _renderUtil2["default"].formatDates(labels, options.dateFormat);
                }
                if (!params.aligned) {
                  tickCount += 1;
                }
                return {
                  labels,
                  tickCount,
                  validTickCount: tickCount,
                  isLabelAxis: true,
                  options,
                  isVertical: !!params.isVertical,
                  isPositionRight: !!params.isPositionRight,
                  aligned: !!params.aligned
                };
              },
              /**
               * Make data for value type axis.
               * @memberOf module:axisDataMaker
               * @param {object} params parameters
               *      @param {AxisScaleMaker} params.axisScaleMaker chart values
               *      @param {boolean} params.isVertical whether vertical or not
               * @returns {{
               *      labels: Array.<string>,
               *      tickCount: number,
               *      validTickCount: number,
               *      isLabelAxis: boolean,
               *      limit: {min: number, max: number},
               *      isVertical: boolean
               * }} axis data
               */
              makeValueAxisData: function makeValueAxisData(params) {
                var labels = params.labels, tickCount = params.tickCount, limit = params.limit;
                var step = params.step, options = params.options, isVertical = params.isVertical, isPositionRight = params.isPositionRight, aligned = params.aligned;
                var axisData = {
                  labels,
                  tickCount,
                  limit,
                  step,
                  options,
                  validTickCount: tickCount,
                  dataMin: limit.min,
                  distance: limit.max - limit.min,
                  isVertical: !!isVertical,
                  isPositionRight: !!isPositionRight,
                  aligned: !!aligned
                };
                return axisData;
              },
              /**
               * Make additional data for coordinate line type chart.
               * @param {Array.<string>} labels - labels
               * @param {Array.<number>} values - values
               * @param {{min: number, max: number}} limit - limit
               * @param {number} step - step
               * @param {number} tickCount = tickCount
               * @returns {{
               *      labels: Array.<string>,
               *      tickCount: number,
               *      validTickCount: number,
               *      limit: {min: number, max: number},
               *      positionRatio: number,
               *      sizeRatio: number
               * }}
               */
              makeAdditionalDataForCoordinateLineType: function makeAdditionalDataForCoordinateLineType(labels, values, limit, step, tickCount) {
                var min = _arrayUtil2["default"].min(values);
                var max = _arrayUtil2["default"].max(values);
                var distance = max - min;
                var positionRatio = 0;
                var sizeRatio = 1;
                if (distance) {
                  if (limit.min < min) {
                    limit.min += step;
                    positionRatio = (limit.min - min) / distance;
                    sizeRatio -= positionRatio;
                    tickCount -= 1;
                    labels.shift();
                  }
                  if (limit.max > max) {
                    limit.max -= step;
                    sizeRatio -= (max - limit.max) / distance;
                    tickCount -= 1;
                    labels.pop();
                  }
                }
                return {
                  labels,
                  tickCount,
                  limit,
                  distance,
                  positionRatio,
                  sizeRatio,
                  validTickCount: tickCount,
                  dataMin: min
                };
              },
              /**
               * Make adjusting tick interval information.
               * @param {number} beforeBlockCount - before block count
               * @param {number} seriesWidth - width of series area
               * @param {number} blockSize - block size
               * @returns {null | {blockCount: number, beforeRemainBlockCount: number, interval: number}}
               * @private
               */
              _makeAdjustingIntervalInfo: function _makeAdjustingIntervalInfo(beforeBlockCount, seriesWidth, blockSize) {
                var remainCount = void 0;
                var newBlockCount = parseInt(seriesWidth / blockSize, 10);
                var intervalInfo = null;
                var interval = parseInt(beforeBlockCount / newBlockCount, 10);
                if (interval > 1) {
                  remainCount = beforeBlockCount - interval * newBlockCount;
                  if (remainCount >= interval) {
                    newBlockCount += parseInt(remainCount / interval, 0);
                    remainCount = remainCount % interval;
                  }
                  intervalInfo = {
                    blockCount: newBlockCount,
                    beforeRemainBlockCount: remainCount,
                    interval
                  };
                }
                return intervalInfo;
              },
              /**
               * Make candidate for adjusting tick interval.
               * @param {number} beforeBlockCount - before block count
               * @param {number} seriesWidth - width of series area
               * @returns {Array.<{newBlockCount: number, remainBlockCount: number, interval: number}>}
               * @private
               */
              _makeCandidatesForAdjustingInterval: function _makeCandidatesForAdjustingInterval(beforeBlockCount, seriesWidth) {
                var _this = this;
                var candidates = [];
                var candidateInterval = _calculator2["default"].divisors(beforeBlockCount);
                candidateInterval.forEach(function(interval) {
                  var intervalWidth = interval / beforeBlockCount * seriesWidth;
                  if (intervalWidth >= AUTO_INTERVAL_MIN_WIDTH && intervalWidth <= AUTO_INTERVAL_MAX_WIDTH) {
                    candidates.push({
                      interval,
                      blockCount: beforeBlockCount / interval,
                      beforeRemainBlockCount: 0
                    });
                  }
                });
                if (candidates.length === 0) {
                  var blockSizeRange = (0, _range2["default"])(AUTO_INTERVAL_MIN_WIDTH, AUTO_INTERVAL_MAX_WIDTH, AUTO_INTERVAL_RANGE_STEP);
                  candidates = blockSizeRange.map(function(blockSize) {
                    return _this._makeAdjustingIntervalInfo(beforeBlockCount, seriesWidth, blockSize);
                  });
                }
                return candidates.filter(function(info) {
                  return !!info;
                });
              },
              /**
               * Calculate adjusting interval information for auto tick interval option.
               * @param {number} curBlockCount - current block count
               * @param {number} seriesWidth - series width
               * @returns {{newBlockCount: number, remainBlockCount: number, interval: number}}
               * @private
               */
              _calculateAdjustingIntervalInfo: function _calculateAdjustingIntervalInfo(curBlockCount, seriesWidth) {
                var candidates = this._makeCandidatesForAdjustingInterval(curBlockCount, seriesWidth);
                var intervalInfo = null;
                if (candidates.length) {
                  intervalInfo = _arrayUtil2["default"].max(candidates, function(candidate) {
                    return candidate.blockCount;
                  });
                }
                return intervalInfo;
              },
              /**
               * Make filtered labels by interval.
               * @param {Array.<string>} labels - labels
               * @param {number} startIndex - start index
               * @param {number} interval - interval
               * @returns {Array.<string>}
               * @private
               */
              _makeFilteredLabelsByInterval: function _makeFilteredLabelsByInterval(labels, startIndex, interval) {
                return labels.slice(startIndex).filter(function(label, index) {
                  return index % interval === 0;
                });
              },
              /**
               * Update label type axisData for auto tick interval option.
               * @param {object} axisData - axisData
               * @param {number} seriesWidth - series width
               * @param {?number} addedDataCount - added data count
               * @param {?boolean} addingDataMode - whether adding data mode or not
               */
              updateLabelAxisDataForAutoTickInterval: function updateLabelAxisDataForAutoTickInterval(axisData, seriesWidth, addedDataCount, addingDataMode) {
                if (addingDataMode) {
                  axisData.tickCount -= 1;
                  axisData.labels.pop();
                }
                var beforeBlockCount = axisData.tickCount - 1;
                var intervalInfo = this._calculateAdjustingIntervalInfo(beforeBlockCount, seriesWidth);
                if (!intervalInfo) {
                  return;
                }
                axisData.eventTickCount = axisData.tickCount;
                var adjustingBlockCount = intervalInfo.blockCount;
                var beforeRemainBlockCount = intervalInfo.beforeRemainBlockCount, interval = intervalInfo.interval;
                var tickCount = adjustingBlockCount + 1;
                var startIndex = 0;
                var lastLabelValue = axisData.labels[axisData.labels.length - 1];
                axisData.labels = this._makeFilteredLabelsByInterval(axisData.labels, startIndex, interval);
                if (beforeRemainBlockCount > 0) {
                  axisData.labels.push(lastLabelValue);
                }
                Object.assign(axisData, {
                  startIndex,
                  tickCount,
                  interval,
                  positionRatio: startIndex / beforeBlockCount,
                  sizeRatio: 1 - beforeRemainBlockCount / beforeBlockCount,
                  remainLastBlockInterval: beforeRemainBlockCount
                });
              },
              /**
               * Update label type axisData for stacking dynamic data.
               * @param {object} axisData - axis data
               * @param {object} prevUpdatedData - previous updated axisData
               * @param {number} firstTickCount - calculated first tick count
               */
              updateLabelAxisDataForStackingDynamicData: function updateLabelAxisDataForStackingDynamicData(axisData, prevUpdatedData, firstTickCount) {
                var interval = prevUpdatedData.interval;
                var startIndex = prevUpdatedData.startIndex;
                var beforeBlockCount = axisData.tickCount - 1;
                var firstBlockCount = firstTickCount ? firstTickCount - 1 : 0;
                var newBlockCount = beforeBlockCount / interval;
                if (firstBlockCount && firstBlockCount * 2 <= newBlockCount) {
                  interval *= 2;
                }
                axisData.labels = this._makeFilteredLabelsByInterval(axisData.labels, startIndex, interval);
                newBlockCount = axisData.labels.length - 1;
                var beforeRemainBlockCount = beforeBlockCount - interval * newBlockCount;
                Object.assign(axisData, {
                  startIndex,
                  interval,
                  eventTickCount: axisData.tickCount,
                  tickCount: axisData.labels.length,
                  positionRatio: startIndex / beforeBlockCount,
                  sizeRatio: 1 - beforeRemainBlockCount / beforeBlockCount
                });
              },
              /**
               * Calculate width for label area for x axis.
               * @param {boolean} isLabelAxis - whether label type axis or not
               * @param {number} seriesWidth - series width
               * @param {number} labelCount - label count
               * @returns {number} limit width
               * @private
               */
              _calculateXAxisLabelAreaWidth: function _calculateXAxisLabelAreaWidth(isLabelAxis, seriesWidth, labelCount) {
                if (!isLabelAxis) {
                  labelCount -= 1;
                }
                return seriesWidth / labelCount;
              },
              /**
               * Create multiline label.
               * @param {string} label - label
               * @param {number} limitWidth - limit width
               * @param {object} theme - label theme
               * @returns {string}
               * @private
               */
              _createMultilineLabel: function _createMultilineLabel(label, limitWidth, theme) {
                var words = String(label).split(" ");
                var lines = [];
                var _words = _slicedToArray(words, 1), lineWords = _words[0];
                words.slice(1).forEach(function(word) {
                  var width = _renderUtil2["default"].getRenderedLabelWidth(lineWords + " " + word, theme);
                  if (width > limitWidth) {
                    lines.push(lineWords);
                    lineWords = word;
                  } else {
                    lineWords += " " + word;
                  }
                });
                if (lineWords) {
                  lines.push(lineWords);
                }
                return lines.join("\n");
              },
              /**
               * Create multiline labels.
               * @param {Array.<string>} labels - labels
               * @param {object} labelTheme - theme for label
               * @param {number} labelAreaWidth - label area width
               * @returns {Array}
               * @private
               */
              _createMultilineLabels: function _createMultilineLabels(labels, labelTheme, labelAreaWidth) {
                var _createMultilineLabel = this._createMultilineLabel;
                return labels.map(function(label) {
                  return _createMultilineLabel(label, labelAreaWidth, labelTheme);
                });
              },
              /**
               * Calculate multiline height.
               * @param {Array.string} multilineLabels - multiline labels
               * @param {object} labelTheme - theme for label
               * @param {number} labelAreaWidth - width for label area
               * @returns {number}
               * @private
               */
              _calculateMultilineHeight: function _calculateMultilineHeight(multilineLabels, labelTheme, labelAreaWidth) {
                return _renderUtil2["default"].getRenderedLabelsMaxHeight(multilineLabels, Object.assign({
                  cssText: "line-height:1.2;width:" + labelAreaWidth + "px"
                }, labelTheme));
              },
              /**
               * Calculate height difference between origin category and multiline category.
               * @param {Array.<string>} labels - labels
               * @param {Array.<string>} validLabelCount - valid label count
               * @param {object} labelTheme - theme for label
               * @param {boolean} isLabelAxis - whether label type axis or not
               * @param {{series: {width: number}, yAxis: {width: number}}} dimensionMap - dimension map
               * @returns {number}
               */
              makeAdditionalDataForMultilineLabels: function makeAdditionalDataForMultilineLabels(labels, validLabelCount, labelTheme, isLabelAxis, dimensionMap) {
                var seriesWidth = dimensionMap.series.width;
                var labelAreaWidth = this._calculateXAxisLabelAreaWidth(isLabelAxis, seriesWidth, validLabelCount);
                var multilineLabels = this._createMultilineLabels(labels, labelTheme, labelAreaWidth);
                var multilineHeight = this._calculateMultilineHeight(multilineLabels, labelTheme, labelAreaWidth);
                var labelHeight = _renderUtil2["default"].getRenderedLabelsMaxHeight(labels, labelTheme);
                return {
                  multilineLabels,
                  overflowHeight: multilineHeight - labelHeight,
                  overflowLeft: 0
                };
              },
              /**
               * Find rotation degree.
               * @param {number} labelAreaWidth - limit width
               * @param {number} labelWidth - label width
               * @param {number} labelHeight - label height
               * @returns {number}
               * @private
               */
              _findRotationDegree: function _findRotationDegree(labelAreaWidth, labelWidth, labelHeight) {
                var foundDegree = null;
                _const2["default"].DEGREE_CANDIDATES.every(function(degree) {
                  var compareWidth = _geometric2["default"].calculateRotatedWidth(degree, labelWidth, labelHeight);
                  foundDegree = degree;
                  if (compareWidth <= labelAreaWidth) {
                    return false;
                  }
                  return true;
                });
                return foundDegree;
              },
              /**
               * Calculate rotated width.
               * @param {number} degree - degree for label of x axis
               * @param {string} firstLabel - first label
               * @param {number} labelHeight - labelHeight
               * @param {object} labelTheme - theme for label
               * @returns {number}
               * @private
               */
              _calculateRotatedWidth: function _calculateRotatedWidth(degree, firstLabel, labelHeight, labelTheme) {
                var firstLabelWidth = _renderUtil2["default"].getRenderedLabelWidth(firstLabel, labelTheme);
                var newLabelWidth = _geometric2["default"].calculateRotatedWidth(degree, firstLabelWidth, labelHeight);
                newLabelWidth -= _geometric2["default"].calculateAdjacent(_const2["default"].ANGLE_90 - degree, labelHeight / 2);
                return newLabelWidth;
              },
              /**
               * Calculate limit width for label
               * @param {number} yAxisWidth - y axis width
               * @param {boolean} isLabelAxis - aligned tick and label
               * @param {number} labelAreaWidth - width for label area
               * @returns {number}
               * @private
               */
              _calculateLimitWidth: function _calculateLimitWidth(yAxisWidth, isLabelAxis, labelAreaWidth) {
                var limitWidth = yAxisWidth;
                if (isLabelAxis) {
                  limitWidth += labelAreaWidth / 2;
                }
                return limitWidth;
              },
              /**
               * Make additional data for rotated labels.
               * The label size is larger than the specified area, creating data to handle the area beyond the border.
               * @param {Array.<string>} validLabels - valid labels
               * @param {Array.<string>} validLabelCount - valid label count
               * @param {object} labelTheme - theme for label
               * @param {boolean} isLabelAxis - whether label type axis or not
               * @param {{series: {width: number}, yAxis: {width: number}}} dimensionMap - dimension map
               * @returns {{degree: number, overflowHeight: number, overflowLeft: number}}
               */
              makeAdditionalDataForRotatedLabels: function makeAdditionalDataForRotatedLabels(validLabels, validLabelCount, labelTheme, isLabelAxis, dimensionMap) {
                var maxLabelWidth = _renderUtil2["default"].getRenderedLabelsMaxWidth(validLabels, labelTheme);
                var seriesWidth = dimensionMap.series.width;
                var yAxisAreaWidth = dimensionMap.yAxis.width + (dimensionMap.rightYAxis ? dimensionMap.rightYAxis.width : 0);
                var labelAreaWidth = this._calculateXAxisLabelAreaWidth(isLabelAxis, seriesWidth, validLabelCount);
                var additionalData = null;
                var contentWidth = _const2["default"].CHART_PADDING * 2 + yAxisAreaWidth + seriesWidth;
                if (labelAreaWidth < maxLabelWidth) {
                  var labelHeight = _renderUtil2["default"].getRenderedLabelsMaxHeight(validLabels, labelTheme);
                  var degree = this._findRotationDegree(labelAreaWidth, maxLabelWidth, labelHeight);
                  var rotatedHeight = _geometric2["default"].calculateRotatedHeight(degree, maxLabelWidth, labelHeight);
                  var rotatedWidth = this._calculateRotatedWidth(degree, validLabels[0], labelHeight, labelTheme);
                  var limitWidth = this._calculateLimitWidth(dimensionMap.yAxis.width, isLabelAxis, labelAreaWidth);
                  contentWidth += rotatedWidth;
                  additionalData = {
                    degree,
                    overflowHeight: rotatedHeight - labelHeight,
                    overflowLeft: rotatedWidth - limitWidth,
                    overflowRight: contentWidth - dimensionMap.chart.width
                  };
                } else {
                  contentWidth += maxLabelWidth;
                  labelAreaWidth = _renderUtil2["default"].getRenderedLabelWidth(validLabels[0], labelTheme) / 2;
                  additionalData = {
                    overflowLeft: labelAreaWidth - dimensionMap.yAxis.width,
                    overflowRight: contentWidth - dimensionMap.chart.width
                  };
                }
                return additionalData;
              }
            };
            exports2["default"] = axisDataMaker;
          },
          /* 153 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _chartBase = __webpack_require__(64);
            var _chartBase2 = _interopRequireDefault(_chartBase);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _rawDataHandler = __webpack_require__(50);
            var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var ColumnChart = function(_ChartBase) {
              _inherits(ColumnChart2, _ChartBase);
              function ColumnChart2(rawData, theme, options) {
                _classCallCheck(this, ColumnChart2);
                _rawDataHandler2["default"].updateRawSeriesDataByOptions(rawData, options.series);
                var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
                  rawData,
                  theme,
                  options,
                  hasAxes: true,
                  isVertical: true
                }));
                _this._updateOptionsRelatedDiverging(options);
                _this.className = "tui-column-chart";
                return _this;
              }
              ColumnChart2.prototype._updateOptionsRelatedDiverging = function _updateOptionsRelatedDiverging(options) {
                options.series = options.series || {};
                if (options.series.diverging) {
                  options.series.stack = options.series.stack || {
                    type: _const2["default"].NORMAL_STACK_TYPE
                  };
                }
              };
              ColumnChart2.prototype.addComponents = function addComponents() {
                this.componentManager.register("title", "title");
                this.componentManager.register("plot", "plot");
                this.componentManager.register("legend", "legend");
                this.componentManager.register("columnSeries", "columnSeries");
                this.componentManager.register("yAxis", "axis");
                this.componentManager.register("xAxis", "axis");
                this.componentManager.register("chartExportMenu", "chartExportMenu");
                this.componentManager.register("tooltip", "tooltip");
                this.componentManager.register("mouseEventDetector", "mouseEventDetector");
              };
              ColumnChart2.prototype.getScaleOption = function getScaleOption() {
                return {
                  yAxis: true
                };
              };
              ColumnChart2.prototype.addDataRatios = function addDataRatios(limitMap) {
                var _options$series = this.options.series, seriesOption = _options$series === void 0 ? {} : _options$series;
                var chartType = this.chartType;
                var _ref = seriesOption[chartType] || seriesOption, stack = _ref.stack;
                this.dataProcessor.addDataRatios(limitMap[chartType], stack, chartType);
              };
              return ColumnChart2;
            }(_chartBase2["default"]);
            exports2["default"] = ColumnChart;
          },
          /* 154 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _forEachArray = __webpack_require__(10);
            var _forEachArray2 = _interopRequireDefault(_forEachArray);
            var _isExisty = __webpack_require__(15);
            var _isExisty2 = _interopRequireDefault(_isExisty);
            var _pick = __webpack_require__(21);
            var _pick2 = _interopRequireDefault(_pick);
            var _chartBase = __webpack_require__(64);
            var _chartBase2 = _interopRequireDefault(_chartBase);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _dynamicDataHelper = __webpack_require__(155);
            var _dynamicDataHelper2 = _interopRequireDefault(_dynamicDataHelper);
            var _lineChartSeries = __webpack_require__(113);
            var _lineChartSeries2 = _interopRequireDefault(_lineChartSeries);
            var _rawDataHandler = __webpack_require__(50);
            var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var LineChart = function(_ChartBase) {
              _inherits(LineChart2, _ChartBase);
              function LineChart2(rawData, theme, options) {
                _classCallCheck(this, LineChart2);
                var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
                  rawData,
                  theme,
                  options,
                  hasAxes: true,
                  isVertical: true
                }));
                _this.className = "tui-line-chart";
                _this.Series = _lineChartSeries2["default"];
                if (rawData.series.line.length && _this.dataProcessor.isCoordinateType()) {
                  delete _this.options.xAxis.tickInterval;
                  _this.options.tooltip.grouped = false;
                  _this.options.series.shifting = false;
                }
                _this._dynamicDataHelper = new _dynamicDataHelper2["default"](_this);
                return _this;
              }
              LineChart2.prototype.setData = function setData() {
                var rawData = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                var animation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                if (rawData.series.length && !rawData.categories.length) {
                  delete this.options.xAxis.tickInterval;
                  this.options.tooltip.grouped = false;
                  this.options.series.shifting = false;
                }
                _ChartBase.prototype.setData.call(this, rawData, animation);
              };
              LineChart2.prototype.addData = function addData(category, values) {
                this._dynamicDataHelper.addData(category, values);
              };
              LineChart2.prototype.onChangeCheckedLegends = function onChangeCheckedLegends(checkedLegends, rawData, boundsParams) {
                this._dynamicDataHelper.reset();
                this._dynamicDataHelper.changeCheckedLegends(checkedLegends, rawData, boundsParams);
              };
              LineChart2.prototype.addDataRatios = function addDataRatios(limitMap) {
                var _this2 = this;
                var chartTypes = this.chartTypes || [this.chartType];
                var seriesOption = this.options.series || {};
                var addDataRatio = void 0;
                if (this.dataProcessor.isCoordinateType()) {
                  addDataRatio = function addDataRatio2(chartType) {
                    var hasRadius = _predicate2["default"].isBubbleChart(chartType);
                    _this2.dataProcessor.addDataRatiosForCoordinateType(chartType, limitMap, hasRadius);
                  };
                } else {
                  addDataRatio = function addDataRatio2(chartType) {
                    var _ref = seriesOption[chartType] || seriesOption, stack = _ref.stack;
                    _this2.dataProcessor.addDataRatios(limitMap[chartType], stack, chartType);
                  };
                }
                (0, _forEachArray2["default"])(chartTypes, addDataRatio);
              };
              LineChart2.prototype.addComponents = function addComponents() {
                this.componentManager.register("title", "title");
                this.componentManager.register("plot", "plot");
                this.componentManager.register("lineSeries", "lineSeries");
                this.componentManager.register("xAxis", "axis");
                if (this.hasRightYAxis) {
                  this.componentManager.register("rightYAxis", "axis");
                }
                this.componentManager.register("yAxis", "axis");
                this.componentManager.register("legend", "legend");
                this.componentManager.register("chartExportMenu", "chartExportMenu");
                this.componentManager.register("tooltip", "tooltip");
                this.componentManager.register("mouseEventDetector", "mouseEventDetector");
              };
              LineChart2.prototype.getScaleOption = function getScaleOption() {
                var scaleOption = {};
                var xAxisOption = this.options.xAxis;
                var yAxisOption = this.options.yAxis;
                var hasDateFormat = void 0, isDateTimeTypeXAxis = void 0;
                if (this.dataProcessor.isCoordinateType()) {
                  isDateTimeTypeXAxis = xAxisOption && xAxisOption.type === "datetime";
                  hasDateFormat = isDateTimeTypeXAxis && (0, _isExisty2["default"])(xAxisOption.dateFormat);
                  scaleOption.xAxis = {
                    valueType: "x"
                  };
                  if (isDateTimeTypeXAxis) {
                    scaleOption.xAxis.type = (xAxisOption || {}).dateTime;
                  }
                  if (hasDateFormat) {
                    scaleOption.xAxis.format = (xAxisOption || {}).dateFormat;
                  }
                  scaleOption.yAxis = {
                    valueType: "y"
                  };
                } else if (this.hasRightYAxis) {
                  scaleOption.yAxis = this._makeYAxisScaleOption("yAxis", yAxisOption[0]);
                  scaleOption.rightYAxis = this._makeYAxisScaleOption("yAxis", yAxisOption[1]);
                } else {
                  scaleOption.yAxis = true;
                }
                return scaleOption;
              };
              LineChart2.prototype._makeYAxisScaleOption = function _makeYAxisScaleOption(name, yAxisOption) {
                return {
                  options: yAxisOption,
                  areaType: "yAxis"
                };
              };
              LineChart2.prototype.addPlotLine = function addPlotLine(data) {
                this.componentManager.get("plot").addPlotLine(data);
              };
              LineChart2.prototype.addPlotBand = function addPlotBand(data) {
                this.componentManager.get("plot").addPlotBand(data);
              };
              LineChart2.prototype.removePlotLine = function removePlotLine(id) {
                this.componentManager.get("plot").removePlotLine(id);
              };
              LineChart2.prototype.removePlotBand = function removePlotBand(id) {
                this.componentManager.get("plot").removePlotBand(id);
              };
              LineChart2.prototype._renderForZoom = function _renderForZoom(isResetZoom) {
                var boundsAndScale = this.readyForRender();
                this.componentManager.render("zoom", boundsAndScale, {
                  isResetZoom
                });
              };
              LineChart2.prototype.onZoom = function onZoom(indexRange) {
                this._dynamicDataHelper.pauseAnimation();
                this.dataProcessor.updateRawDataForZoom(indexRange);
                this._renderForZoom(false);
              };
              LineChart2.prototype.onResetZoom = function onResetZoom() {
                var rawData = this.dataProcessor.getOriginalRawData();
                if (this._dynamicDataHelper.checkedLegends) {
                  rawData = _rawDataHandler2["default"].filterCheckedRawData(rawData, this._dynamicDataHelper.checkedLegends);
                }
                this.dataProcessor.initData(rawData);
                this.dataProcessor.initZoomedRawData();
                this.dataProcessor.addDataFromRemainDynamicData((0, _pick2["default"])(this.options.series, "shifting"));
                this._renderForZoom(true);
                this._dynamicDataHelper.restartAnimation();
              };
              return LineChart2;
            }(_chartBase2["default"]);
            exports2["default"] = LineChart;
          },
          /* 155 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var DynamicDataHelper = function() {
              function DynamicDataHelper2(chart) {
                var _this = this;
                _classCallCheck(this, DynamicDataHelper2);
                var firstRenderCheck = function firstRenderCheck2() {
                  _this.isInitRenderCompleted = true;
                  _this.chart.off(firstRenderCheck2);
                };
                this.chart = chart;
                this.isInitRenderCompleted = false;
                this.chart.on("load", firstRenderCheck);
                this.reset();
              }
              DynamicDataHelper2.prototype.reset = function reset() {
                this.lookupping = false;
                this.paused = false;
                this.rerenderingDelayTimerId = null;
                this.addedDataCount = 0;
                this.checkedLegends = null;
                this.prevXAxisData = null;
              };
              DynamicDataHelper2.prototype._calculateAnimateTickSize = function _calculateAnimateTickSize(xAxisWidth) {
                var dataProcessor = this.chart.dataProcessor;
                var tickInterval = this.chart.options.xAxis.tickInterval;
                var shiftingOption = !!this.chart.options.series.shifting;
                var tickCount = void 0;
                if (dataProcessor.isCoordinateType()) {
                  tickCount = dataProcessor.getValues(this.chart.chartType, "x").length - 1;
                } else {
                  tickCount = dataProcessor.getCategoryCount(false) - 1;
                }
                if (shiftingOption && !_predicate2["default"].isAutoTickInterval(tickInterval)) {
                  tickCount -= 1;
                }
                return xAxisWidth / tickCount;
              };
              DynamicDataHelper2.prototype._animateForAddingData = function _animateForAddingData() {
                var chart = this.chart;
                var boundsAndScale = chart.readyForRender(true);
                var shiftingOption = !!this.chart.options.series.shifting;
                this.addedDataCount += 1;
                var tickSize = this._calculateAnimateTickSize(boundsAndScale.dimensionMap.xAxis.width);
                chart.componentManager.render("animateForAddingData", boundsAndScale, {
                  tickSize,
                  shifting: shiftingOption
                });
                if (shiftingOption) {
                  chart.dataProcessor.shiftData();
                }
              };
              DynamicDataHelper2.prototype._rerenderForAddingData = function _rerenderForAddingData() {
                var chart = this.chart;
                var boundsAndScale = chart.readyForRender();
                chart.componentManager.render("rerender", boundsAndScale);
              };
              DynamicDataHelper2.prototype._checkForAddedData = function _checkForAddedData() {
                var _this2 = this;
                var chart = this.chart;
                var added = chart.dataProcessor.addDataFromDynamicData();
                if (!added) {
                  this.lookupping = false;
                  return;
                }
                if (this.paused) {
                  if (chart.options.series.shifting) {
                    chart.dataProcessor.shiftData();
                  }
                  return;
                }
                this._animateForAddingData();
                this.rerenderingDelayTimerId = setTimeout(function() {
                  _this2.rerenderingDelayTimerId = null;
                  _this2._rerenderForAddingData();
                  _this2._checkForAddedData();
                }, 400);
              };
              DynamicDataHelper2.prototype.changeCheckedLegends = function changeCheckedLegends(checkedLegends, rawData, boundsParams) {
                var _this3 = this;
                var chart = this.chart;
                var shiftingOption = !!chart.options.series.shifting;
                var pastPaused = this.paused;
                if (!pastPaused) {
                  this.pauseAnimation();
                }
                this.checkedLegends = checkedLegends;
                chart.protectedRerender(checkedLegends, rawData, boundsParams);
                if (!pastPaused) {
                  setTimeout(function() {
                    chart.dataProcessor.addDataFromRemainDynamicData(shiftingOption);
                    _this3.restartAnimation();
                  }, _const2["default"].RERENDER_TIME);
                }
              };
              DynamicDataHelper2.prototype.pauseAnimation = function pauseAnimation() {
                this.paused = true;
                if (this.rerenderingDelayTimerId) {
                  clearTimeout(this.rerenderingDelayTimerId);
                  this.rerenderingDelayTimerId = null;
                  if (this.chart.options.series.shifting) {
                    this.chart.dataProcessor.shiftData();
                  }
                }
              };
              DynamicDataHelper2.prototype.restartAnimation = function restartAnimation() {
                this.paused = false;
                this.lookupping = false;
                this._startLookup();
              };
              DynamicDataHelper2.prototype._startLookup = function _startLookup() {
                if (this.lookupping) {
                  return;
                }
                this.lookupping = true;
                this._checkForAddedData();
              };
              DynamicDataHelper2.prototype.addData = function addData(category, values) {
                if (!values) {
                  values = category;
                  category = null;
                }
                this.chart.dataProcessor.addDynamicData(category, values);
                if (this.isInitRenderCompleted) {
                  this._startLookup();
                } else if (values) {
                  this.addedDataCount += 1;
                }
              };
              return DynamicDataHelper2;
            }();
            exports2["default"] = DynamicDataHelper;
          },
          /* 156 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _pick = __webpack_require__(21);
            var _pick2 = _interopRequireDefault(_pick);
            var _chartBase = __webpack_require__(64);
            var _chartBase2 = _interopRequireDefault(_chartBase);
            var _dynamicDataHelper = __webpack_require__(155);
            var _dynamicDataHelper2 = _interopRequireDefault(_dynamicDataHelper);
            var _rawDataHandler = __webpack_require__(50);
            var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
            var _areaChartSeries = __webpack_require__(116);
            var _areaChartSeries2 = _interopRequireDefault(_areaChartSeries);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var AreaChart = function(_ChartBase) {
              _inherits(AreaChart2, _ChartBase);
              function AreaChart2(rawData, theme, options) {
                _classCallCheck(this, AreaChart2);
                _rawDataHandler2["default"].removeSeriesStack(rawData.series);
                var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
                  rawData,
                  theme,
                  options,
                  hasAxes: true,
                  isVertical: true
                }));
                _this.className = "tui-area-chart";
                _this.Series = _areaChartSeries2["default"];
                _this._dynamicDataHelper = new _dynamicDataHelper2["default"](_this);
                return _this;
              }
              AreaChart2.prototype.addData = function addData(category, values) {
                this._dynamicDataHelper.addData(category, values);
              };
              AreaChart2.prototype.onChangeCheckedLegends = function onChangeCheckedLegends(checkedLegends, rawData, boundsParams) {
                this._dynamicDataHelper.reset();
                this._dynamicDataHelper.changeCheckedLegends(checkedLegends, rawData, boundsParams);
              };
              AreaChart2.prototype.addDataRatios = function addDataRatios(limitMap) {
                var _this2 = this;
                var chartTypes = this.chartTypes || [this.chartType];
                var seriesOption = this.options.series || {};
                var addDataRatio = void 0;
                if (this.dataProcessor.isCoordinateType()) {
                  addDataRatio = function addDataRatio2(chartType) {
                    _this2.dataProcessor.addDataRatiosForCoordinateType(chartType, limitMap, false);
                  };
                } else {
                  addDataRatio = function addDataRatio2(chartType) {
                    var _ref = seriesOption[chartType] || seriesOption, stack = _ref.stack;
                    _this2.dataProcessor.addDataRatios(limitMap[chartType], stack, chartType);
                  };
                }
                chartTypes.forEach(addDataRatio);
              };
              AreaChart2.prototype.addComponents = function addComponents() {
                this.componentManager.register("title", "title");
                this.componentManager.register("plot", "plot");
                this.componentManager.register("legend", "legend");
                this.componentManager.register("areaSeries", "areaSeries");
                this.componentManager.register("xAxis", "axis");
                this.componentManager.register("yAxis", "axis");
                this.componentManager.register("chartExportMenu", "chartExportMenu");
                this.componentManager.register("tooltip", "tooltip");
                this.componentManager.register("mouseEventDetector", "mouseEventDetector");
              };
              AreaChart2.prototype.getScaleOption = function getScaleOption() {
                var scaleOption = {};
                if (this.dataProcessor.isCoordinateType()) {
                  scaleOption.xAxis = {
                    valueType: "x"
                  };
                  scaleOption.yAxis = {
                    valueType: "y"
                  };
                } else {
                  scaleOption.yAxis = true;
                }
                return scaleOption;
              };
              AreaChart2.prototype.addPlotLine = function addPlotLine(data) {
                this.componentManager.get("plot").addPlotLine(data);
              };
              AreaChart2.prototype.addPlotBand = function addPlotBand(data) {
                this.componentManager.get("plot").addPlotBand(data);
              };
              AreaChart2.prototype.removePlotLine = function removePlotLine(id) {
                this.componentManager.get("plot").removePlotLine(id);
              };
              AreaChart2.prototype.removePlotBand = function removePlotBand(id) {
                this.componentManager.get("plot").removePlotBand(id);
              };
              AreaChart2.prototype._renderForZoom = function _renderForZoom(isResetZoom) {
                var boundsAndScale = this.readyForRender();
                this.componentManager.render("zoom", boundsAndScale, {
                  isResetZoom
                });
              };
              AreaChart2.prototype.onZoom = function onZoom(indexRange) {
                this._dynamicDataHelper.pauseAnimation();
                this.dataProcessor.updateRawDataForZoom(indexRange);
                this._renderForZoom(false);
              };
              AreaChart2.prototype.onResetZoom = function onResetZoom() {
                var rawData = this.dataProcessor.getOriginalRawData();
                if (this._dynamicDataHelper.checkedLegends) {
                  rawData = _rawDataHandler2["default"].filterCheckedRawData(rawData, this._dynamicDataHelper.checkedLegends);
                }
                this.dataProcessor.initData(rawData);
                this.dataProcessor.initZoomedRawData();
                this.dataProcessor.addDataFromRemainDynamicData((0, _pick2["default"])(this.options.series, "shifting"));
                this._renderForZoom(true);
                this._dynamicDataHelper.restartAnimation();
              };
              return AreaChart2;
            }(_chartBase2["default"]);
            exports2["default"] = AreaChart;
          },
          /* 157 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _chartBase = __webpack_require__(64);
            var _chartBase2 = _interopRequireDefault(_chartBase);
            var _rawDataHandler = __webpack_require__(50);
            var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _validTypeMakerForYAxisOptions = __webpack_require__(158);
            var _validTypeMakerForYAxisOptions2 = _interopRequireDefault(_validTypeMakerForYAxisOptions);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var ColumnLineComboChart = function(_ChartBase) {
              _inherits(ColumnLineComboChart2, _ChartBase);
              function ColumnLineComboChart2(rawData, theme, options) {
                _classCallCheck(this, ColumnLineComboChart2);
                options.tooltip = options.tooltip || {};
                options.tooltip.grouped = true;
                var typeData = (0, _validTypeMakerForYAxisOptions2["default"])({
                  rawSeriesData: rawData.series,
                  yAxisOptions: options.yAxis
                });
                var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
                  rawData,
                  theme,
                  options,
                  chartTypes: typeData.chartTypes,
                  seriesTypes: typeData.seriesTypes,
                  hasAxes: true,
                  isVertical: true
                }));
                _this.yAxisOptions = _this._makeYAxisOptions(_this.chartTypes, options.yAxis);
                return _this;
              }
              ColumnLineComboChart2.prototype._makeYAxisOptions = function _makeYAxisOptions(chartTypes, yAxisOptions) {
                var options = {};
                yAxisOptions = yAxisOptions || {};
                chartTypes.forEach(function(chartType, index) {
                  options[chartType] = yAxisOptions[index] || yAxisOptions;
                });
                return options;
              };
              ColumnLineComboChart2.prototype.onChangeCheckedLegends = function onChangeCheckedLegends(checkedLegends) {
                var originalRawData = this.dataProcessor.getOriginalRawData();
                var rawData = _rawDataHandler2["default"].filterCheckedRawData(originalRawData, checkedLegends);
                var typeData = (0, _validTypeMakerForYAxisOptions2["default"])({
                  rawSeriesData: rawData.series,
                  yAxisOptions: this.options.yAxis
                });
                this.chartTypes = typeData.chartTypes;
                this.seriesTypes = typeData.seriesTypes;
                this.protectedRerender(checkedLegends, rawData, typeData);
              };
              ColumnLineComboChart2.prototype.addComponents = function addComponents() {
                this.componentManager.register("title", "title");
                this.componentManager.register("plot", "plot");
                this.componentManager.register("legend", "legend");
                this.componentManager.register("columnSeries", "columnSeries");
                this.componentManager.register("lineSeries", "lineSeries");
                this.componentManager.register("yAxis", "axis");
                if (this.hasRightYAxis) {
                  this.componentManager.register("rightYAxis", "axis");
                }
                this.componentManager.register("xAxis", "axis");
                this.componentManager.register("chartExportMenu", "chartExportMenu");
                this.componentManager.register("tooltip", "tooltip");
                this.componentManager.register("mouseEventDetector", "mouseEventDetector");
              };
              ColumnLineComboChart2.prototype.getScaleOption = function getScaleOption() {
                var scaleOption = {
                  yAxis: this._makeYAxisScaleOption("yAxis", this.chartTypes[0], !this.hasRightYAxis)
                };
                if (this.hasRightYAxis) {
                  scaleOption.rightYAxis = this._makeYAxisScaleOption("rightYAxis", this.chartTypes[1]);
                }
                return scaleOption;
              };
              ColumnLineComboChart2.prototype._makeYAxisScaleOption = function _makeYAxisScaleOption(name, chartType, isSingleYAxis) {
                var yAxisOption = this.yAxisOptions[chartType];
                var additionalOptions = {
                  isSingleYAxis: !!isSingleYAxis
                };
                if (isSingleYAxis && this.options.series) {
                  this._setAdditionalOptions(additionalOptions);
                }
                return {
                  options: yAxisOption,
                  areaType: "yAxis",
                  chartType,
                  additionalOptions
                };
              };
              ColumnLineComboChart2.prototype._setAdditionalOptions = function _setAdditionalOptions(additionalOptions) {
                var dataProcessor = this.dataProcessor;
                Object.entries(this.options.series).forEach(function(_ref) {
                  var _ref2 = _slicedToArray(_ref, 2), seriesType = _ref2[0], seriesOption = _ref2[1];
                  if (!seriesOption.stackType) {
                    return;
                  }
                  var chartType = dataProcessor.findChartType(seriesType);
                  if (!_predicate2["default"].isAllowedStackOption(chartType)) {
                    return;
                  }
                  additionalOptions.chartType = chartType;
                  additionalOptions.stackType = seriesOption.stackType;
                });
              };
              ColumnLineComboChart2.prototype.addDataRatios = function addDataRatios(limitMap) {
                var _this2 = this;
                var chartTypes = this.chartTypes || [this.chartType];
                var seriesOption = this.options.series || {};
                var addDataRatio = function addDataRatio2(chartType) {
                  var _ref3 = seriesOption[chartType] || seriesOption, stack = _ref3.stack;
                  _this2.dataProcessor.addDataRatios(limitMap[chartType], stack, chartType);
                };
                chartTypes.forEach(addDataRatio);
              };
              return ColumnLineComboChart2;
            }(_chartBase2["default"]);
            exports2["default"] = ColumnLineComboChart;
          },
          /* 158 */
          /***/
          function(module2, exports2) {
            "use strict";
            exports2.__esModule = true;
            exports2["default"] = validTypeMakerForYAxisOptions;
            function validTypeMakerForYAxisOptions(params) {
              var rawSeriesData = params.rawSeriesData, yAxisOptions = params.yAxisOptions;
              var chartTypesMap = makeChartTypesMap(rawSeriesData, yAxisOptions);
              return {
                chartTypes: chartTypesMap.chartTypes,
                seriesTypes: chartTypesMap.seriesTypes
              };
            }
            function makeChartTypesMap(rawSeriesData, yAxisOption) {
              var seriesTypes = Object.keys(rawSeriesData).sort();
              var optionChartTypes = getYAxisOptionChartTypes(seriesTypes, yAxisOption);
              var chartTypes = optionChartTypes.length ? optionChartTypes : seriesTypes;
              var validChartTypes = optionChartTypes.filter(function(_chartType) {
                return rawSeriesData[_chartType].length;
              });
              var chartTypesMap = void 0;
              if (validChartTypes.length === 1) {
                chartTypesMap = {
                  chartTypes: validChartTypes,
                  seriesTypes: validChartTypes
                };
              } else {
                chartTypesMap = {
                  chartTypes,
                  seriesTypes
                };
              }
              return chartTypesMap;
            }
            function getYAxisOptionChartTypes(chartTypes, yAxisOption) {
              var resultChartTypes = chartTypes.slice();
              var yAxisOptions = [].concat(yAxisOption || []);
              var isReverse = false;
              var optionChartTypes = void 0;
              if (!yAxisOptions.length || yAxisOptions.length === 1 && !yAxisOptions[0].chartType) {
                resultChartTypes = [];
              } else if (yAxisOptions.length) {
                optionChartTypes = yAxisOptions.map(function(option) {
                  return option.chartType;
                });
                optionChartTypes.forEach(function(chartType, index) {
                  isReverse = isReverse || chartType && resultChartTypes[index] !== chartType || false;
                });
                if (isReverse) {
                  resultChartTypes.reverse();
                }
              }
              return resultChartTypes;
            }
          },
          /* 159 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _forEachArray = __webpack_require__(10);
            var _forEachArray2 = _interopRequireDefault(_forEachArray);
            var _chartBase = __webpack_require__(64);
            var _chartBase2 = _interopRequireDefault(_chartBase);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var LineScatterComboChart = function(_ChartBase) {
              _inherits(LineScatterComboChart2, _ChartBase);
              function LineScatterComboChart2(rawData, theme, options) {
                _classCallCheck(this, LineScatterComboChart2);
                return _possibleConstructorReturn(this, _ChartBase.call(this, {
                  rawData,
                  theme,
                  options,
                  chartTypes: ["line", "scatter"],
                  seriesTypes: ["line", "scatter"],
                  hasAxes: true,
                  isVertical: true
                }));
              }
              LineScatterComboChart2.prototype.getScaleOption = function getScaleOption() {
                return {
                  yAxis: {
                    valueType: "y"
                  },
                  xAxis: {
                    valueType: "x"
                  }
                };
              };
              LineScatterComboChart2.prototype.addDataRatios = function addDataRatios(limitMap) {
                var _this2 = this;
                var chartTypes = this.chartTypes || [this.chartType];
                var addDataRatio = function addDataRatio2(chartType) {
                  _this2.dataProcessor.addDataRatiosForCoordinateType(chartType, limitMap, false);
                };
                (0, _forEachArray2["default"])(chartTypes, addDataRatio);
              };
              LineScatterComboChart2.prototype.addComponents = function addComponents() {
                this.componentManager.register("title", "title");
                this.componentManager.register("plot", "plot");
                this.componentManager.register("legend", "legend");
                this.componentManager.register("lineSeries", "lineSeries");
                this.componentManager.register("scatterSeries", "scatterSeries");
                this.componentManager.register("yAxis", "axis");
                this.componentManager.register("xAxis", "axis");
                this.componentManager.register("chartExportMenu", "chartExportMenu");
                this.componentManager.register("tooltip", "tooltip");
                this.componentManager.register("mouseEventDetector", "mouseEventDetector");
              };
              return LineScatterComboChart2;
            }(_chartBase2["default"]);
            exports2["default"] = LineScatterComboChart;
          },
          /* 160 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _pick = __webpack_require__(21);
            var _pick2 = _interopRequireDefault(_pick);
            var _forEachArray = __webpack_require__(10);
            var _forEachArray2 = _interopRequireDefault(_forEachArray);
            var _chartBase = __webpack_require__(64);
            var _chartBase2 = _interopRequireDefault(_chartBase);
            var _rawDataHandler = __webpack_require__(50);
            var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
            var _predicate = __webpack_require__(33);
            var _predicate2 = _interopRequireDefault(_predicate);
            var _validTypeMakerForYAxisOptions = __webpack_require__(158);
            var _validTypeMakerForYAxisOptions2 = _interopRequireDefault(_validTypeMakerForYAxisOptions);
            var _dynamicDataHelper = __webpack_require__(155);
            var _dynamicDataHelper2 = _interopRequireDefault(_dynamicDataHelper);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var LineAreaComboChart = function(_ChartBase) {
              _inherits(LineAreaComboChart2, _ChartBase);
              function LineAreaComboChart2(rawData, theme, options) {
                _classCallCheck(this, LineAreaComboChart2);
                var typeData = (0, _validTypeMakerForYAxisOptions2["default"])({
                  rawSeriesData: rawData.series,
                  yAxisOptions: options.yAxis
                });
                options.tooltip = options.tooltip || {};
                options.tooltip.grouped = true;
                var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
                  rawData,
                  theme,
                  options,
                  seriesTypes: typeData.seriesTypes,
                  chartTypes: typeData.chartTypes,
                  hasAxes: true,
                  isVertical: true
                }));
                _this.yAxisOptions = _this._makeYAxisOptions(_this.chartTypes, options.yAxis);
                _this._dynamicDataHelper = new _dynamicDataHelper2["default"](_this);
                _this.className = "tui-combo-chart";
                return _this;
              }
              LineAreaComboChart2.prototype.onChangeCheckedLegends = function onChangeCheckedLegends(checkedLegends) {
                var currentData = this.dataProcessor.getCurrentData();
                var rawData = _rawDataHandler2["default"].filterCheckedRawData(currentData, checkedLegends);
                var typeData = (0, _validTypeMakerForYAxisOptions2["default"])({
                  rawSeriesData: rawData.series,
                  yAxisOptions: this.options.yAxis
                });
                this._dynamicDataHelper.reset();
                this._dynamicDataHelper.changeCheckedLegends(checkedLegends, rawData, typeData);
              };
              LineAreaComboChart2.prototype.addComponents = function addComponents() {
                this.componentManager.register("title", "title");
                this.componentManager.register("plot", "plot");
                this.componentManager.register("legend", "legend");
                this.componentManager.register("areaSeries", "areaSeries");
                this.componentManager.register("lineSeries", "lineSeries");
                this.componentManager.register("xAxis", "axis");
                this.componentManager.register("yAxis", "axis");
                if (this.hasRightYAxis) {
                  this.componentManager.register("rightYAxis", "axis");
                }
                this.componentManager.register("chartExportMenu", "chartExportMenu");
                this.componentManager.register("tooltip", "tooltip");
                this.componentManager.register("mouseEventDetector", "mouseEventDetector");
              };
              LineAreaComboChart2.prototype.getScaleOption = function getScaleOption() {
                var scaleOption = {
                  yAxis: this._makeYAxisScaleOption("yAxis", this.chartTypes[0], !this.hasRightYAxis)
                };
                if (this.hasRightYAxis) {
                  scaleOption.rightYAxis = this._makeYAxisScaleOption("rightYAxis", this.chartTypes[1]);
                }
                return scaleOption;
              };
              LineAreaComboChart2.prototype._makeYAxisScaleOption = function _makeYAxisScaleOption(name, chartType, isSingleYAxis) {
                var yAxisOption = this.yAxisOptions[chartType];
                var additionalOptions = {
                  isSingleYAxis: !!isSingleYAxis
                };
                if (isSingleYAxis && this.options.series) {
                  this._setAdditionalOptions(additionalOptions);
                }
                return {
                  options: yAxisOption,
                  areaType: "yAxis",
                  chartType,
                  additionalOptions
                };
              };
              LineAreaComboChart2.prototype._makeYAxisOptions = function _makeYAxisOptions(chartTypes) {
                var yAxisOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var options = {};
                chartTypes.forEach(function(chartType, index) {
                  options[chartType] = yAxisOptions[index] || yAxisOptions;
                });
                return options;
              };
              LineAreaComboChart2.prototype.addData = function addData(category, values) {
                this._dynamicDataHelper.addData(category, values);
              };
              LineAreaComboChart2.prototype._setAdditionalOptions = function _setAdditionalOptions(additionalOptions) {
                var dataProcessor = this.dataProcessor;
                Object.entries(this.options.series).forEach(function(_ref) {
                  var _ref2 = _slicedToArray(_ref, 2), seriesType = _ref2[0], seriesOption = _ref2[1];
                  if (!seriesOption.stackType) {
                    return;
                  }
                  var chartType = dataProcessor.findChartType(seriesType);
                  if (!_predicate2["default"].isAllowedStackOption(chartType)) {
                    return;
                  }
                  additionalOptions.chartType = chartType;
                  additionalOptions.stack = seriesOption.stack;
                });
              };
              LineAreaComboChart2.prototype.addDataRatios = function addDataRatios(limitMap) {
                var _this2 = this;
                var chartTypes = this.chartTypes || [this.chartType];
                var seriesOption = this.options.series || {};
                var addDataRatio = void 0;
                if (this.dataProcessor.isCoordinateType()) {
                  addDataRatio = function addDataRatio2(chartType) {
                    _this2.dataProcessor.addDataRatiosForCoordinateType(chartType, limitMap, false);
                  };
                } else {
                  addDataRatio = function addDataRatio2(chartType) {
                    var _ref3 = seriesOption[chartType] || seriesOption, stack = _ref3.stack;
                    _this2.dataProcessor.addDataRatios(limitMap[chartType], stack, chartType);
                  };
                }
                (0, _forEachArray2["default"])(chartTypes, addDataRatio);
              };
              LineAreaComboChart2.prototype.addPlotLine = function addPlotLine(data) {
                this.componentManager.get("plot").addPlotLine(data);
              };
              LineAreaComboChart2.prototype.addPlotBand = function addPlotBand(data) {
                this.componentManager.get("plot").addPlotBand(data);
              };
              LineAreaComboChart2.prototype.removePlotLine = function removePlotLine(id) {
                this.componentManager.get("plot").removePlotLine(id);
              };
              LineAreaComboChart2.prototype.removePlotBand = function removePlotBand(id) {
                this.componentManager.get("plot").removePlotBand(id);
              };
              LineAreaComboChart2.prototype._renderForZoom = function _renderForZoom(isResetZoom) {
                var boundsAndScale = this.readyForRender();
                this.componentManager.render("zoom", boundsAndScale, {
                  isResetZoom
                });
              };
              LineAreaComboChart2.prototype.onZoom = function onZoom(indexRange) {
                this._dynamicDataHelper.pauseAnimation();
                this.dataProcessor.updateRawDataForZoom(indexRange);
                this._renderForZoom(false);
              };
              LineAreaComboChart2.prototype.onResetZoom = function onResetZoom() {
                var rawData = this.dataProcessor.getOriginalRawData();
                if (this._dynamicDataHelper.checkedLegends) {
                  rawData = _rawDataHandler2["default"].filterCheckedRawData(rawData, this._dynamicDataHelper.checkedLegends);
                }
                this.dataProcessor.initData(rawData);
                this.dataProcessor.initZoomedRawData();
                this.dataProcessor.addDataFromRemainDynamicData((0, _pick2["default"])(this.options.series, "shifting"));
                this._renderForZoom(true);
                this._dynamicDataHelper.restartAnimation();
              };
              return LineAreaComboChart2;
            }(_chartBase2["default"]);
            exports2["default"] = LineAreaComboChart;
          },
          /* 161 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _chartBase = __webpack_require__(64);
            var _chartBase2 = _interopRequireDefault(_chartBase);
            var _rawDataHandler = __webpack_require__(50);
            var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var PieDonutComboChart = function(_ChartBase) {
              _inherits(PieDonutComboChart2, _ChartBase);
              function PieDonutComboChart2(rawData, theme, options) {
                _classCallCheck(this, PieDonutComboChart2);
                var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
                  rawData,
                  theme,
                  options,
                  seriesTypes: Object.keys(rawData.series).sort(),
                  chartTypes: ["pie", "pie"],
                  isVertical: true
                }));
                _this.className = "tui-combo-chart";
                return _this;
              }
              PieDonutComboChart2.prototype.addComponents = function addComponents() {
                this.componentManager.register("title", "title");
                this.componentManager.register("legend", "legend");
                this.componentManager.register("pie1Series", "pieSeries");
                this.componentManager.register("pie2Series", "pieSeries");
                this.componentManager.register("chartExportMenu", "chartExportMenu");
                this.componentManager.register("tooltip", "tooltip");
                this.componentManager.register("mouseEventDetector", "mouseEventDetector");
              };
              PieDonutComboChart2.prototype.addDataRatios = function addDataRatios() {
                var _this2 = this;
                var seriesTypes = this.seriesTypes || [this.chartType];
                seriesTypes.forEach(function(chartType) {
                  _this2.dataProcessor.addDataRatiosOfPieChart(chartType);
                });
              };
              PieDonutComboChart2.prototype.onChangeCheckedLegends = function onChangeCheckedLegends(checkedLegends) {
                var originalRawData = this.dataProcessor.getOriginalRawData();
                var rawData = _rawDataHandler2["default"].filterCheckedRawData(originalRawData, checkedLegends);
                _chartBase2["default"].prototype.onChangeCheckedLegends.call(this, checkedLegends, rawData, {
                  seriesTypes: this.seriesTypes
                });
              };
              return PieDonutComboChart2;
            }(_chartBase2["default"]);
            exports2["default"] = PieDonutComboChart;
          },
          /* 162 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _chartBase = __webpack_require__(64);
            var _chartBase2 = _interopRequireDefault(_chartBase);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var PieChart = function(_ChartBase) {
              _inherits(PieChart2, _ChartBase);
              function PieChart2(rawData, theme, options) {
                _classCallCheck(this, PieChart2);
                options.tooltip = options.tooltip || {};
                if (!options.tooltip.align) {
                  options.tooltip.align = _const2["default"].TOOLTIP_DEFAULT_ALIGN_OPTION;
                }
                var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
                  rawData,
                  theme,
                  options
                }));
                _this.className = "tui-pie-chart";
                return _this;
              }
              PieChart2.prototype.addComponents = function addComponents() {
                this.componentManager.register("title", "title");
                this.componentManager.register("legend", "legend");
                this.componentManager.register("pieSeries", "pieSeries");
                this.componentManager.register("chartExportMenu", "chartExportMenu");
                this.componentManager.register("tooltip", "tooltip");
                this.componentManager.register("mouseEventDetector", "mouseEventDetector");
              };
              PieChart2.prototype.addDataRatios = function addDataRatios() {
                this.dataProcessor.addDataRatiosOfPieChart(this.chartType);
              };
              return PieChart2;
            }(_chartBase2["default"]);
            exports2["default"] = PieChart;
          },
          /* 163 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _chartBase = __webpack_require__(64);
            var _chartBase2 = _interopRequireDefault(_chartBase);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var BubbleChart = function(_ChartBase) {
              _inherits(BubbleChart2, _ChartBase);
              function BubbleChart2(rawData, theme, options) {
                _classCallCheck(this, BubbleChart2);
                options = Object.assign({
                  tooltip: {},
                  circleLegend: {}
                }, options);
                options.circleLegend = Object.assign({
                  visible: true
                }, options.circleLegend);
                options.tooltip = Object.assign({
                  align: _const2["default"].TOOLTIP_DEFAULT_ALIGN_OPTION,
                  grouped: false
                }, options.tooltip);
                var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
                  rawData,
                  theme,
                  options,
                  hasAxes: true
                }));
                _this.className = "tui-bubble-chart";
                return _this;
              }
              BubbleChart2.prototype.getScaleOption = function getScaleOption() {
                var scaleOption = {};
                if (this.dataProcessor.hasXValue(this.chartType)) {
                  scaleOption.xAxis = {
                    valueType: "x"
                  };
                }
                if (this.dataProcessor.hasYValue(this.chartType)) {
                  scaleOption.yAxis = {
                    valueType: "y"
                  };
                }
                return scaleOption;
              };
              BubbleChart2.prototype._setDefaultOptions = function _setDefaultOptions(options) {
                _chartBase2["default"].prototype._setDefaultOptions.call(this, options);
                this.options.circleLegend = this.options.circleLegend || {};
                if ((0, _isUndefined2["default"])(this.options.circleLegend.visible)) {
                  this.options.circleLegend.visible = true;
                }
              };
              BubbleChart2.prototype.addComponents = function addComponents() {
                this.componentManager.register("title", "title");
                this.componentManager.register("plot", "plot");
                this.componentManager.register("legend", "legend");
                this.componentManager.register("circleLegend", "circleLegend");
                this.componentManager.register("bubbleSeries", "bubbleSeries");
                this.componentManager.register("yAxis", "axis");
                this.componentManager.register("xAxis", "axis");
                this.componentManager.register("chartExportMenu", "chartExportMenu");
                this.componentManager.register("tooltip", "tooltip");
                this.componentManager.register("mouseEventDetector", "mouseEventDetector");
              };
              BubbleChart2.prototype.addDataRatios = function addDataRatios(limitMap) {
                this.dataProcessor.addDataRatiosForCoordinateType(this.chartType, limitMap, true);
              };
              return BubbleChart2;
            }(_chartBase2["default"]);
            exports2["default"] = BubbleChart;
          },
          /* 164 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _chartBase = __webpack_require__(64);
            var _chartBase2 = _interopRequireDefault(_chartBase);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var ScatterChart = function(_ChartBase) {
              _inherits(ScatterChart2, _ChartBase);
              function ScatterChart2(rawData, theme, options) {
                _classCallCheck(this, ScatterChart2);
                options.tooltip = options.tooltip || {};
                if (!options.tooltip.align) {
                  options.tooltip.align = _const2["default"].TOOLTIP_DEFAULT_ALIGN_OPTION;
                }
                options.tooltip.grouped = false;
                var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
                  rawData,
                  theme,
                  options,
                  hasAxes: true
                }));
                _this.className = "tui-scatter-chart";
                return _this;
              }
              ScatterChart2.prototype.getScaleOption = function getScaleOption() {
                return {
                  xAxis: {
                    valueType: "x"
                  },
                  yAxis: {
                    valueType: "y"
                  }
                };
              };
              ScatterChart2.prototype.addComponents = function addComponents() {
                this.componentManager.register("title", "title");
                this.componentManager.register("plot", "plot");
                this.componentManager.register("legend", "legend");
                this.componentManager.register("scatterSeries", "scatterSeries");
                this.componentManager.register("yAxis", "axis");
                this.componentManager.register("xAxis", "axis");
                this.componentManager.register("chartExportMenu", "chartExportMenu");
                this.componentManager.register("tooltip", "tooltip");
                this.componentManager.register("mouseEventDetector", "mouseEventDetector");
              };
              ScatterChart2.prototype.addDataRatios = function addDataRatios(limitMap) {
                this.dataProcessor.addDataRatiosForCoordinateType(this.chartType, limitMap, false);
              };
              return ScatterChart2;
            }(_chartBase2["default"]);
            exports2["default"] = ScatterChart;
          },
          /* 165 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _chartBase = __webpack_require__(64);
            var _chartBase2 = _interopRequireDefault(_chartBase);
            var _colorSpectrum = __webpack_require__(166);
            var _colorSpectrum2 = _interopRequireDefault(_colorSpectrum);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var HeatmapChart = function(_ChartBase) {
              _inherits(HeatmapChart2, _ChartBase);
              function HeatmapChart2(rawData, theme, options) {
                _classCallCheck(this, HeatmapChart2);
                options.tooltip = options.tooltip || {};
                if (!options.tooltip.align) {
                  options.tooltip.align = _const2["default"].TOOLTIP_DEFAULT_ALIGN_OPTION;
                }
                options.tooltip.grouped = false;
                var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
                  rawData,
                  theme,
                  options,
                  hasAxes: true,
                  isVertical: true
                }));
                _this.className = "tui-heatmap-chart";
                return _this;
              }
              HeatmapChart2.prototype._addComponents = function _addComponents() {
                var seriesTheme = this.theme.series[this.chartType];
                var colorSpectrum = new _colorSpectrum2["default"](seriesTheme.startColor, seriesTheme.endColor);
                this._addComponentsForAxisType({
                  axis: [{
                    name: "yAxis",
                    isVertical: true
                  }, {
                    name: "xAxis"
                  }],
                  legend: {
                    classType: "spectrumLegend",
                    additionalParams: {
                      colorSpectrum
                    }
                  },
                  series: [{
                    name: "heatmapSeries",
                    data: {
                      colorSpectrum
                    }
                  }],
                  tooltip: true,
                  mouseEventDetector: true
                });
              };
              HeatmapChart2.prototype.getScaleOption = function getScaleOption() {
                return {
                  legend: true
                };
              };
              HeatmapChart2.prototype.addDataRatios = function addDataRatios(limitMap) {
                this.dataProcessor.addDataRatios(limitMap.legend, null, this.chartType);
              };
              HeatmapChart2.prototype.addComponents = function addComponents() {
                var seriesTheme = this.theme.series[this.chartType];
                var colorSpectrum = new _colorSpectrum2["default"](seriesTheme.startColor, seriesTheme.endColor);
                this.componentManager.register("title", "title");
                this.componentManager.register("legend", "spectrumLegend", {
                  colorSpectrum
                });
                this.componentManager.register("heatmapSeries", "heatmapSeries", {
                  colorSpectrum
                });
                this.componentManager.register("xAxis", "axis");
                this.componentManager.register("yAxis", "axis");
                this.componentManager.register("chartExportMenu", "chartExportMenu");
                this.componentManager.register("tooltip", "tooltip", {
                  colorSpectrum
                });
                this.componentManager.register("mouseEventDetector", "mouseEventDetector");
              };
              return HeatmapChart2;
            }(_chartBase2["default"]);
            exports2["default"] = HeatmapChart;
          },
          /* 166 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _colorutil = __webpack_require__(167);
            var _colorutil2 = _interopRequireDefault(_colorutil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _toConsumableArray(arr) {
              if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              } else {
                return Array.from(arr);
              }
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var ColorSpectrum = function() {
              function ColorSpectrum2(startColor, endColor) {
                _classCallCheck(this, ColorSpectrum2);
                this.start = _colorutil2["default"].colorNameToHex(startColor);
                this.startRGB = _colorutil2["default"].hexToRGB(this.start);
                this.end = _colorutil2["default"].colorNameToHex(endColor);
                var endRGB = _colorutil2["default"].hexToRGB(this.end);
                this.distances = this._makeDistances(this.startRGB, endRGB);
                this.colorMap = {};
              }
              ColorSpectrum2.prototype._makeDistances = function _makeDistances(startRGB, endRGB) {
                return startRGB.map(function(value, index) {
                  return endRGB[index] - value;
                });
              };
              ColorSpectrum2.prototype.getColor = function getColor(ratio) {
                var hexColor = this.colorMap[ratio];
                if (!hexColor) {
                  var distances = this.distances, startRGB = this.startRGB;
                  var rgbColor = startRGB.map(function(start, index) {
                    return start + parseInt(distances[index] * ratio, 10);
                  });
                  hexColor = _colorutil2["default"].rgbToHEX.apply(_colorutil2["default"], _toConsumableArray(rgbColor));
                }
                return hexColor || null;
              };
              return ColorSpectrum2;
            }();
            exports2["default"] = ColorSpectrum;
          },
          /* 167 */
          /***/
          function(module2, exports2) {
            "use strict";
            exports2.__esModule = true;
            var hexRX = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i;
            var colorMap = {
              aliceblue: "#f0f8ff",
              antiquewhite: "#faebd7",
              aqua: "#00ffff",
              aquamarine: "#7fffd4",
              azure: "#f0ffff",
              beige: "#f5f5dc",
              bisque: "#ffe4c4",
              black: "#000000",
              blanchedalmond: "#ffebcd",
              blue: "#0000ff",
              blueviolet: "#8a2be2",
              brown: "#a52a2a",
              burlywood: "#deb887",
              cadetblue: "#5f9ea0",
              chartreuse: "#7fff00",
              chocolate: "#d2691e",
              coral: "#ff7f50",
              cornflowerblue: "#6495ed",
              cornsilk: "#fff8dc",
              crimson: "#dc143c",
              cyan: "#00ffff",
              darkblue: "#00008b",
              darkcyan: "#008b8b",
              darkgoldenrod: "#b8860b",
              darkgray: "#a9a9a9",
              darkgreen: "#006400",
              darkkhaki: "#bdb76b",
              darkmagenta: "#8b008b",
              darkolivegreen: "#556b2f",
              darkorange: "#ff8c00",
              darkorchid: "#9932cc",
              darkred: "#8b0000",
              darksalmon: "#e9967a",
              darkseagreen: "#8fbc8f",
              darkslateblue: "#483d8b",
              darkslategray: "#2f4f4f",
              darkturquoise: "#00ced1",
              darkviolet: "#9400d3",
              deeppink: "#ff1493",
              deepskyblue: "#00bfff",
              dimgray: "#696969",
              dodgerblue: "#1e90ff",
              firebrick: "#b22222",
              floralwhite: "#fffaf0",
              forestgreen: "#228b22",
              fuchsia: "#ff00ff",
              gainsboro: "#dcdcdc",
              ghostwhite: "#f8f8ff",
              gold: "#ffd700",
              goldenrod: "#daa520",
              gray: "#808080",
              green: "#008000",
              greenyellow: "#adff2f",
              honeydew: "#f0fff0",
              hotpink: "#ff69b4",
              "indianred ": "#cd5c5c",
              indigo: "#4b0082",
              ivory: "#fffff0",
              khaki: "#f0e68c",
              lavender: "#e6e6fa",
              lavenderblush: "#fff0f5",
              lawngreen: "#7cfc00",
              lemonchiffon: "#fffacd",
              lightblue: "#add8e6",
              lightcoral: "#f08080",
              lightcyan: "#e0ffff",
              lightgoldenrodyellow: "#fafad2",
              lightgrey: "#d3d3d3",
              lightgreen: "#90ee90",
              lightpink: "#ffb6c1",
              lightsalmon: "#ffa07a",
              lightseagreen: "#20b2aa",
              lightskyblue: "#87cefa",
              lightslategray: "#778899",
              lightsteelblue: "#b0c4de",
              lightyellow: "#ffffe0",
              lime: "#00ff00",
              limegreen: "#32cd32",
              linen: "#faf0e6",
              magenta: "#ff00ff",
              maroon: "#800000",
              mediumaquamarine: "#66cdaa",
              mediumblue: "#0000cd",
              mediumorchid: "#ba55d3",
              mediumpurple: "#9370d8",
              mediumseagreen: "#3cb371",
              mediumslateblue: "#7b68ee",
              mediumspringgreen: "#00fa9a",
              mediumturquoise: "#48d1cc",
              mediumvioletred: "#c71585",
              midnightblue: "#191970",
              mintcream: "#f5fffa",
              mistyrose: "#ffe4e1",
              moccasin: "#ffe4b5",
              navajowhite: "#ffdead",
              navy: "#000080",
              oldlace: "#fdf5e6",
              olive: "#808000",
              olivedrab: "#6b8e23",
              orange: "#ffa500",
              orangered: "#ff4500",
              orchid: "#da70d6",
              palegoldenrod: "#eee8aa",
              palegreen: "#98fb98",
              paleturquoise: "#afeeee",
              palevioletred: "#d87093",
              papayawhip: "#ffefd5",
              peachpuff: "#ffdab9",
              peru: "#cd853f",
              pink: "#ffc0cb",
              plum: "#dda0dd",
              powderblue: "#b0e0e6",
              purple: "#800080",
              red: "#ff0000",
              rosybrown: "#bc8f8f",
              royalblue: "#4169e1",
              saddlebrown: "#8b4513",
              salmon: "#fa8072",
              sandybrown: "#f4a460",
              seagreen: "#2e8b57",
              seashell: "#fff5ee",
              sienna: "#a0522d",
              silver: "#c0c0c0",
              skyblue: "#87ceeb",
              slateblue: "#6a5acd",
              slategray: "#708090",
              snow: "#fffafa",
              springgreen: "#00ff7f",
              steelblue: "#4682b4",
              tan: "#d2b48c",
              teal: "#008080",
              thistle: "#d8bfd8",
              tomato: "#ff6347",
              turquoise: "#40e0d0",
              violet: "#ee82ee",
              wheat: "#f5deb3",
              white: "#ffffff",
              whitesmoke: "#f5f5f5",
              yellow: "#ffff00",
              yellowgreen: "#9acd32"
            };
            exports2["default"] = {
              /**
               * pad left zero characters.
               * @param {number} number number value to pad zero.
               * @param {number} length pad length to want.
               * @returns {string} padded string.
               */
              leadingZero: function leadingZero(number, length) {
                var zero = "";
                if (String(number).length > length) {
                  return String(number);
                }
                for (var i = 0; i < length - 1; i += 1) {
                  zero += "0";
                }
                return (zero + number).slice(length * -1);
              },
              /**
               * Check validate of hex string value is RGB
               * @param {string} str - rgb hex string
               * @returns {boolean} return true when supplied str is valid RGB hex string
               */
              isValidRGB: function isValidRGB(str) {
                return hexRX.test(str);
              },
              // @license RGB <-> HSV conversion utilities based off of http://www.cs.rit.edu/~ncs/color/t_convert.html
              /**
               * Convert color hex string to rgb number array
               * @param {string} hexStr - hex string
               * @returns {number[]} rgb numbers
               */
              hexToRGB: function hexToRGB(hexStr) {
                if (!this.isValidRGB(hexStr)) {
                  return false;
                }
                hexStr = hexStr.substring(1);
                var r = parseInt(hexStr.substr(0, 2), 16);
                var g = parseInt(hexStr.substr(2, 2), 16);
                var b = parseInt(hexStr.substr(4, 2), 16);
                return [r, g, b];
              },
              /**
               * Convert rgb number to hex string
               * @param {number} r - red
               * @param {number} g - green
               * @param {number} b - blue
               * @returns {string|boolean} return false when supplied rgb number is not valid. otherwise, converted hex string
               */
              rgbToHEX: function rgbToHEX(r, g, b) {
                var hexPreFix = "#";
                var hexStr = hexPreFix + this.leadingZero(r.toString(16), 2) + this.leadingZero(g.toString(16), 2) + this.leadingZero(b.toString(16), 2);
                if (this.isValidRGB(hexStr)) {
                  return hexStr;
                }
                return false;
              },
              /**
               * Color name to hex.
               * @param {string} colorName color name
               * @returns {string} hex
               */
              colorNameToHex: function colorNameToHex(colorName) {
                return colorMap[colorName.toLowerCase()] || colorName;
              }
            };
          },
          /* 168 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _pick = __webpack_require__(21);
            var _pick2 = _interopRequireDefault(_pick);
            var _chartBase = __webpack_require__(64);
            var _chartBase2 = _interopRequireDefault(_chartBase);
            var _colorSpectrum = __webpack_require__(166);
            var _colorSpectrum2 = _interopRequireDefault(_colorSpectrum);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var TreemapChart = function(_ChartBase) {
              _inherits(TreemapChart2, _ChartBase);
              function TreemapChart2(rawData, theme, options) {
                _classCallCheck(this, TreemapChart2);
                options.tooltip = options.tooltip || {};
                options.tooltip.grouped = false;
                var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
                  rawData,
                  theme,
                  options,
                  hasAxes: false,
                  isVertical: true
                }));
                _this.className = "tui-treemap-chart";
                return _this;
              }
              TreemapChart2.prototype.addComponents = function addComponents() {
                var seriesTheme = this.theme.series[this.chartType];
                var useColorValue = this.options.series.useColorValue;
                var colorSpectrum = useColorValue ? new _colorSpectrum2["default"](seriesTheme.startColor, seriesTheme.endColor) : null;
                this.componentManager.register("title", "title");
                this.componentManager.register("treemapSeries", "treemapSeries", {
                  colorSpectrum
                });
                if (useColorValue && this.options.legend.visible) {
                  this.componentManager.register("legend", "spectrumLegend", {
                    colorSpectrum
                  });
                }
                this.componentManager.register("tooltip", "tooltip", Object.assign({
                  labelTheme: (0, _pick2["default"])(this.theme, "series", "label"),
                  colorSpectrum
                }));
                this.componentManager.register("mouseEventDetector", "mouseEventDetector");
                this.componentManager.register("chartExportMenu", "chartExportMenu");
              };
              TreemapChart2.prototype.getScaleOption = function getScaleOption() {
                return {
                  legend: true
                };
              };
              TreemapChart2.prototype.addDataRatios = function addDataRatios(limitMap) {
                this.dataProcessor.addDataRatiosForTreemapChart(limitMap.legend, this.chartType);
              };
              TreemapChart2.prototype.onZoom = function onZoom(index) {
                this.componentManager.render("zoom", null, {
                  index
                });
              };
              return TreemapChart2;
            }(_chartBase2["default"]);
            exports2["default"] = TreemapChart;
          },
          /* 169 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _chartBase = __webpack_require__(64);
            var _chartBase2 = _interopRequireDefault(_chartBase);
            var _mapManager = __webpack_require__(54);
            var _mapManager2 = _interopRequireDefault(_mapManager);
            var _mapChartMapModel = __webpack_require__(170);
            var _mapChartMapModel2 = _interopRequireDefault(_mapChartMapModel);
            var _mapChartDataProcessor = __webpack_require__(171);
            var _mapChartDataProcessor2 = _interopRequireDefault(_mapChartDataProcessor);
            var _colorSpectrum = __webpack_require__(166);
            var _colorSpectrum2 = _interopRequireDefault(_colorSpectrum);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var MapChart = function(_ChartBase) {
              _inherits(MapChart2, _ChartBase);
              function MapChart2(rawData, theme, options) {
                _classCallCheck(this, MapChart2);
                options.map = _mapManager2["default"].get(options.map);
                options.tooltip = options.tooltip || {};
                options.legend = options.legend || {};
                var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
                  rawData,
                  theme,
                  options,
                  DataProcessor: _mapChartDataProcessor2["default"]
                }));
                _this.className = "tui-map-chart";
                return _this;
              }
              MapChart2.prototype.addComponents = function addComponents() {
                var seriesTheme = this.theme.series[this.chartType];
                var colorSpectrum = new _colorSpectrum2["default"](seriesTheme.startColor, seriesTheme.endColor);
                this.mapModel = new _mapChartMapModel2["default"](this.dataProcessor, this.options.map);
                this.componentManager.register("mapSeries", "mapSeries", {
                  mapModel: this.mapModel,
                  colorSpectrum
                });
                this.componentManager.register("title", "title");
                this.componentManager.register("legend", "spectrumLegend", {
                  colorSpectrum
                });
                this.componentManager.register("tooltip", "tooltip", {
                  mapModel: this.mapModel,
                  colorSpectrum
                });
                this.componentManager.register("zoom", "zoom");
                this.componentManager.register("mouseEventDetector", "mapChartEventDetector");
              };
              MapChart2.prototype.setData = function setData() {
                var rawData = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                this.mapModel.clearMapData();
                _ChartBase.prototype.setData.call(this, rawData);
              };
              MapChart2.prototype.getScaleOption = function getScaleOption() {
                return {
                  legend: true
                };
              };
              MapChart2.prototype.addDataRatios = function addDataRatios(limitMap) {
                this.dataProcessor.addDataRatios(limitMap.legend);
              };
              return MapChart2;
            }(_chartBase2["default"]);
            exports2["default"] = MapChart;
          },
          /* 170 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isUndefined = __webpack_require__(14);
            var _isUndefined2 = _interopRequireDefault(_isUndefined);
            var _pluck = __webpack_require__(58);
            var _pluck2 = _interopRequireDefault(_pluck);
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _arrayUtil = __webpack_require__(27);
            var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var MapChartMapModel = function() {
              function MapChartMapModel2(dataProcessor, rawMapData) {
                _classCallCheck(this, MapChartMapModel2);
                this.commandFuncMap = {
                  M: this._makeCoordinate.bind(this),
                  m: this._makeCoordinateFromRelativeCoordinate.bind(this),
                  L: this._makeCoordinate.bind(this),
                  l: this._makeCoordinateFromRelativeCoordinate.bind(this),
                  H: this._makeXCoordinate.bind(this),
                  h: this._makeXCoordinateFroRelativeCoordinate.bind(this),
                  V: this._makeYCoordinate.bind(this),
                  v: this._makeYCoordinateFromRelativeCoordinate.bind(this)
                };
                this.ignoreCommandMap = {
                  Z: true,
                  z: true
                };
                this.mapDimension = null;
                this.dataProcessor = dataProcessor;
                this.rawMapData = rawMapData;
                this.mapData = null;
              }
              MapChartMapModel2.prototype._splitCoordinate = function _splitCoordinate(coordinateStr) {
                var coordinates = coordinateStr.split(",");
                var result = {
                  x: parseFloat(coordinates[0])
                };
                if (coordinates[1]) {
                  result.y = parseFloat(coordinates[1]);
                }
                return result;
              };
              MapChartMapModel2.prototype._makeCoordinate = function _makeCoordinate(coordinateStr) {
                return this._splitCoordinate(coordinateStr);
              };
              MapChartMapModel2.prototype._makeCoordinateFromRelativeCoordinate = function _makeCoordinateFromRelativeCoordinate(coordinateStr, prevCoordinate) {
                var coordinate = this._splitCoordinate(coordinateStr);
                return {
                  x: coordinate.x + prevCoordinate.x,
                  y: coordinate.y + prevCoordinate.y
                };
              };
              MapChartMapModel2.prototype._makeXCoordinate = function _makeXCoordinate(coordinateStr) {
                var coordinate = this._splitCoordinate(coordinateStr);
                return {
                  x: coordinate.x
                };
              };
              MapChartMapModel2.prototype._makeXCoordinateFroRelativeCoordinate = function _makeXCoordinateFroRelativeCoordinate(coordinateStr, prevCoordinate) {
                var coordinate = this._splitCoordinate(coordinateStr);
                return {
                  x: coordinate.x + prevCoordinate.x
                };
              };
              MapChartMapModel2.prototype._makeYCoordinate = function _makeYCoordinate(coordinateStr) {
                var coordinate = this._splitCoordinate(coordinateStr);
                return {
                  y: coordinate.x
                };
              };
              MapChartMapModel2.prototype._makeYCoordinateFromRelativeCoordinate = function _makeYCoordinateFromRelativeCoordinate(coordinateStr, prevCoordinate) {
                var coordinate = this._splitCoordinate(coordinateStr);
                return {
                  y: coordinate.x + prevCoordinate.y
                };
              };
              MapChartMapModel2.prototype._splitPath = function _splitPath(path) {
                var len = path.length;
                var pathData = [];
                var coordinate = "";
                var commandType = void 0;
                for (var i = 0; i < len; i += 1) {
                  var chr = path.charAt(i);
                  if (this.commandFuncMap[chr]) {
                    if (commandType && coordinate) {
                      pathData.push({
                        type: commandType,
                        coordinate
                      });
                    }
                    commandType = chr;
                    coordinate = "";
                  } else if (!this.ignoreCommandMap[chr]) {
                    coordinate += chr;
                  }
                }
                this._addCommandPath(pathData, {
                  commandType,
                  coordinate
                });
                return pathData;
              };
              MapChartMapModel2.prototype._addCommandPath = function _addCommandPath(pathData) {
                var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, commandType = _ref.commandType, coordinate = _ref.coordinate;
                if (commandType && coordinate) {
                  pathData.push({
                    type: commandType,
                    coordinate
                  });
                }
              };
              MapChartMapModel2.prototype._makeCoordinatesFromPath = function _makeCoordinatesFromPath(path) {
                var _this = this;
                var pathData = this._splitPath(path);
                var prevCoordinate = {
                  x: 0,
                  y: 0
                };
                return pathData.map(function(datum) {
                  var commandFunc = _this.commandFuncMap[datum.type];
                  var coordinate = commandFunc(datum.coordinate, prevCoordinate);
                  Object.assign(prevCoordinate, coordinate);
                  return coordinate;
                });
              };
              MapChartMapModel2.prototype._findBoundFromCoordinates = function _findBoundFromCoordinates(coordinates) {
                var xs = (0, _pluck2["default"])(coordinates, "x").filter(function(x) {
                  return !(0, _isUndefined2["default"])(x);
                });
                var ys = (0, _pluck2["default"])(coordinates, "y").filter(function(y) {
                  return !(0, _isUndefined2["default"])(y);
                });
                var maxLeft = _arrayUtil2["default"].max(xs);
                var minLeft = _arrayUtil2["default"].min(xs);
                var maxTop = _arrayUtil2["default"].max(ys);
                var minTop = _arrayUtil2["default"].min(ys);
                return {
                  dimension: {
                    width: maxLeft - minLeft,
                    height: maxTop - minTop
                  },
                  position: {
                    left: minLeft,
                    top: minTop
                  }
                };
              };
              MapChartMapModel2.prototype._makeLabelPosition = function _makeLabelPosition(bound, positionRatio) {
                positionRatio = positionRatio || _const2["default"].MAP_CHART_LABEL_DEFAULT_POSITION_RATIO;
                return {
                  left: bound.position.left + bound.dimension.width * positionRatio.x,
                  top: bound.position.top + bound.dimension.height * positionRatio.y
                };
              };
              MapChartMapModel2.prototype._createMapData = function _createMapData(rawMapData) {
                var _this2 = this;
                return rawMapData.map(function(datum) {
                  var coordinate = _this2._makeCoordinatesFromPath(datum.path);
                  var bound = _this2._findBoundFromCoordinates(coordinate);
                  var userData = _this2.dataProcessor.getValueMapDatum(datum.code);
                  var name = void 0, labelCoordinate = void 0, label = void 0, ratio = void 0;
                  if (userData) {
                    label = userData.label;
                    ratio = userData.ratio;
                    name = userData.name || datum.name;
                    labelCoordinate = userData.labelCoordinate || datum.labelCoordinate;
                  }
                  var resultData = {
                    code: datum.code,
                    name,
                    path: datum.path,
                    bound,
                    labelPosition: _this2._makeLabelPosition(bound, labelCoordinate)
                  };
                  if (label) {
                    resultData.label = label;
                  }
                  if (ratio >= 0) {
                    resultData.ratio = ratio;
                  }
                  return resultData;
                });
              };
              MapChartMapModel2.prototype.clearMapData = function clearMapData() {
                this.mapData = null;
              };
              MapChartMapModel2.prototype.getMapData = function getMapData() {
                if (!this.mapData) {
                  this.mapData = this._createMapData(this.rawMapData);
                }
                return this.mapData;
              };
              MapChartMapModel2.prototype.getDatum = function getDatum(index) {
                return this.getMapData()[index];
              };
              MapChartMapModel2.prototype.getLabelData = function getLabelData(ratio) {
                var _this3 = this;
                var mapData = this.getMapData();
                var labelData = mapData.filter(function(datum) {
                  return _this3.dataProcessor.getValueMapDatum(datum.code);
                });
                return labelData.map(function(datum) {
                  return {
                    name: datum.name,
                    labelPosition: {
                      left: datum.labelPosition.left * ratio,
                      top: datum.labelPosition.top * ratio
                    }
                  };
                });
              };
              MapChartMapModel2.prototype._makeMapDimension = function _makeMapDimension() {
                var mapData = this.getMapData();
                var lefts = mapData.map(function(datum) {
                  return datum.bound.position.left;
                });
                var rights = mapData.map(function(datum) {
                  return datum.bound.position.left + datum.bound.dimension.width;
                });
                var tops = mapData.map(function(datum) {
                  return datum.bound.position.top;
                });
                var bottoms = mapData.map(function(datum) {
                  return datum.bound.position.top + datum.bound.dimension.height;
                });
                return {
                  width: _arrayUtil2["default"].max(rights) - _arrayUtil2["default"].min(lefts),
                  height: _arrayUtil2["default"].max(bottoms) - _arrayUtil2["default"].min(tops)
                };
              };
              MapChartMapModel2.prototype.getMapDimension = function getMapDimension() {
                if (!this.mapDimension) {
                  this.mapDimension = this._makeMapDimension();
                }
                return this.mapDimension;
              };
              return MapChartMapModel2;
            }();
            exports2["default"] = MapChartMapModel;
          },
          /* 171 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _pluck = __webpack_require__(58);
            var _pluck2 = _interopRequireDefault(_pluck);
            var _dataProcessorBase = __webpack_require__(131);
            var _dataProcessorBase2 = _interopRequireDefault(_dataProcessorBase);
            var _renderUtil = __webpack_require__(17);
            var _renderUtil2 = _interopRequireDefault(_renderUtil);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var MapChartDataProcessor = function(_DataProcessorBase) {
              _inherits(MapChartDataProcessor2, _DataProcessorBase);
              function MapChartDataProcessor2(rawData, chartType, options) {
                _classCallCheck(this, MapChartDataProcessor2);
                var _this = _possibleConstructorReturn(this, _DataProcessorBase.call(this));
                _this.rawData = rawData;
                _this.options = options;
                return _this;
              }
              MapChartDataProcessor2.prototype.initData = function initData(rawData) {
                this.rawData = rawData;
                this.valueMap = null;
              };
              MapChartDataProcessor2.prototype._makeValueMap = function _makeValueMap() {
                var rawSeriesData = this.rawData.series.map;
                var valueMap = {};
                var formatFunctions = this._findFormatFunctions();
                rawSeriesData.forEach(function(datum) {
                  var result = {
                    value: datum.data,
                    label: _renderUtil2["default"].formatValue({
                      value: datum.data,
                      formatFunctions,
                      chartType: "map",
                      areaType: "series"
                    })
                  };
                  if (datum.name) {
                    result.name = datum.name;
                  }
                  if (datum.labelCoordinate) {
                    result.labelCoordinate = datum.labelCoordinate;
                  }
                  valueMap[datum.code] = result;
                });
                return valueMap;
              };
              MapChartDataProcessor2.prototype.getValueMap = function getValueMap() {
                if (!this.valueMap) {
                  this.valueMap = this._makeValueMap();
                }
                return this.valueMap;
              };
              MapChartDataProcessor2.prototype.getValues = function getValues() {
                return (0, _pluck2["default"])(this.getValueMap(), "value");
              };
              MapChartDataProcessor2.prototype.getCurrentData = function getCurrentData() {
                return this.rawData;
              };
              MapChartDataProcessor2.prototype.getValueMapDatum = function getValueMapDatum(code) {
                return this.getValueMap()[code];
              };
              MapChartDataProcessor2.prototype.addDataRatios = function addDataRatios(limit) {
                var min = limit.min;
                var max = limit.max - min;
                var maps = Object.values(this.getValueMap());
                maps.forEach(function(map) {
                  map.ratio = (map.value - min) / max;
                });
              };
              MapChartDataProcessor2.prototype.createBaseValuesForLimit = function createBaseValuesForLimit() {
                return this.getValues();
              };
              MapChartDataProcessor2.prototype.getLegendVisibility = function getLegendVisibility() {
                return null;
              };
              return MapChartDataProcessor2;
            }(_dataProcessorBase2["default"]);
            exports2["default"] = MapChartDataProcessor;
          },
          /* 172 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _chartBase = __webpack_require__(64);
            var _chartBase2 = _interopRequireDefault(_chartBase);
            var _lineChartSeries = __webpack_require__(113);
            var _lineChartSeries2 = _interopRequireDefault(_lineChartSeries);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var RadialChart = function(_ChartBase) {
              _inherits(RadialChart2, _ChartBase);
              function RadialChart2(rawData, theme, options) {
                _classCallCheck(this, RadialChart2);
                if (options.tooltip) {
                  options.tooltip.grouped = false;
                }
                var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
                  rawData,
                  theme,
                  options,
                  hasAxes: true,
                  isVertical: true
                }));
                _this.className = "tui-radial-chart";
                _this.Series = _lineChartSeries2["default"];
                return _this;
              }
              RadialChart2.prototype.addComponents = function addComponents() {
                this.componentManager.register("title", "title");
                this.componentManager.register("legend", "legend");
                this.componentManager.register("plot", "radialPlot");
                this.componentManager.register("radialSeries", "radialSeries");
                this.componentManager.register("chartExportMenu", "chartExportMenu");
                this.componentManager.register("tooltip", "tooltip");
                this.componentManager.register("mouseEventDetector", "mouseEventDetector");
              };
              RadialChart2.prototype.addDataRatios = function addDataRatios(limitMap) {
                this.dataProcessor.addDataRatios(limitMap[this.chartType], null, this.chartType);
              };
              RadialChart2.prototype.getScaleOption = function getScaleOption() {
                return {
                  yAxis: {}
                };
              };
              return RadialChart2;
            }(_chartBase2["default"]);
            exports2["default"] = RadialChart;
          },
          /* 173 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _chartBase = __webpack_require__(64);
            var _chartBase2 = _interopRequireDefault(_chartBase);
            var _rawDataHandler = __webpack_require__(50);
            var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var BoxplotChart = function(_ChartBase) {
              _inherits(BoxplotChart2, _ChartBase);
              function BoxplotChart2(rawData, theme, options) {
                _classCallCheck(this, BoxplotChart2);
                _rawDataHandler2["default"].appendOutliersToSeriesData(rawData);
                var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
                  rawData,
                  theme,
                  options,
                  hasAxes: true,
                  isVertical: true
                }));
                _this.className = "tui-boxplot-chart";
                return _this;
              }
              BoxplotChart2.prototype.addComponents = function addComponents() {
                this.componentManager.register("title", "title");
                this.componentManager.register("plot", "plot");
                this.componentManager.register("legend", "legend");
                this.componentManager.register("boxplotSeries", "boxplotSeries");
                this.componentManager.register("yAxis", "axis");
                this.componentManager.register("xAxis", "axis");
                this.componentManager.register("chartExportMenu", "chartExportMenu");
                this.componentManager.register("tooltip", "tooltip");
                this.componentManager.register("mouseEventDetector", "mouseEventDetector");
              };
              BoxplotChart2.prototype.getScaleOption = function getScaleOption() {
                return {
                  yAxis: true
                };
              };
              BoxplotChart2.prototype.onChangeCheckedLegends = function onChangeCheckedLegends(checkedLegends) {
                var boundParams = void 0;
                if (this.hasRightYAxis) {
                  boundParams = {
                    optionChartTypes: ["boxplot", "boxplot"]
                  };
                }
                _chartBase2["default"].prototype.onChangeCheckedLegends.call(this, checkedLegends, null, boundParams);
              };
              BoxplotChart2.prototype.addDataRatios = function addDataRatios(limitMap) {
                var _options$series = this.options.series, seriesOption = _options$series === void 0 ? {} : _options$series, chartType = this.chartType;
                var _ref = seriesOption[chartType] || seriesOption, stack = _ref.stack;
                this.dataProcessor.addDataRatios(limitMap[chartType], stack, chartType);
              };
              return BoxplotChart2;
            }(_chartBase2["default"]);
            exports2["default"] = BoxplotChart;
          },
          /* 174 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _chartBase = __webpack_require__(64);
            var _chartBase2 = _interopRequireDefault(_chartBase);
            var _rawDataHandler = __webpack_require__(50);
            var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var BulletChart = function(_ChartBase) {
              _inherits(BulletChart2, _ChartBase);
              function BulletChart2(rawData, theme, options) {
                _classCallCheck(this, BulletChart2);
                _rawDataHandler2["default"]._makeRawSeriesDataForBulletChart(rawData);
                var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
                  rawData,
                  theme,
                  options,
                  hasAxes: true,
                  isVertical: !!options.series.vertical
                }));
                _this.className = "tui-bullet-chart";
                return _this;
              }
              BulletChart2.prototype.addComponents = function addComponents() {
                this.componentManager.register("title", "title");
                this.componentManager.register("plot", "plot");
                this.componentManager.register("legend", "legend");
                this.componentManager.register("bulletSeries", "bulletSeries");
                this.componentManager.register("yAxis", "axis");
                this.componentManager.register("xAxis", "axis");
                this.componentManager.register("chartExportMenu", "chartExportMenu", {
                  chartType: "bullet"
                });
                this.componentManager.register("tooltip", "tooltip");
                this.componentManager.register("mouseEventDetector", "mouseEventDetector");
              };
              BulletChart2.prototype.getScaleOption = function getScaleOption() {
                if (this.isVertical) {
                  return {
                    yAxis: true
                  };
                }
                return {
                  xAxis: true
                };
              };
              BulletChart2.prototype.addDataRatios = function addDataRatios(limitMap) {
                this.dataProcessor.addDataRatios(limitMap[this.chartType], null, this.chartType);
              };
              return BulletChart2;
            }(_chartBase2["default"]);
            exports2["default"] = BulletChart;
          },
          /* 175 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _const = __webpack_require__(23);
            var _const2 = _interopRequireDefault(_const);
            var _themeManager = __webpack_require__(52);
            var _themeManager2 = _interopRequireDefault(_themeManager);
            var _defaultTheme = __webpack_require__(53);
            var _defaultTheme2 = _interopRequireDefault(_defaultTheme);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            }
            _themeManager2["default"].register(_const2["default"].DEFAULT_THEME_NAME, _defaultTheme2["default"]);
          },
          /* 176 */
          /***/
          function(module2, exports2) {
          }
        ])
      );
    });
  }
});

export {
  require_tui_chart
};
/*! Bundled license information:

tui-chart/dist/tui-chart.js:
  (*!
   * tui-chart
   * @fileoverview tui-chart
   * @author NHN. FE Development Lab <dl_javascript@nhn.com>
   * @version 3.11.3
   * @license MIT
   * @link https://github.com/nhn/tui.chart
   * bundle created at "Fri Jan 29 2021 15:51:40 GMT+0900 (Korean Standard Time)"
   *)
*/
//# sourceMappingURL=chunk-NNIZL33Y.js.map
